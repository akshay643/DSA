{
  "category": {
    "id": "linked-lists",
    "name": "Linked Lists",
    "description": "Linked list operations and manipulations"
  },
  "questions": [
    
   
     {
    "id": "linked-lists-1",
    "title": "Reverse Linked List",
    "category": "linked-lists",
    "difficulty": "easy",
    "companies": ["Amazon", "Microsoft", "Facebook", "Google", "Apple", "Bloomberg"],
    "introduction": "Reversing a linked list is one of the most fundamental linked list operations. Given the head of a singly linked list, reverse the list and return the new head. This problem has both iterative and recursive solutions.",
    "problemStatement": "Given the head of a singly linked list, reverse the list, and return the reversed list.\n\nConstraints:\n- The number of nodes in the list is the range [0, 5000]\n- -5000 <= Node.val <= 5000",
    "examples": [
      {
        "input": "head = [1,2,3,4,5]",
        "output": "[5,4,3,2,1]",
        "explanation": "The list 1->2->3->4->5 becomes 5->4->3->2->1."
      },
      {
        "input": "head = [1,2]",
        "output": "[2,1]",
        "explanation": "The list 1->2 becomes 2->1."
      },
      {
        "input": "head = []",
        "output": "[]",
        "explanation": "Empty list remains empty."
      }
    ],
    "hints": [
      "Use three pointers: prev, curr, next",
      "Save next node before changing pointer",
      "Point current node's next to previous node",
      "Move prev and curr one step forward",
      "When curr is null, prev is the new head"
    ],
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1) iterative, O(n) recursive",
    "tags": ["linked-list", "recursion"],
    "links": {
      "leetcode": "https://leetcode.com/problems/reverse-linked-list/",
      "gfg": "https://www.geeksforgeeks.org/reverse-a-linked-list/"
    },
    "testCases": [
      {
        "input": {"head": [1,2,3,4,5]},
        "output": [5,4,3,2,1]
      },
      {
        "input": {"head": [1,2]},
        "output": [2,1]
      },
      {
        "input": {"head": []},
        "output": []
      }
    ],
    "starterCode": {
      "javascript": "function reverseList(head) {\n  // Write your code here\n  // ListNode structure: { val: number, next: ListNode }\n  \n}",
      "python": "def reverse_list(head):\n    # Write your code here\n    # ListNode has val and next\n    pass",
      "java": "public ListNode reverseList(ListNode head) {\n    // Write your code here\n    return null;\n}"
    }
  },
  {
    "id": "linked-lists-2",
    "title": "Merge Two Sorted Lists",
    "category": "linked-lists",
    "difficulty": "easy",
    "companies": ["Amazon", "Microsoft", "Facebook", "Google", "Apple", "Bloomberg"],
    "introduction": "Merging two sorted linked lists into one sorted list is a fundamental operation used as a building block in merge sort and other algorithms. The resulting list should be made by splicing together the nodes of the first two lists.",
    "problemStatement": "You are given the heads of two sorted linked lists list1 and list2.\n\nMerge the two lists into one sorted list. The list should be made by splicing together the nodes of the first two lists.\n\nReturn the head of the merged linked list.\n\nConstraints:\n- The number of nodes in both lists is in the range [0, 50]\n- -100 <= Node.val <= 100\n- Both list1 and list2 are sorted in non-decreasing order",
    "examples": [
      {
        "input": "list1 = [1,2,4], list2 = [1,3,4]",
        "output": "[1,1,2,3,4,4]",
        "explanation": "Merging 1->2->4 and 1->3->4 gives 1->1->2->3->4->4."
      },
      {
        "input": "list1 = [], list2 = []",
        "output": "[]",
        "explanation": "Both lists are empty."
      },
      {
        "input": "list1 = [], list2 = [0]",
        "output": "[0]",
        "explanation": "One list is empty."
      }
    ],
    "hints": [
      "Use a dummy head node to simplify edge cases",
      "Compare values and append smaller one",
      "Move pointer of the list from which node was taken",
      "When one list is exhausted, append remaining of other",
      "Can also solve recursively"
    ],
    "timeComplexity": "O(n + m) where n and m are list lengths",
    "spaceComplexity": "O(1) iterative, O(n + m) recursive",
    "tags": ["linked-list", "recursion"],
    "links": {
      "leetcode": "https://leetcode.com/problems/merge-two-sorted-lists/",
      "gfg": "https://www.geeksforgeeks.org/merge-two-sorted-linked-lists/"
    },
    "testCases": [
      {
        "input": {"list1": [1,2,4], "list2": [1,3,4]},
        "output": [1,1,2,3,4,4]
      },
      {
        "input": {"list1": [], "list2": []},
        "output": []
      },
      {
        "input": {"list1": [], "list2": [0]},
        "output": [0]
      }
    ],
    "starterCode": {
      "javascript": "function mergeTwoLists(list1, list2) {\n  // Write your code here\n  \n}",
      "python": "def merge_two_lists(list1, list2):\n    # Write your code here\n    pass",
      "java": "public ListNode mergeTwoLists(ListNode list1, ListNode list2) {\n    // Write your code here\n    return null;\n}"
    }
  },
  {
    "id": "linked-lists-3",
    "title": "Linked List Cycle",
    "category": "linked-lists",
    "difficulty": "easy",
    "companies": ["Amazon", "Microsoft", "Facebook", "Google", "Apple"],
    "introduction": "Detecting a cycle in a linked list is a classic problem solved using Floyd's Cycle Detection Algorithm (also known as the tortoise and hare algorithm). If a cycle exists, a slow pointer and fast pointer will eventually meet.",
    "problemStatement": "Given head, the head of a linked list, determine if the linked list has a cycle in it.\n\nThere is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. Internally, pos is used to denote the index of the node that tail's next pointer is connected to. Note that pos is not passed as a parameter.\n\nReturn true if there is a cycle in the linked list. Otherwise, return false.\n\nConstraints:\n- The number of the nodes in the list is in the range [0, 10⁴]\n- -10⁵ <= Node.val <= 10⁵\n- pos is -1 or a valid index in the linked-list",
    "examples": [
      {
        "input": "head = [3,2,0,-4], pos = 1",
        "output": "true",
        "explanation": "There is a cycle in the linked list, where the tail connects to the 1st node (0-indexed)."
      },
      {
        "input": "head = [1,2], pos = 0",
        "output": "true",
        "explanation": "There is a cycle in the linked list, where the tail connects to the 0th node."
      },
      {
        "input": "head = [1], pos = -1",
        "output": "false",
        "explanation": "There is no cycle in the linked list."
      }
    ],
    "hints": [
      "Use Floyd's Cycle Detection (slow and fast pointers)",
      "Slow pointer moves one step, fast moves two",
      "If they meet, there's a cycle",
      "If fast reaches null, there's no cycle",
      "O(1) space solution is expected"
    ],
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "tags": ["linked-list", "two-pointers", "hash-table"],
    "links": {
      "leetcode": "https://leetcode.com/problems/linked-list-cycle/",
      "gfg": "https://www.geeksforgeeks.org/detect-loop-in-a-linked-list/"
    },
    "testCases": [
      {
        "input": {"head": [3,2,0,-4], "pos": 1},
        "output": true
      },
      {
        "input": {"head": [1,2], "pos": 0},
        "output": true
      },
      {
        "input": {"head": [1], "pos": -1},
        "output": false
      }
    ],
    "starterCode": {
      "javascript": "function hasCycle(head) {\n  // Write your code here\n  \n}",
      "python": "def has_cycle(head):\n    # Write your code here\n    pass",
      "java": "public boolean hasCycle(ListNode head) {\n    // Write your code here\n    return false;\n}"
    }
  },
  {
    "id": "linked-lists-4",
    "title": "Remove Nth Node From End of List",
    "category": "linked-lists",
    "difficulty": "medium",
    "companies": ["Amazon", "Facebook", "Google", "Microsoft", "Apple", "Bloomberg"],
    "introduction": "This problem requires removing the nth node from the end of a linked list in one pass. The elegant solution uses two pointers with a gap of n nodes between them.",
    "problemStatement": "Given the head of a linked list, remove the nth node from the end of the list and return its head.\n\nConstraints:\n- The number of nodes in the list is sz\n- 1 <= sz <= 30\n- 0 <= Node.val <= 100\n- 1 <= n <= sz",
    "examples": [
      {
        "input": "head = [1,2,3,4,5], n = 2",
        "output": "[1,2,3,5]",
        "explanation": "Remove the 2nd node from the end (node 4)."
      },
      {
        "input": "head = [1], n = 1",
        "output": "[]",
        "explanation": "Remove the only node."
      },
      {
        "input": "head = [1,2], n = 1",
        "output": "[1]",
        "explanation": "Remove the last node."
      }
    ],
    "hints": [
      "Use two pointers with n nodes gap",
      "Move fast pointer n steps ahead first",
      "Then move both until fast reaches end",
      "Slow pointer will be at node before target",
      "Use dummy node to handle edge case of removing head"
    ],
    "timeComplexity": "O(n) - one pass",
    "spaceComplexity": "O(1)",
    "tags": ["linked-list", "two-pointers"],
    "links": {
      "leetcode": "https://leetcode.com/problems/remove-nth-node-from-end-of-list/",
      "gfg": "https://www.geeksforgeeks.org/remove-nth-node-from-end-of-the-linked-list/"
    },
    "testCases": [
      {
        "input": {"head": [1,2,3,4,5], "n": 2},
        "output": [1,2,3,5]
      },
      {
        "input": {"head": [1], "n": 1},
        "output": []
      },
      {
        "input": {"head": [1,2], "n": 1},
        "output": [1]
      }
    ],
    "starterCode": {
      "javascript": "function removeNthFromEnd(head, n) {\n  // Write your code here\n  \n}",
      "python": "def remove_nth_from_end(head, n):\n    # Write your code here\n    pass",
      "java": "public ListNode removeNthFromEnd(ListNode head, int n) {\n    // Write your code here\n    return null;\n}"
    }
  },
  {
    "id": "linked-lists-5",
    "title": "Merge K Sorted Lists",
    "category": "linked-lists",
    "difficulty": "hard",
    "companies": ["Amazon", "Facebook", "Google", "Microsoft", "Apple", "Uber", "Bloomberg"],
    "introduction": "Merging K sorted linked lists is an extension of merging two sorted lists. The optimal solution uses a min-heap (priority queue) to efficiently find the smallest element among all list heads.",
    "problemStatement": "You are given an array of k linked-lists lists, each linked-list is sorted in ascending order.\n\nMerge all the linked-lists into one sorted linked-list and return it.\n\nConstraints:\n- k == lists.length\n- 0 <= k <= 10⁴\n- 0 <= lists[i].length <= 500\n- -10⁴ <= lists[i][j] <= 10⁴\n- lists[i] is sorted in ascending order\n- The sum of lists[i].length will not exceed 10⁴",
    "examples": [
      {
        "input": "lists = [[1,4,5],[1,3,4],[2,6]]",
        "output": "[1,1,2,3,4,4,5,6]",
        "explanation": "Merging all three sorted lists into one sorted list."
      },
      {
        "input": "lists = []",
        "output": "[]",
        "explanation": "Empty input."
      },
      {
        "input": "lists = [[]]",
        "output": "[]",
        "explanation": "One empty list."
      }
    ],
    "hints": [
      "Use a min-heap to track smallest node among all lists",
      "Initially add head of each non-empty list to heap",
      "Pop smallest, add to result, push its next to heap",
      "Alternative: divide and conquer (merge pairs recursively)",
      "Alternative: merge lists one by one (less efficient)"
    ],
    "timeComplexity": "O(N log k) where N is total nodes and k is number of lists",
    "spaceComplexity": "O(k) for heap",
    "tags": ["linked-list", "heap", "divide-and-conquer", "merge-sort"],
    "links": {
      "leetcode": "https://leetcode.com/problems/merge-k-sorted-lists/",
      "gfg": "https://www.geeksforgeeks.org/merge-k-sorted-linked-lists/"
    },
    "testCases": [
      {
        "input": {"lists": [[1,4,5],[1,3,4],[2,6]]},
        "output": [1,1,2,3,4,4,5,6]
      },
      {
        "input": {"lists": []},
        "output": []
      },
      {
        "input": {"lists": [[]]},
        "output": []
      }
    ],
    "starterCode": {
      "javascript": "function mergeKLists(lists) {\n  // Write your code here\n  \n}",
      "python": "def merge_k_lists(lists):\n    # Write your code here\n    pass",
      "java": "public ListNode mergeKLists(ListNode[] lists) {\n    // Write your code here\n    return null;\n}"
    }
  },
   {
      "id": "linked-lists-6",
      "title": "Reverse Linked List",
      "category": "linked-lists",
      "difficulty": "easy",
      "companies": [
        "Amazon",
        "Microsoft",
        "Facebook",
        "Google"
      ],
      "introduction": "Given the head of a singly linked list, reverse the list, and return the reversed list.",
      "problemStatement": "Reverse a singly linked list.\n\nConstraints:\n- The number of nodes in the list is in the range [0, 5000]\n- -5000 <= Node.val <= 5000",
      "examples": [
        {
          "input": "head = [1,2,3,4,5]",
          "output": "[5,4,3,2,1]",
          "explanation": "The linked list is reversed."
        }
      ],
      "hints": [
        "Use three pointers: prev, current, next",
        "Iterate through the list reversing pointers",
        "Can also be solved recursively"
      ],
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(1) iterative, O(n) recursive",
      "tags": [
        "linked-list",
        "recursion"
      ],
      "links": {
        "leetcode": "https://leetcode.com/problems/reverse-linked-list/",
        "gfg": "https://www.geeksforgeeks.org/reverse-a-linked-list/"
      },
      "testCases": [
        {
          "input": {
            "head": [
              1,
              2,
              3,
              4,
              5
            ]
          },
          "output": [
            5,
            4,
            3,
            2,
            1
          ]
        },
        {
          "input": {
            "head": [
              1,
              2
            ]
          },
          "output": [
            2,
            1
          ]
        },
        {
          "input": {
            "head": []
          },
          "output": []
        },
        {
          "input": {
            "head": [
              1
            ]
          },
          "output": [
            1
          ]
        }
      ],
      "starterCode": {
        "javascript": "function reverseList(head) {\n  // Write your code here\n  // Example: head = [1,2,3,4,5]\n  // Expected output: [5,4,3,2,1]\n  \n}\n\n// Test cases (assuming ListNode class exists)\nconsole.log('Test 1:', reverseList([1,2,3,4,5])); // [5,4,3,2,1]\nconsole.log('Test 2:', reverseList([1,2])); // [2,1]\nconsole.log('Test 3:', reverseList([])); // []",
        "python": "def reverse_list(head):\n    # Write your code here\n    # Example: head = [1,2,3,4,5]\n    # Expected output: [5,4,3,2,1]\n    pass\n\n# Test cases\nprint('Test 1:', reverse_list([1,2,3,4,5]))  # [5,4,3,2,1]\nprint('Test 2:', reverse_list([1,2]))  # [2,1]\nprint('Test 3:', reverse_list([]))  # []",
        "java": "public ListNode reverseList(ListNode head) {\n    // Write your code here\n    // Example: head = [1,2,3,4,5]\n    // Expected output: [5,4,3,2,1]\n    return null;\n}\n\n// Test in main\npublic static void main(String[] args) {\n    Solution sol = new Solution();\n    // Assuming ListNode helper methods exist\n    System.out.println(sol.reverseList(createList(new int[]{1,2,3,4,5})));\n}"
      }
    },
    {
    "id": "linked-lists-7",
    "title": "Reorder List",
    "category": "linked-lists",
    "difficulty": "medium",
    "companies": ["Amazon", "Facebook", "Microsoft", "Google", "Bloomberg"],
    "introduction": "Given a linked list, reorder it such that the first node is followed by the last, then the second by the second-last, and so on. This combines finding middle, reversing second half, and merging.",
    "problemStatement": "You are given the head of a singly linked-list. The list can be represented as:\n\nL0 → L1 → ... → Ln-1 → Ln\n\nReorder the list to be on the following form:\n\nL0 → Ln → L1 → Ln-1 → L2 → Ln-2 → ...\n\nYou may not modify the values in the list's nodes. Only nodes themselves may be changed.\n\nConstraints:\n- The number of nodes in the list is in the range [1, 5 × 10⁴]\n- 1 <= Node.val <= 1000",
    "examples": [
      {
        "input": "head = [1,2,3,4]",
        "output": "[1,4,2,3]",
        "explanation": "Reorder: 1 → 4 → 2 → 3."
      },
      {
        "input": "head = [1,2,3,4,5]",
        "output": "[1,5,2,4,3]",
        "explanation": "Reorder: 1 → 5 → 2 → 4 → 3."
      }
    ],
    "hints": [
      "Split into three steps",
      "Step 1: Find middle of list using slow/fast pointers",
      "Step 2: Reverse second half of list",
      "Step 3: Merge two halves alternately",
      "Handle odd/even length lists"
    ],
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "tags": ["linked-list", "two-pointers"],
    "links": {
      "leetcode": "https://leetcode.com/problems/reorder-list/",
      "gfg": "https://www.geeksforgeeks.org/rearrange-a-given-linked-list-in-place/"
    },
    "testCases": [
      {
        "input": {"head": [1,2,3,4]},
        "output": [1,4,2,3]
      },
      {
        "input": {"head": [1,2,3,4,5]},
        "output": [1,5,2,4,3]
      }
    ],
    "starterCode": {
      "javascript": "function reorderList(head) {\n  // Modify list in-place\n  // Write your code here\n  \n}",
      "python": "def reorder_list(head):\n    # Modify list in-place\n    # Write your code here\n    pass",
      "java": "public void reorderList(ListNode head) {\n    // Modify list in-place\n    // Write your code here\n}"
    }
  },
  {
    "id": "linked-lists-8",
    "title": "Copy List with Random Pointer",
    "category": "linked-lists",
    "difficulty": "medium",
    "companies": ["Amazon", "Facebook", "Microsoft", "Google", "Bloomberg"],
    "introduction": "Create a deep copy of a linked list where each node has a random pointer that could point to any node or null. The challenge is handling the random pointers since the target nodes might not exist yet during copying.",
    "problemStatement": "A linked list of length n is given such that each node contains an additional random pointer, which could point to any node in the list, or null.\n\nConstruct a deep copy of the list. The deep copy should consist of exactly n brand new nodes, where each new node has its value set to the value of its corresponding original node. Both the next and random pointer of the new nodes should point to new nodes in the copied list such that the pointers in the original list and copied list represent the same list state. None of the pointers in the new list should point to nodes in the original list.\n\nReturn the head of the copied linked list.\n\nConstraints:\n- 0 <= n <= 1000\n- -10⁴ <= Node.val <= 10⁴\n- Node.random is null or is pointing to some node in the linked list",
    "examples": [
      {
        "input": "head = [[7,null],[13,0],[11,4],[10,2],[1,0]]",
        "output": "[[7,null],[13,0],[11,4],[10,2],[1,0]]",
        "explanation": "Deep copy with same structure and random pointers pointing to corresponding new nodes."
      },
      {
        "input": "head = [[1,1],[2,1]]",
        "output": "[[1,1],[2,1]]",
        "explanation": "Node 1's random points to node 2, node 2's random points to node 2."
      }
    ],
    "hints": [
      "Method 1: Use HashMap to map original nodes to copies",
      "Two passes: first create all nodes, then set pointers",
      "Method 2: Interleave copied nodes with original",
      "Insert copy after each original: A → A' → B → B' → ...",
      "Set random pointers, then separate the two lists"
    ],
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(n) with HashMap, O(1) with interleaving",
    "tags": ["linked-list", "hash-table"],
    "links": {
      "leetcode": "https://leetcode.com/problems/copy-list-with-random-pointer/",
      "gfg": "https://www.geeksforgeeks.org/a-linked-list-with-next-and-arbit-pointer/"
    },
    "testCases": [
      {
        "input": {"head": [[7,null],[13,0],[11,4],[10,2],[1,0]]},
        "output": [[7,null],[13,0],[11,4],[10,2],[1,0]]
      },
      {
        "input": {"head": [[1,1],[2,1]]},
        "output": [[1,1],[2,1]]
      }
    ],
    "starterCode": {
      "javascript": "function copyRandomList(head) {\n  // Write your code here\n  // Node structure: { val, next, random }\n  \n}",
      "python": "def copy_random_list(head):\n    # Write your code here\n    # Node has val, next, random\n    pass",
      "java": "public Node copyRandomList(Node head) {\n    // Write your code here\n    return null;\n}"
    }
  },
  {
    "id": "linked-lists-9",
    "title": "Add Two Numbers",
    "category": "linked-lists",
    "difficulty": "medium",
    "companies": ["Amazon", "Facebook", "Microsoft", "Google", "Apple", "Bloomberg"],
    "introduction": "Given two non-empty linked lists representing two non-negative integers (digits stored in reverse order), add them and return the sum as a linked list. Handle carry between digits.",
    "problemStatement": "You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.\n\nYou may assume the two numbers do not contain any leading zero, except the number 0 itself.\n\nConstraints:\n- The number of nodes in each linked list is in the range [1, 100]\n- 0 <= Node.val <= 9\n- It is guaranteed that the list represents a number that does not have leading zeros",
    "examples": [
      {
        "input": "l1 = [2,4,3], l2 = [5,6,4]",
        "output": "[7,0,8]",
        "explanation": "342 + 465 = 807."
      },
      {
        "input": "l1 = [0], l2 = [0]",
        "output": "[0]",
        "explanation": "0 + 0 = 0."
      },
      {
        "input": "l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]",
        "output": "[8,9,9,9,0,0,0,1]",
        "explanation": "9999999 + 9999 = 10009998."
      }
    ],
    "hints": [
      "Use elementary math: add digit by digit",
      "Track carry between additions",
      "sum = l1.val + l2.val + carry",
      "new digit = sum % 10, new carry = sum / 10",
      "Handle different list lengths and final carry"
    ],
    "timeComplexity": "O(max(m, n))",
    "spaceComplexity": "O(max(m, n))",
    "tags": ["linked-list", "math"],
    "links": {
      "leetcode": "https://leetcode.com/problems/add-two-numbers/",
      "gfg": "https://www.geeksforgeeks.org/add-two-numbers-represented-by-linked-lists/"
    },
    "testCases": [
      {
        "input": {"l1": [2,4,3], "l2": [5,6,4]},
        "output": [7,0,8]
      },
      {
        "input": {"l1": [0], "l2": [0]},
        "output": [0]
      },
      {
        "input": {"l1": [9,9,9,9,9,9,9], "l2": [9,9,9,9]},
        "output": [8,9,9,9,0,0,0,1]
      }
    ],
    "starterCode": {
      "javascript": "function addTwoNumbers(l1, l2) {\n  // Write your code here\n  \n}",
      "python": "def add_two_numbers(l1, l2):\n    # Write your code here\n    pass",
      "java": "public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\n    // Write your code here\n    return null;\n}"
    }
  },
  {
    "id": "linked-lists-10",
    "title": "LRU Cache",
    "category": "linked-lists",
    "difficulty": "medium",
    "companies": ["Amazon", "Facebook", "Microsoft", "Google", "Apple", "Bloomberg", "Uber"],
    "introduction": "Design a data structure that follows the constraints of a Least Recently Used (LRU) cache. It should support get and put operations in O(1) time. Combine a HashMap with a doubly linked list.",
    "problemStatement": "Design a data structure that follows the constraints of a Least Recently Used (LRU) cache.\n\nImplement the LRUCache class:\n- LRUCache(int capacity) Initialize the LRU cache with positive size capacity.\n- int get(int key) Return the value of the key if the key exists, otherwise return -1.\n- void put(int key, int value) Update the value of the key if the key exists. Otherwise, add the key-value pair to the cache. If the number of keys exceeds the capacity from this operation, evict the least recently used key.\n\nThe functions get and put must each run in O(1) average time complexity.\n\nConstraints:\n- 1 <= capacity <= 3000\n- 0 <= key <= 10⁴\n- 0 <= value <= 10⁵\n- At most 2 × 10⁵ calls will be made to get and put",
    "examples": [
      {
        "input": "[\"LRUCache\",\"put\",\"put\",\"get\",\"put\",\"get\",\"put\",\"get\",\"get\",\"get\"]\n[[2],[1,1],[2,2],[1],[3,3],[2],[4,4],[1],[3],[4]]",
        "output": "[null,null,null,1,null,-1,null,-1,3,4]",
        "explanation": "Operations performed on LRU cache of capacity 2."
      }
    ],
    "hints": [
      "Use HashMap for O(1) key lookup",
      "Use doubly linked list to track access order",
      "Most recently used at head, least recently used at tail",
      "On access, move node to head",
      "On capacity overflow, remove tail node"
    ],
    "timeComplexity": "O(1) for both get and put",
    "spaceComplexity": "O(capacity)",
    "tags": ["linked-list", "hash-table", "design"],
    "links": {
      "leetcode": "https://leetcode.com/problems/lru-cache/",
      "gfg": "https://www.geeksforgeeks.org/lru-cache-implementation/"
    },
    "testCases": [
      {
        "input": {"operations": ["LRUCache","put","put","get","put","get","put","get","get","get"], "values": [[2],[1,1],[2,2],[1],[3,3],[2],[4,4],[1],[3],[4]]},
        "output": [null,null,null,1,null,-1,null,-1,3,4]
      }
    ],
    "starterCode": {
      "javascript": "class LRUCache {\n  constructor(capacity) {\n    // Initialize your data structure here\n  }\n  \n  get(key) {\n    // Write your code here\n  }\n  \n  put(key, value) {\n    // Write your code here\n  }\n}",
      "python": "class LRUCache:\n    def __init__(self, capacity):\n        # Initialize your data structure here\n        pass\n    \n    def get(self, key):\n        # Write your code here\n        pass\n    \n    def put(self, key, value):\n        # Write your code here\n        pass",
      "java": "class LRUCache {\n    public LRUCache(int capacity) {\n        // Initialize your data structure here\n    }\n    \n    public int get(int key) {\n        // Write your code here\n        return -1;\n    }\n    \n    public void put(int key, int value) {\n        // Write your code here\n    }\n}"
    }
  }
  ]
}
