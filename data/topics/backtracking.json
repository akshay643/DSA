{
  "category": {
    "id": "backtracking",
    "name": "Backtracking",
    "description": "Problems solved using backtracking technique - exploring all possibilities and backtracking when needed",
    "tricks": {
    "introduction": {
      "title": "What is Backtracking?",
      "definition": "Backtracking is an algorithmic technique for solving problems recursively by building a solution incrementally, one piece at a time, and removing solutions that fail to satisfy the constraints at any point (hence 'backtracking').",
      "analogy": "Imagine navigating a maze: you explore a path, and when you hit a dead end, you backtrack to the last junction and try a different route. You continue until you find the exit or exhaust all possibilities.",
      "keyIdea": "Try → Check → Accept or Reject → Backtrack if rejected → Try next option",
      "philosophy": "Backtracking is essentially DFS (Depth-First Search) on the solution space tree with pruning."
    },

    "coreConceptsS": {
      "solutionSpace": {
        "title": "Solution Space Tree",
        "explanation": "Every backtracking problem can be visualized as a tree where:",
        "points": [
          "Root represents the initial state (empty solution)",
          "Each node represents a partial solution",
          "Edges represent choices/decisions",
          "Leaves represent complete solutions or dead ends",
          "We explore this tree using DFS"
        ]
      },
      "threeKeyQuestions": {
        "title": "Three Questions to Ask",
        "questions": [
          "1. What are my CHOICES at each step?",
          "2. What are my CONSTRAINTS? (When to prune/reject)",
          "3. What is my GOAL? (When is solution complete)"
        ],
        "example": {
          "problem": "N-Queens",
          "choices": "Which column to place queen in current row",
          "constraints": "No two queens attack each other",
          "goal": "All N queens are placed successfully"
        }
      },
      "backtrackingVsBruteForce": {
        "title": "Backtracking vs Brute Force",
        "bruteForce": "Generate ALL possible solutions, then filter valid ones",
        "backtracking": "Build solution incrementally, PRUNE invalid branches early",
        "advantage": "Backtracking avoids exploring paths that cannot lead to valid solutions"
      }
    },

    "generalTemplate": {
      "title": "Universal Backtracking Template",
      "pseudocode": {
        "code": "function backtrack(currentState, choices, result):\n    // Base case: Goal reached\n    if isGoal(currentState):\n        result.add(copy(currentState))\n        return\n    \n    // Explore all choices\n    for choice in choices:\n        // Constraint check (pruning)\n        if isValid(choice, currentState):\n            // Make choice\n            currentState.add(choice)\n            \n            // Recurse\n            backtrack(currentState, remainingChoices, result)\n            \n            // Undo choice (BACKTRACK)\n            currentState.remove(choice)",
        "explanation": [
          "1. Base Case: Check if we've reached a valid complete solution",
          "2. Loop through all available choices",
          "3. Check if choice is valid (pruning)",
          "4. Make the choice (modify state)",
          "5. Recurse with new state",
          "6. UNDO the choice (this is the backtracking step)"
        ]
      },
      "javascript": "function backtrack(path, choices, result) {\n    if (isComplete(path)) {\n        result.push([...path]); // Clone!\n        return;\n    }\n    \n    for (let i = 0; i < choices.length; i++) {\n        if (!isValid(choices[i], path)) continue; // Prune\n        \n        path.push(choices[i]);           // Choose\n        backtrack(path, choices, result); // Explore\n        path.pop();                       // Un-choose\n    }\n}",
      "python": "def backtrack(path, choices, result):\n    if is_complete(path):\n        result.append(path[:])  # Clone!\n        return\n    \n    for choice in choices:\n        if not is_valid(choice, path):  # Prune\n            continue\n        \n        path.append(choice)              # Choose\n        backtrack(path, choices, result) # Explore\n        path.pop()                       # Un-choose"
    },

    "patternCategories": {
      "title": "Major Backtracking Pattern Categories",
      
      "subsets": {
        "name": "Subsets Pattern",
        "description": "Generate all subsets/combinations",
        "problems": ["Subsets", "Subsets II", "Combination Sum"],
        "template": "function subsets(nums):\n    result = []\n    backtrack(0, [], result)\n    return result\n\nfunction backtrack(start, path, result):\n    result.add(copy(path))  // Every path is valid subset\n    \n    for i from start to nums.length:\n        path.add(nums[i])\n        backtrack(i + 1, path, result)  // i+1 to avoid duplicates\n        path.remove(last)",
        "keyInsight": "Start index prevents going backward, ensuring unique subsets"
      },
      
      "permutations": {
        "name": "Permutations Pattern",
        "description": "Generate all arrangements where ORDER matters",
        "problems": ["Permutations", "Permutations II", "Letter Case Permutation"],
        "template": "function permutations(nums):\n    result = []\n    used = [false] * nums.length\n    backtrack([], used, result)\n    return result\n\nfunction backtrack(path, used, result):\n    if path.length == nums.length:\n        result.add(copy(path))\n        return\n    \n    for i from 0 to nums.length:\n        if used[i]: continue\n        \n        used[i] = true\n        path.add(nums[i])\n        backtrack(path, used, result)\n        path.remove(last)\n        used[i] = false",
        "keyInsight": "Used array tracks which elements are already in current permutation"
      },
      
      "combinations": {
        "name": "Combinations Pattern",
        "description": "Choose k elements from n (order doesn't matter)",
        "problems": ["Combinations", "Combination Sum", "Combination Sum II"],
        "template": "function combinations(n, k):\n    result = []\n    backtrack(1, [], result)\n    return result\n\nfunction backtrack(start, path, result):\n    if path.length == k:\n        result.add(copy(path))\n        return\n    \n    for i from start to n:\n        path.add(i)\n        backtrack(i + 1, path, result)\n        path.remove(last)",
        "keyInsight": "Start index + target length defines valid combinations"
      },
      
      "partitioning": {
        "name": "Partitioning Pattern",
        "description": "Divide input into valid parts",
        "problems": ["Palindrome Partitioning", "Restore IP Addresses", "Word Break II"],
        "template": "function partition(s):\n    result = []\n    backtrack(0, [], result)\n    return result\n\nfunction backtrack(start, path, result):\n    if start == s.length:\n        result.add(copy(path))\n        return\n    \n    for end from start+1 to s.length:\n        substring = s[start:end]\n        if isValid(substring):\n            path.add(substring)\n            backtrack(end, path, result)\n            path.remove(last)",
        "keyInsight": "Try all valid partition points, recurse on remaining"
      },
      
      "gridSearch": {
        "name": "Grid/Board Pattern",
        "description": "Search paths or patterns in 2D grid",
        "problems": ["Word Search", "N-Queens", "Sudoku Solver", "Rat in Maze"],
        "template": "function searchGrid(board, word):\n    for each cell (i, j):\n        if backtrack(i, j, 0):\n            return true\n    return false\n\nfunction backtrack(row, col, index):\n    if index == word.length:\n        return true  // Found!\n    \n    if outOfBounds or board[row][col] != word[index]:\n        return false  // Invalid\n    \n    temp = board[row][col]\n    board[row][col] = '#'  // Mark visited\n    \n    // Explore 4 directions\n    found = backtrack(row+1, col, index+1) or\n            backtrack(row-1, col, index+1) or\n            backtrack(row, col+1, index+1) or\n            backtrack(row, col-1, index+1)\n    \n    board[row][col] = temp  // Restore (backtrack)\n    return found",
        "keyInsight": "Mark cells visited, explore directions, restore on backtrack"
      },

      "constraintSatisfaction": {
        "name": "Constraint Satisfaction Pattern",
        "description": "Find assignment satisfying all constraints",
        "problems": ["N-Queens", "Sudoku Solver", "Graph Coloring"],
        "approach": [
          "1. Try placing value in next empty position",
          "2. Check if all constraints are satisfied",
          "3. If valid, recurse to next position",
          "4. If stuck, backtrack and try different value"
        ]
      }
    },

    "pruningTechniques": {
      "title": "Pruning - The Key to Efficient Backtracking",
      "importance": "Pruning eliminates branches of the search tree that cannot lead to valid solutions, dramatically reducing time complexity.",
      
      "techniques": {
        "constraintChecking": {
          "name": "Early Constraint Checking",
          "description": "Check constraints BEFORE making a choice, not after",
          "example": "In N-Queens, check if position is safe BEFORE placing queen",
          "bad": "Place queen → Check all queens → Remove if invalid",
          "good": "Check position → Only place if safe"
        },
        
        "sortingFirst": {
          "name": "Sort Input First",
          "description": "Sorting enables efficient duplicate handling and early termination",
          "example": "In Combination Sum II, sort to group duplicates together",
          "benefit": "Skip consecutive duplicates: if (i > start && nums[i] == nums[i-1]) continue"
        },
        
        "remainingCheck": {
          "name": "Check Remaining Elements",
          "description": "Prune if remaining elements can't possibly complete solution",
          "example": "In Combinations(n, k): if (n - start + 1 < k - path.length) return",
          "benefit": "Don't explore paths that can't reach target length"
        },
        
        "sumPruning": {
          "name": "Sum-Based Pruning",
          "description": "For sum problems, stop when sum exceeds or can't reach target",
          "example": "In Combination Sum, if currentSum > target, stop exploring",
          "code": "if (currentSum + nums[i] > target) break; // If sorted"
        },
        
        "symmetryBreaking": {
          "name": "Symmetry Breaking",
          "description": "Avoid exploring symmetric/equivalent solutions",
          "example": "In N-Queens, only explore half the first row (mirror solutions)",
          "benefit": "Can reduce search space by half or more"
        },
        
        "boundaryPruning": {
          "name": "Boundary Pruning",
          "description": "Check bounds before recursive call",
          "example": "In grid problems, check row/col bounds before exploring",
          "code": "if (row < 0 || row >= n || col < 0 || col >= m) return"
        }
      }
    },

    "handlingDuplicates": {
      "title": "Handling Duplicates in Backtracking",
      "importance": "Many problems have duplicate elements that can cause duplicate solutions",
      
      "strategies": {
        "sortAndSkip": {
          "name": "Sort + Skip Consecutive Duplicates",
          "when": "Input array has duplicates, need unique subsets/combinations",
          "code": "// Sort array first\nnums.sort()\n\n// In backtracking loop:\nfor i from start to n:\n    // Skip duplicates at same level\n    if i > start and nums[i] == nums[i-1]:\n        continue\n    // ... rest of backtracking",
          "explanation": "Skip duplicates only at same decision level (i > start), not across levels"
        },
        
        "usedArray": {
          "name": "Used Array for Permutations",
          "when": "Generating permutations with duplicates",
          "code": "// Sort array first\n// Skip if same as previous AND previous not used\nif i > 0 and nums[i] == nums[i-1] and not used[i-1]:\n    continue",
          "explanation": "This ensures duplicates are used in order, avoiding duplicate permutations"
        },
        
        "setDeduplication": {
          "name": "Use Set for Results",
          "when": "Quick solution, may have duplicates",
          "approach": "Convert each solution to string/tuple, store in set",
          "note": "Less efficient than proper skipping, but simpler"
        }
      }
    },

    "stateManagement": {
      "title": "State Management in Backtracking",
      
      "whatIsState": {
        "definition": "State = All information needed to make decisions and check validity",
        "examples": [
          "Path built so far (array/list)",
          "Current position (index, row/col)",
          "Remaining choices",
          "Used elements (boolean array or set)",
          "Running totals (sum, count, etc.)"
        ]
      },
      
      "passingVsGlobal": {
        "title": "Passing State vs Global State",
        "passing": {
          "description": "Pass state as parameters",
          "pros": ["Cleaner", "Thread-safe", "Easier to reason about"],
          "cons": ["More memory in call stack"]
        },
        "global": {
          "description": "Use class/global variables",
          "pros": ["Less parameter passing", "Sometimes cleaner for complex state"],
          "cons": ["Must remember to undo changes", "Not thread-safe"]
        }
      },
      
      "cloning": {
        "title": "When to Clone State",
        "rule": "ALWAYS clone when adding to results!",
        "why": "The path array is modified during backtracking. If you don't clone, all results will reference the same (empty) array.",
        "correct": "result.push([...path])  // JavaScript\nresult.append(path[:])   # Python\nresult.add(new ArrayList<>(path))  // Java",
        "wrong": "result.push(path)  // WRONG! Reference to same array"
      },
      
      "undoingChanges": {
        "title": "Undoing Changes (The Backtrack Step)",
        "importance": "CRITICAL! Must undo all changes made before recursive call",
        "commonPatterns": [
          "path.pop() - Remove added element",
          "used[i] = false - Mark as unused",
          "board[r][c] = original - Restore grid cell",
          "sum -= nums[i] - Subtract added value",
          "swap back - Restore original positions"
        ],
        "tip": "Match every 'do' with an 'undo' after recursion"
      }
    },

    "complexityAnalysis": {
      "title": "Time & Space Complexity of Backtracking",
      
      "timeComplexity": {
        "general": "O(k × N!) or O(k × 2^N) where k is work per node",
        "commonCases": {
          "subsets": {
            "formula": "O(N × 2^N)",
            "explanation": "2^N subsets, each takes O(N) to copy"
          },
          "permutations": {
            "formula": "O(N × N!)",
            "explanation": "N! permutations, each takes O(N) to copy"
          },
          "combinations": {
            "formula": "O(k × C(N,k))",
            "explanation": "C(N,k) combinations of size k"
          },
          "nQueens": {
            "formula": "O(N!)",
            "explanation": "At most N choices for each row, pruning helps"
          },
          "sudoku": {
            "formula": "O(9^(empty cells))",
            "explanation": "9 choices for each empty cell, heavily pruned"
          }
        }
      },
      
      "spaceComplexity": {
        "recursionStack": "O(N) or O(max depth) for call stack",
        "stateStorage": "Depends on state: path array, used array, etc.",
        "results": "O(number of solutions × solution size)",
        "tip": "Don't forget recursion stack in space analysis!"
      }
    },

    "commonMistakes": {
      "title": "Common Mistakes to Avoid",
      
      "mistakes": {
        "forgettingToBacktrack": {
          "problem": "Not undoing changes after recursive call",
          "symptom": "Wrong or incomplete results",
          "fix": "Always pair 'do' with 'undo'"
        },
        
        "notCloningResults": {
          "problem": "Adding reference instead of copy to results",
          "symptom": "All results are empty or same",
          "fix": "Clone path when adding: result.push([...path])"
        },
        
        "wrongLoopBounds": {
          "problem": "Starting from 0 instead of 'start' index",
          "symptom": "Duplicate combinations like [1,2] and [2,1]",
          "fix": "Use 'start' parameter for subsets/combinations"
        },
        
        "duplicateHandling": {
          "problem": "Not handling duplicates in input",
          "symptom": "Duplicate solutions",
          "fix": "Sort + skip: if (i > start && nums[i] == nums[i-1]) continue"
        },
        
        "inefficientPruning": {
          "problem": "Checking constraints too late",
          "symptom": "TLE (Time Limit Exceeded)",
          "fix": "Check constraints before making choice, not after"
        },
        
        "modifyingInput": {
          "problem": "Not restoring modified input (like grid)",
          "symptom": "Missing solutions, wrong results",
          "fix": "Save original value, restore after backtrack"
        },
        
        "wrongBaseCase": {
          "problem": "Incorrect termination condition",
          "symptom": "Infinite loop or missing solutions",
          "fix": "Carefully define when solution is complete"
        }
      }
    },

    "optimizationTips": {
      "title": "Tips for Optimizing Backtracking",
      
      "tips": [
        {
          "tip": "Sort input first",
          "benefit": "Enables duplicate skipping and early termination"
        },
        {
          "tip": "Check constraints before recursion",
          "benefit": "Avoid unnecessary function calls"
        },
        {
          "tip": "Use efficient data structures",
          "benefit": "HashSet for O(1) lookups instead of O(n) array search"
        },
        {
          "tip": "Pass indices instead of creating new arrays",
          "benefit": "Reduces memory allocation overhead"
        },
        {
          "tip": "Use swap for in-place permutations",
          "benefit": "Avoids extra 'used' array"
        },
        {
          "tip": "Precompute validity checks",
          "benefit": "In N-Queens, use arrays for column/diagonal tracking"
        },
        {
          "tip": "Consider iterative approach for simple cases",
          "benefit": "Avoids recursion overhead for subsets"
        },
        {
          "tip": "Memoization for overlapping subproblems",
          "benefit": "When same state can be reached multiple ways"
        }
      ]
    },

    "backtrackingVsDFS": {
      "title": "Backtracking vs DFS vs Recursion",
      
      "comparison": {
        "recursion": {
          "definition": "Function calling itself",
          "scope": "General technique for breaking problem into subproblems"
        },
        "dfs": {
          "definition": "Depth-First Search on graphs/trees",
          "scope": "Graph traversal strategy - go deep before wide"
        },
        "backtracking": {
          "definition": "DFS on solution space with pruning and undo",
          "scope": "Building solutions incrementally with constraint checking"
        }
      },
      
      "relationship": "Backtracking = DFS + Pruning + State Undo",
      
      "whenToUse": {
        "dfs": "Traversing existing graph/tree structure",
        "backtracking": "Exploring solution space, generating combinations/permutations"
      }
    },

    "problemIdentification": {
      "title": "How to Identify Backtracking Problems",
      
      "signals": [
        "\"Find ALL possible solutions\"",
        "\"Generate ALL combinations/permutations\"",
        "\"Count the number of ways\"",
        "\"Print all paths\"",
        "\"Partition into valid groups\"",
        "\"Check if valid arrangement exists\"",
        "Constraint satisfaction problems"
      ],
      
      "typicalProblems": {
        "generate": ["Subsets", "Permutations", "Combinations", "Parentheses"],
        "search": ["Word Search", "Sudoku", "N-Queens"],
        "partition": ["Palindrome Partitioning", "Restore IP Addresses"],
        "path": ["All Paths in Graph", "Rat in Maze", "Knight's Tour"]
      },
      
      "notBacktracking": [
        "Finding single optimal solution (might be DP)",
        "Finding shortest path (might be BFS)",
        "When greedy works (no need to explore all)"
      ]
    },

    "stepByStepApproach": {
      "title": "Step-by-Step Problem Solving Approach",
      
      "steps": [
        {
          "step": 1,
          "action": "Understand the Problem",
          "questions": [
            "What constitutes a valid solution?",
            "How many solutions exist?",
            "What are the constraints?"
          ]
        },
        {
          "step": 2,
          "action": "Identify the Choices",
          "questions": [
            "What decisions do I make at each step?",
            "What are my options at each decision point?"
          ]
        },
        {
          "step": 3,
          "action": "Define the Constraints",
          "questions": [
            "When is a partial solution invalid?",
            "When can I prune the search?"
          ]
        },
        {
          "step": 4,
          "action": "Define the Goal",
          "questions": [
            "When is the solution complete?",
            "What should I add to results?"
          ]
        },
        {
          "step": 5,
          "action": "Write the Template",
          "actions": [
            "Define backtrack function signature",
            "Write base case",
            "Write loop over choices",
            "Add constraint checking",
            "Add recursive call",
            "Add undo step"
          ]
        },
        {
          "step": 6,
          "action": "Handle Edge Cases",
          "cases": [
            "Empty input",
            "Single element",
            "Duplicates in input",
            "No valid solution"
          ]
        },
        {
          "step": 7,
          "action": "Optimize",
          "techniques": [
            "Add pruning",
            "Sort if helpful",
            "Use efficient data structures"
          ]
        }
      ]
    },

    "visualizationTips": {
      "title": "Visualizing Backtracking",
      
      "drawTree": {
        "description": "Draw the decision tree for small inputs",
        "example": "For subsets of [1,2,3]:\n        []\n       / \\\n    [1]   []\n    / \\   / \\\n [1,2] [1] [2] []\n  ...",
        "benefit": "Helps understand the structure and identify pruning opportunities"
      },
      
      "traceExecution": {
        "description": "Trace through with print statements",
        "code": "function backtrack(path):\n    print('Exploring:', path)\n    // ... backtracking logic\n    print('Backtracking from:', path)",
        "benefit": "See exactly how algorithm explores and backtracks"
      }
    },

    "cheatSheet": {
      "title": "Backtracking Cheat Sheet",
      
      "templates": {
        "subsets": "for i in range(start, n):\n    path.append(nums[i])\n    backtrack(i + 1)  # i+1, not i\n    path.pop()",
        
        "permutations": "for i in range(n):\n    if used[i]: continue\n    used[i] = True\n    path.append(nums[i])\n    backtrack()\n    path.pop()\n    used[i] = False",
        
        "combinations": "for i in range(start, n + 1):\n    path.append(i)\n    backtrack(i + 1)\n    path.pop()",
        
        "skipDuplicates": "if i > start and nums[i] == nums[i-1]:\n    continue",
        
        "gridSearch": "temp = board[r][c]\nboard[r][c] = '#'\nbacktrack(neighbors)\nboard[r][c] = temp"
      },
      
      "reminders": [
        "✓ Clone path when adding to results",
        "✓ Undo EVERY change after recursion",
        "✓ Sort first if handling duplicates",
        "✓ Use start index for combinations, used array for permutations",
        "✓ Check constraints BEFORE making choice",
        "✓ Base case BEFORE the loop"
      ],
      
      "complexities": {
        "subsets": "Time: O(N × 2^N), Space: O(N)",
        "permutations": "Time: O(N × N!), Space: O(N)",
        "combinations": "Time: O(k × C(N,k)), Space: O(k)",
        "nQueens": "Time: O(N!), Space: O(N)"
      }
    },

    "practiceProgression": {
      "title": "Recommended Practice Order",
      
      "levels": {
        "beginner": [
          "Subsets (basic template)",
          "Permutations (used array)",
          "Combinations (start index)",
          "Letter Combinations of Phone Number"
        ],
        "intermediate": [
          "Subsets II (duplicates)",
          "Permutations II (duplicates)",
          "Combination Sum (unlimited use)",
          "Combination Sum II (limited use)",
          "Palindrome Partitioning"
        ],
        "advanced": [
          "N-Queens",
          "Sudoku Solver",
          "Word Search",
          "Word Search II (with Trie)",
          "Restore IP Addresses",
          "Generate Parentheses"
        ],
        "expert": [
          "Regular Expression Matching",
          "Wildcard Matching",
          "Word Break II",
          "24 Game",
          "Optimal Account Balancing"
        ]
      }
    }
  }
  },
  "questions": [
     {
    "id": "backtracking-1",
    "title": "Subsets",
    "category": "backtracking",
    "difficulty": "medium",
    "companies": ["Amazon", "Facebook", "Google", "Microsoft", "Bloomberg"],
    "introduction": "Given an array of unique integers, return all possible subsets (the power set). This is a classic backtracking problem that demonstrates the include/exclude pattern.",
    "problemStatement": "Given an integer array nums of unique elements, return all possible subsets (the power set).\n\nThe solution set must not contain duplicate subsets. Return the solution in any order.\n\nConstraints:\n- 1 <= nums.length <= 10\n- -10 <= nums[i] <= 10\n- All the numbers of nums are unique",
    "examples": [
      {
        "input": "nums = [1,2,3]",
        "output": "[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]",
        "explanation": "All 2^3 = 8 subsets."
      },
      {
        "input": "nums = [0]",
        "output": "[[],[0]]",
        "explanation": "Two subsets: empty and [0]."
      }
    ],
    "hints": [
      "For each element, we have two choices: include or exclude",
      "Use backtracking to explore both choices",
      "Alternative: iterative approach starting with [[]]",
      "For each num, add it to all existing subsets",
      "Total subsets = 2^n"
    ],
    "timeComplexity": "O(n × 2ⁿ)",
    "spaceComplexity": "O(n) for recursion depth",
    "tags": ["backtracking", "array", "bit-manipulation"],
    "links": {
      "leetcode": "https://leetcode.com/problems/subsets/",
      "gfg": "https://www.geeksforgeeks.org/power-set/"
    },
    "testCases": [
      {
        "input": {"nums": [1, 2, 3]},
        "output": [[], [1], [2], [1,2], [3], [1,3], [2,3], [1,2,3]]
      },
      {
        "input": {"nums": [0]},
        "output": [[], [0]]
      }
    ],
    "starterCode": {
      "javascript": "function subsets(nums) {\n  // Write your code here\n  \n}\n\n// Test cases\nconsole.log('Test 1:', subsets([1, 2, 3]));",
      "python": "def subsets(nums):\n    # Write your code here\n    pass\n\n# Test cases\nprint('Test 1:', subsets([1, 2, 3]))",
      "java": "public List<List<Integer>> subsets(int[] nums) {\n    // Write your code here\n    return new ArrayList<>();\n}"
    }
  },
  {
    "id": "backtracking-2",
    "title": "Permutations",
    "category": "backtracking",
    "difficulty": "medium",
    "companies": ["Amazon", "Facebook", "Google", "Microsoft", "LinkedIn"],
    "introduction": "Given an array of distinct integers, return all possible permutations. Unlike subsets, permutations use all elements and order matters.",
    "problemStatement": "Given an array nums of distinct integers, return all the possible permutations. You can return the answer in any order.\n\nConstraints:\n- 1 <= nums.length <= 6\n- -10 <= nums[i] <= 10\n- All the integers of nums are unique",
    "examples": [
      {
        "input": "nums = [1,2,3]",
        "output": "[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]",
        "explanation": "All 3! = 6 permutations."
      },
      {
        "input": "nums = [0,1]",
        "output": "[[0,1],[1,0]]",
        "explanation": "All 2! = 2 permutations."
      },
      {
        "input": "nums = [1]",
        "output": "[[1]]",
        "explanation": "Only one permutation."
      }
    ],
    "hints": [
      "Use backtracking to try each element at each position",
      "Track which elements are used with a visited array",
      "Or swap elements to generate permutations in-place",
      "Base case: when current permutation has n elements",
      "Total permutations = n!"
    ],
    "timeComplexity": "O(n × n!)",
    "spaceComplexity": "O(n) for recursion and tracking",
    "tags": ["backtracking", "array"],
    "links": {
      "leetcode": "https://leetcode.com/problems/permutations/",
      "gfg": "https://www.geeksforgeeks.org/write-a-c-program-to-print-all-permutations-of-a-given-string/"
    },
    "testCases": [
      {
        "input": {"nums": [1, 2, 3]},
        "output": [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
      },
      {
        "input": {"nums": [0, 1]},
        "output": [[0,1],[1,0]]
      }
    ],
    "starterCode": {
      "javascript": "function permute(nums) {\n  // Write your code here\n  \n}\n\n// Test cases\nconsole.log('Test 1:', permute([1, 2, 3]));",
      "python": "def permute(nums):\n    # Write your code here\n    pass\n\n# Test cases\nprint('Test 1:', permute([1, 2, 3]))",
      "java": "public List<List<Integer>> permute(int[] nums) {\n    // Write your code here\n    return new ArrayList<>();\n}"
    }
  },
  {
    "id": "backtracking-3",
    "title": "Combination Sum",
    "category": "backtracking",
    "difficulty": "medium",
    "companies": ["Amazon", "Facebook", "Google", "Microsoft", "Airbnb"],
    "introduction": "Given an array of distinct integers and a target, return all unique combinations that sum to the target. Elements can be used unlimited times. This is a variant of the subset problem with a sum constraint.",
    "problemStatement": "Given an array of distinct integers candidates and a target integer target, return a list of all unique combinations of candidates where the chosen numbers sum to target. You may return the combinations in any order.\n\nThe same number may be chosen from candidates an unlimited number of times. Two combinations are unique if the frequency of at least one of the chosen numbers is different.\n\nConstraints:\n- 1 <= candidates.length <= 30\n- 2 <= candidates[i] <= 40\n- All elements of candidates are distinct\n- 1 <= target <= 40",
    "examples": [
      {
        "input": "candidates = [2,3,6,7], target = 7",
        "output": "[[2,2,3],[7]]",
        "explanation": "2 + 2 + 3 = 7 and 7 = 7."
      },
      {
        "input": "candidates = [2,3,5], target = 8",
        "output": "[[2,2,2,2],[2,3,3],[3,5]]",
        "explanation": "Multiple ways to reach 8."
      },
      {
        "input": "candidates = [2], target = 1",
        "output": "[]",
        "explanation": "No combination sums to 1."
      }
    ],
    "hints": [
      "Use backtracking with remaining target",
      "Allow same element to be used again (don't increment start index)",
      "Prune when target becomes negative",
      "Sort to enable early termination",
      "Start from current index to avoid duplicate combinations"
    ],
    "timeComplexity": "O(n^(target/min))",
    "spaceComplexity": "O(target/min) for recursion depth",
    "tags": ["backtracking", "array"],
    "links": {
      "leetcode": "https://leetcode.com/problems/combination-sum/",
      "gfg": "https://www.geeksforgeeks.org/combinational-sum/"
    },
    "testCases": [
      {
        "input": {"candidates": [2,3,6,7], "target": 7},
        "output": [[2,2,3],[7]]
      },
      {
        "input": {"candidates": [2,3,5], "target": 8},
        "output": [[2,2,2,2],[2,3,3],[3,5]]
      }
    ],
    "starterCode": {
      "javascript": "function combinationSum(candidates, target) {\n  // Write your code here\n  \n}\n\n// Test cases\nconsole.log('Test 1:', combinationSum([2,3,6,7], 7)); // [[2,2,3],[7]]",
      "python": "def combination_sum(candidates, target):\n    # Write your code here\n    pass\n\n# Test cases\nprint('Test 1:', combination_sum([2,3,6,7], 7)) # [[2,2,3],[7]]",
      "java": "public List<List<Integer>> combinationSum(int[] candidates, int target) {\n    // Write your code here\n    return new ArrayList<>();\n}"
    }
  },
  {
    "id": "backtracking-4",
    "title": "Letter Combinations of a Phone Number",
    "category": "backtracking",
    "difficulty": "medium",
    "companies": ["Amazon", "Facebook", "Google", "Microsoft", "Uber"],
    "introduction": "Given a string containing digits from 2-9, return all possible letter combinations that the number could represent. This is like old phone keypads where each digit maps to multiple letters.",
    "problemStatement": "Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. Return the answer in any order.\n\nA mapping of digits to letters (just like on the telephone buttons) is given below:\n2 → abc, 3 → def, 4 → ghi, 5 → jkl, 6 → mno, 7 → pqrs, 8 → tuv, 9 → wxyz\n\nNote that 1 does not map to any letters.\n\nConstraints:\n- 0 <= digits.length <= 4\n- digits[i] is a digit in the range ['2', '9']",
    "examples": [
      {
        "input": "digits = \"23\"",
        "output": "[\"ad\",\"ae\",\"af\",\"bd\",\"be\",\"bf\",\"cd\",\"ce\",\"cf\"]",
        "explanation": "2 → abc, 3 → def. All combinations of one letter from each."
      },
      {
        "input": "digits = \"\"",
        "output": "[]",
        "explanation": "Empty input gives empty output."
      },
      {
        "input": "digits = \"2\"",
        "output": "[\"a\",\"b\",\"c\"]",
        "explanation": "Just the letters for digit 2."
      }
    ],
    "hints": [
      "Create a mapping of digit to letters",
      "Use backtracking to try each letter for each digit",
      "Build combination character by character",
      "When combination length equals input length, add to result",
      "Can also use BFS/iterative approach"
    ],
    "timeComplexity": "O(4ⁿ × n) where n is length of digits",
    "spaceComplexity": "O(n) for recursion depth",
    "tags": ["backtracking", "string", "hash-table"],
    "links": {
      "leetcode": "https://leetcode.com/problems/letter-combinations-of-a-phone-number/",
      "gfg": "https://www.geeksforgeeks.org/iterative-letter-combinations-of-a-phone-number/"
    },
    "testCases": [
      {
        "input": {"digits": "23"},
        "output": ["ad","ae","af","bd","be","bf","cd","ce","cf"]
      },
      {
        "input": {"digits": ""},
        "output": []
      },
      {
        "input": {"digits": "2"},
        "output": ["a","b","c"]
      }
    ],
    "starterCode": {
      "javascript": "function letterCombinations(digits) {\n  // Write your code here\n  \n}\n\n// Test cases\nconsole.log('Test 1:', letterCombinations('23'));",
      "python": "def letter_combinations(digits):\n    # Write your code here\n    pass\n\n# Test cases\nprint('Test 1:', letter_combinations('23'))",
      "java": "public List<String> letterCombinations(String digits) {\n    // Write your code here\n    return new ArrayList<>();\n}"
    }
  },
  {
    "id": "backtracking-5",
    "title": "N-Queens",
    "category": "backtracking",
    "difficulty": "hard",
    "companies": ["Amazon", "Facebook", "Google", "Microsoft", "Bloomberg"],
    "introduction": "Place n queens on an n×n chessboard such that no two queens attack each other. Queens can attack horizontally, vertically, and diagonally. This is the classic backtracking problem.",
    "problemStatement": "The n-queens puzzle is the problem of placing n queens on an n x n chessboard such that no two queens attack each other.\n\nGiven an integer n, return all distinct solutions to the n-queens puzzle. You may return the answer in any order.\n\nEach solution contains a distinct board configuration of the n-queens' placement, where 'Q' and '.' both indicate a queen and an empty space, respectively.\n\nConstraints:\n- 1 <= n <= 9",
    "examples": [
      {
        "input": "n = 4",
        "output": "[[\".Q..\",\"...Q\",\"Q...\",\"..Q.\"],[\"..Q.\",\"Q...\",\"...Q\",\".Q..\"]]",
        "explanation": "There are two distinct solutions to the 4-queens puzzle."
      },
      {
        "input": "n = 1",
        "output": "[[\"Q\"]]",
        "explanation": "Only one way to place one queen."
      }
    ],
    "hints": [
      "Place queens row by row",
      "Track columns, diagonals, and anti-diagonals",
      "For position (r, c): diagonal = r - c, anti-diagonal = r + c",
      "Use sets or arrays to track attacked positions",
      "Backtrack when no valid position in current row"
    ],
    "timeComplexity": "O(n!)",
    "spaceComplexity": "O(n²) for the board",
    "tags": ["backtracking", "array"],
    "links": {
      "leetcode": "https://leetcode.com/problems/n-queens/",
      "gfg": "https://www.geeksforgeeks.org/n-queen-problem-backtracking-3/"
    },
    "testCases": [
      {
        "input": {"n": 4},
        "output": [[".Q..","...Q","Q...","..Q."],["..Q.","Q...","...Q",".Q.."]]
      },
      {
        "input": {"n": 1},
        "output": [["Q"]]
      }
    ],
    "starterCode": {
      "javascript": "function solveNQueens(n) {\n  // Write your code here\n  \n}\n\n// Test cases\nconsole.log('Test 1:', solveNQueens(4));",
      "python": "def solve_n_queens(n):\n    # Write your code here\n    pass\n\n# Test cases\nprint('Test 1:', solve_n_queens(4))",
      "java": "public List<List<String>> solveNQueens(int n) {\n    // Write your code here\n    return new ArrayList<>();\n}"
    }
  },
  {
    "id": "backtracking-6",
    "title": "Word Search",
    "category": "backtracking",
    "difficulty": "medium",
    "companies": ["Amazon", "Facebook", "Google", "Microsoft", "Bloomberg", "Apple"],
    "introduction": "Given a 2D grid of characters and a word, find if the word exists in the grid. The word can be constructed from adjacent cells (horizontally or vertically). Each cell can only be used once.",
    "problemStatement": "Given an m x n grid of characters board and a string word, return true if word exists in the grid.\n\nThe word can be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once.\n\nConstraints:\n- m == board.length\n- n = board[i].length\n- 1 <= m, n <= 6\n- 1 <= word.length <= 15\n- board and word consists of only lowercase and uppercase English letters",
    "examples": [
      {
        "input": "board = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], word = \"ABCCED\"",
        "output": "true",
        "explanation": "The word ABCCED can be found in the grid."
      },
      {
        "input": "board = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], word = \"SEE\"",
        "output": "true",
        "explanation": "The word SEE can be found."
      },
      {
        "input": "board = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], word = \"ABCB\"",
        "output": "false",
        "explanation": "Cannot revisit the same cell."
      }
    ],
    "hints": [
      "Start DFS from each cell that matches first character",
      "Mark cell as visited during DFS (e.g., change to '#')",
      "Restore cell after backtracking",
      "Check bounds and character match at each step",
      "Prune early if remaining word can't be found"
    ],
    "timeComplexity": "O(m × n × 4^L) where L is word length",
    "spaceComplexity": "O(L) for recursion depth",
    "tags": ["backtracking", "matrix", "dfs"],
    "links": {
      "leetcode": "https://leetcode.com/problems/word-search/",
      "gfg": "https://www.geeksforgeeks.org/search-a-word-in-a-2d-grid-of-characters/"
    },
    "testCases": [
      {
        "input": {"board": [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], "word": "ABCCED"},
        "output": true
      },
      {
        "input": {"board": [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], "word": "SEE"},
        "output": true
      },
      {
        "input": {"board": [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], "word": "ABCB"},
        "output": false
      }
    ],
    "starterCode": {
      "javascript": "function exist(board, word) {\n  // Write your code here\n  \n}\n\n// Test cases\nconsole.log('Test 1:', exist([['A','B','C','E'],['S','F','C','S'],['A','D','E','E']], 'ABCCED')); // true",
      "python": "def exist(board, word):\n    # Write your code here\n    pass\n\n# Test cases\nprint('Test 1:', exist([['A','B','C','E'],['S','F','C','S'],['A','D','E','E']], 'ABCCED')) # True",
      "java": "public boolean exist(char[][] board, String word) {\n    // Write your code here\n    return false;\n}"
    }
  }
  ]
}
