{
  "id": "javascript-fullstack",
  "title": "Full Stack JavaScript & Angular Developer",
  "description": "Complete technical skills Q&A reference guide covering JavaScript fundamentals, TypeScript, Angular, Node.js, Web Security, Testing, CI/CD, Databases, and Performance Optimization",
  "difficulty": "beginner-to-advanced",
  "estimatedTime": "20-25 hours",
  "sections": [
    {
      "id": "section-1",
      "title": "JavaScript - Arrays",
      "blocks": [
        {
          "type": "title",
          "level": 2,
          "content": "Q1. What is the difference between slice() and splice() methods?"
        },
        {
          "type": "description",
          "content": "slice() returns a shallow copy of a portion of an array without modifying the original array. It takes start and end parameters. splice() modifies the original array by removing, replacing, or adding elements. It takes start, deleteCount, and items to add as parameters."
        },
        {
          "type": "code",
          "language": "javascript",
          "title": "slice() vs splice() Examples",
          "code": "// slice() - Non-mutating\nconst arr1 = [1, 2, 3, 4, 5];\nconst sliced = arr1.slice(1, 4); // [2, 3, 4]\nconsole.log(arr1); // [1, 2, 3, 4, 5] - original unchanged\n\n// splice() - Mutating\nconst arr2 = [1, 2, 3, 4, 5];\nconst removed = arr2.splice(1, 2); // removes 2 elements starting at index 1\nconsole.log(removed); // [2, 3]\nconsole.log(arr2); // [1, 4, 5] - original modified\n\n// splice() - Adding elements\nconst arr3 = [1, 2, 5];\narr3.splice(2, 0, 3, 4); // insert 3, 4 at index 2\nconsole.log(arr3); // [1, 2, 3, 4, 5]\n\n// splice() - Replacing elements\nconst arr4 = [1, 2, 3, 4, 5];\narr4.splice(2, 1, 99); // replace 1 element at index 2\nconsole.log(arr4); // [1, 2, 99, 4, 5]"
        },
        {
          "type": "interview-tip",
          "tip": "Key Differences",
          "explanation": "1. slice() creates new array, splice() modifies original\n2. slice(start, end) excludes end index\n3. splice(start, deleteCount, ...items) can add/remove/replace\n4. slice() safer for functional programming\n5. splice() useful when mutation is acceptable"
        },
        {
          "type": "title",
          "level": 2,
          "content": "Q2. Explain the difference between map() and forEach()?"
        },
        {
          "type": "description",
          "content": "map() creates and returns a new array with the results of calling a function on every element. forEach() executes a function on each element but returns undefined. Use map() when you need to transform data, forEach() when you just need to iterate."
        },
        {
          "type": "code",
          "language": "javascript",
          "title": "map() vs forEach() Comparison",
          "code": "const numbers = [1, 2, 3, 4, 5];\n\n// map() - Returns new array\nconst doubled = numbers.map(num => num * 2);\nconsole.log(doubled); // [2, 4, 6, 8, 10]\nconsole.log(numbers); // [1, 2, 3, 4, 5] - original unchanged\n\n// forEach() - Returns undefined\nconst result = numbers.forEach(num => num * 2);\nconsole.log(result); // undefined\n\n// forEach() - Use for side effects\nconst output = [];\nnumbers.forEach(num => output.push(num * 2));\nconsole.log(output); // [2, 4, 6, 8, 10]\n\n// Chaining with map()\nconst processed = numbers\n  .map(x => x * 2)    // [2, 4, 6, 8, 10]\n  .filter(x => x > 5) // [6, 8, 10]\n  .map(x => x / 2);   // [3, 4, 5]\n\n// Cannot chain forEach (returns undefined)\n// numbers.forEach(x => x * 2).filter(...); // Error!"
        },
        {
          "type": "interview-tip",
          "tip": "When to Use Each",
          "explanation": "1. map(): Transform data, need new array, functional approach\n2. forEach(): Side effects (logging, DOM updates), don't need return value\n3. map() is chainable, forEach() is not\n4. Both iterate entire array (can't break early)\n5. For breaking early, use for...of or traditional for loop"
        },
        {
          "type": "title",
          "level": 2,
          "content": "Q3. What does the reduce() method do?"
        },
        {
          "type": "description",
          "content": "reduce() executes a reducer function on each array element, resulting in a single output value. It takes an accumulator and current value as parameters. Common uses include summing numbers, flattening arrays, and grouping objects."
        },
        {
          "type": "code",
          "language": "javascript",
          "title": "reduce() Examples",
          "code": "// 1. Sum numbers\nconst numbers = [1, 2, 3, 4, 5];\nconst sum = numbers.reduce((acc, curr) => acc + curr, 0);\nconsole.log(sum); // 15\n\n// 2. Flatten array\nconst nested = [[1, 2], [3, 4], [5]];\nconst flat = nested.reduce((acc, arr) => acc.concat(arr), []);\nconsole.log(flat); // [1, 2, 3, 4, 5]\n\n// 3. Count occurrences\nconst fruits = ['apple', 'banana', 'apple', 'orange', 'banana', 'apple'];\nconst count = fruits.reduce((acc, fruit) => {\n  acc[fruit] = (acc[fruit] || 0) + 1;\n  return acc;\n}, {});\nconsole.log(count); // { apple: 3, banana: 2, orange: 1 }\n\n// 4. Group by property\nconst users = [\n  { name: 'Alice', age: 25 },\n  { name: 'Bob', age: 30 },\n  { name: 'Charlie', age: 25 }\n];\nconst groupedByAge = users.reduce((acc, user) => {\n  const age = user.age;\n  if (!acc[age]) acc[age] = [];\n  acc[age].push(user);\n  return acc;\n}, {});\n// { 25: [{Alice}, {Charlie}], 30: [{Bob}] }\n\n// 5. Transform array to object\nconst arr = ['a', 'b', 'c'];\nconst obj = arr.reduce((acc, val, idx) => {\n  acc[val] = idx;\n  return acc;\n}, {});\nconsole.log(obj); // { a: 0, b: 1, c: 2 }\n\n// 6. Pipe functions\nconst pipe = (...fns) => x => fns.reduce((v, f) => f(v), x);\nconst add5 = x => x + 5;\nconst multiply3 = x => x * 3;\nconst result = pipe(add5, multiply3)(10); // (10 + 5) * 3 = 45"
        },
        {
          "type": "interview-tip",
          "tip": "reduce() Best Practices",
          "explanation": "1. Always provide initial value (second parameter)\n2. Accumulator can be any type: number, object, array\n3. Return accumulator in each iteration\n4. More powerful than map/filter but harder to read\n5. Consider using specific methods for simple cases (sum → reduce, but map/filter for transformations)"
        },
        {
          "type": "title",
          "level": 2,
          "content": "Q4. Explain the difference between for...of and for...in loops?"
        },
        {
          "type": "description",
          "content": "for...of iterates over iterable objects (arrays, strings, Maps, Sets) returning values. for...in iterates over enumerable properties of objects returning keys/indices. Use for...of for arrays, for...in for object properties."
        },
        {
          "type": "code",
          "language": "javascript",
          "title": "for...of vs for...in Examples",
          "code": "// for...of - Iterates over VALUES\nconst array = ['a', 'b', 'c'];\nfor (const value of array) {\n  console.log(value); // 'a', 'b', 'c'\n}\n\n// for...in - Iterates over KEYS/INDICES\nfor (const index in array) {\n  console.log(index); // '0', '1', '2' (strings!)\n  console.log(typeof index); // 'string'\n}\n\n// Object iteration\nconst obj = { name: 'Alice', age: 25, city: 'NYC' };\n\n// for...in - Works with objects\nfor (const key in obj) {\n  console.log(key, obj[key]);\n  // name Alice\n  // age 25\n  // city NYC\n}\n\n// for...of - Doesn't work with plain objects\n// for (const val of obj) {} // Error: obj is not iterable\n\n// for...of with Object methods\nfor (const key of Object.keys(obj)) {\n  console.log(key); // name, age, city\n}\n\nfor (const value of Object.values(obj)) {\n  console.log(value); // Alice, 25, NYC\n}\n\nfor (const [key, value] of Object.entries(obj)) {\n  console.log(key, value); // name Alice, age 25, city NYC\n}\n\n// String iteration\nconst str = 'hello';\nfor (const char of str) {\n  console.log(char); // h, e, l, l, o\n}\n\n// Map and Set\nconst map = new Map([['a', 1], ['b', 2]]);\nfor (const [key, value] of map) {\n  console.log(key, value); // a 1, b 2\n}\n\nconst set = new Set([1, 2, 3]);\nfor (const value of set) {\n  console.log(value); // 1, 2, 3\n}\n\n// Array with custom properties (edge case)\nconst arr = [1, 2, 3];\narr.customProp = 'hello';\n\nfor (const val of arr) {\n  console.log(val); // 1, 2, 3 (only array elements)\n}\n\nfor (const key in arr) {\n  console.log(key); // '0', '1', '2', 'customProp' (includes custom property!)\n}"
        },
        {
          "type": "interview-tip",
          "tip": "Usage Guidelines",
          "explanation": "1. for...of: Arrays, strings, Maps, Sets, any iterable\n2. for...in: Object properties (but beware of prototype chain)\n3. for...of gets VALUES, for...in gets KEYS\n4. for...in returns strings, not numbers for array indices\n5. Avoid for...in for arrays (can include inherited properties)\n6. Use Object.hasOwnProperty() with for...in to skip inherited properties"
        }
      ]
    },
    {
      "id": "section-2",
      "title": "JavaScript - Data Types",
      "blocks": [
        {
          "type": "title",
          "level": 2,
          "content": "Q1. What is the difference between null and undefined?"
        },
        {
          "type": "description",
          "content": "undefined means a variable has been declared but not assigned a value, or a function doesn't return anything. null is an assignment value representing no value or empty. typeof null returns 'object' (historical bug), typeof undefined returns 'undefined'."
        },
        {
          "type": "code",
          "language": "javascript",
          "title": "null vs undefined Examples",
          "code": "// undefined - Variable declared but not assigned\nlet x;\nconsole.log(x); // undefined\nconsole.log(typeof x); // 'undefined'\n\n// undefined - Function with no return\nfunction noReturn() {}\nconsole.log(noReturn()); // undefined\n\n// undefined - Non-existent object property\nconst obj = { name: 'Alice' };\nconsole.log(obj.age); // undefined\n\n// undefined - Missing function parameter\nfunction greet(name) {\n  console.log(name); // undefined if not provided\n}\ngreet();\n\n// null - Intentional absence of value\nlet user = null; // explicitly set to null\nconsole.log(user); // null\nconsole.log(typeof user); // 'object' (JavaScript bug!)\n\n// Comparisons\nconsole.log(null == undefined);  // true (loose equality)\nconsole.log(null === undefined); // false (strict equality)\nconsole.log(null == 0);          // false\nconsole.log(undefined == 0);     // false\n\n// Practical usage\nfunction findUser(id) {\n  // return null to indicate \"searched but not found\"\n  // undefined would mean \"didn't search\" or error\n  return users.find(u => u.id === id) || null;\n}\n\n// Default values\nfunction config(options = {}) {\n  // undefined triggers default, null doesn't\n  const timeout = options.timeout ?? 1000; // nullish coalescing\n  const retry = options.retry !== undefined ? options.retry : 3;\n}\n\nconfig({ timeout: undefined }); // timeout = 1000\nconfig({ timeout: null });      // timeout = null (not default!)\nconfig({ timeout: 0 });         // timeout = 0 (falsy but defined)"
        },
        {
          "type": "interview-tip",
          "tip": "Key Differences",
          "explanation": "1. undefined: automatic, means 'not assigned'\n2. null: manual, means 'intentionally empty'\n3. typeof null === 'object' is a JavaScript bug from 1995\n4. Use null to reset/clear a value explicitly\n5. Use optional chaining (?.) to handle both: obj?.prop\n6. Nullish coalescing (???) only checks for null/undefined, not all falsy values"
        },
        {
          "type": "title",
          "level": 2,
          "content": "Q2. What is a Symbol in JavaScript?"
        },
        {
          "type": "description",
          "content": "Symbol is a primitive data type introduced in ES6 that creates unique, immutable identifiers. Used for creating unique object property keys that won't conflict. Created using Symbol() or Symbol.for() for global registry."
        },
        {
          "type": "code",
          "language": "javascript",
          "title": "Symbol Examples",
          "code": "// Creating symbols - each is unique\nconst sym1 = Symbol();\nconst sym2 = Symbol();\nconst sym3 = Symbol('description');\n\nconsole.log(sym1 === sym2); // false (always unique)\nconsole.log(sym3.toString()); // 'Symbol(description)'\n\n// Symbol as object property\nconst ID = Symbol('id');\nconst user = {\n  name: 'Alice',\n  [ID]: 12345 // symbol as computed property\n};\n\nconsole.log(user[ID]); // 12345\nconsole.log(user.ID);  // undefined (not the same as string 'ID')\n\n// Symbols are hidden from iteration\nfor (let key in user) {\n  console.log(key); // Only 'name' (symbol is skipped)\n}\n\nconsole.log(Object.keys(user)); // ['name']\nconsole.log(Object.getOwnPropertySymbols(user)); // [Symbol(id)]\n\n// Global symbol registry - Symbol.for()\nconst globalSym1 = Symbol.for('app.id');\nconst globalSym2 = Symbol.for('app.id');\nconsole.log(globalSym1 === globalSym2); // true (same from registry)\n\n// Get key from global symbol\nconsole.log(Symbol.keyFor(globalSym1)); // 'app.id'\nconsole.log(Symbol.keyFor(sym1)); // undefined (not in global registry)\n\n// Well-known symbols - built-in JavaScript symbols\nconst arr = [1, 2, 3];\nconsole.log(arr[Symbol.iterator]); // ƒ values() { [native code] }\n\n// Custom iterator using Symbol.iterator\nconst range = {\n  from: 1,\n  to: 5,\n  \n  [Symbol.iterator]() {\n    let current = this.from;\n    let last = this.to;\n    \n    return {\n      next() {\n        if (current <= last) {\n          return { value: current++, done: false };\n        }\n        return { done: true };\n      }\n    };\n  }\n};\n\nfor (let num of range) {\n  console.log(num); // 1, 2, 3, 4, 5\n}\n\n// Private-like properties (not truly private)\nconst _private = Symbol('private');\nclass MyClass {\n  constructor() {\n    this[_private] = 'secret';\n    this.public = 'visible';\n  }\n  \n  getPrivate() {\n    return this[_private];\n  }\n}\n\nconst instance = new MyClass();\nconsole.log(instance.public);        // 'visible'\nconsole.log(instance[_private]);     // undefined (don't have reference)\nconsole.log(instance.getPrivate());  // 'secret'"
        },
        {
          "type": "interview-tip",
          "tip": "Symbol Use Cases",
          "explanation": "1. Unique property keys (avoid name collisions)\n2. Meta-programming with well-known symbols (Symbol.iterator, Symbol.toStringTag)\n3. Semi-private object properties\n4. Constants that must be unique\n5. Symbols are not truly private (can access via Object.getOwnPropertySymbols())\n6. Common well-known symbols: iterator, hasInstance, toPrimitive, toStringTag"
        },
        {
          "type": "title",
          "level": 2,
          "content": "Q3. What is the difference between Set and Map?"
        },
        {
          "type": "description",
          "content": "Set stores unique values of any type, like a collection with no duplicates. Map stores key-value pairs where keys can be any type (not just strings). Set has add/has/delete, Map has set/get/has/delete methods."
        },
        {
          "type": "code",
          "language": "javascript",
          "title": "Set vs Map Examples",
          "code": "// SET - Unique values collection\nconst set = new Set();\n\n// Adding values\nset.add(1);\nset.add(2);\nset.add(2); // Duplicate ignored\nset.add('2'); // Different type, so added\n\nconsole.log(set); // Set(3) { 1, 2, '2' }\nconsole.log(set.size); // 3\nconsole.log(set.has(2)); // true\n\n// Remove duplicates from array\nconst numbers = [1, 2, 2, 3, 3, 3, 4];\nconst unique = [...new Set(numbers)];\nconsole.log(unique); // [1, 2, 3, 4]\n\n// Set operations\nconst setA = new Set([1, 2, 3]);\nconst setB = new Set([3, 4, 5]);\n\n// Union\nconst union = new Set([...setA, ...setB]);\nconsole.log(union); // Set(5) { 1, 2, 3, 4, 5 }\n\n// Intersection\nconst intersection = new Set([...setA].filter(x => setB.has(x)));\nconsole.log(intersection); // Set(1) { 3 }\n\n// Difference\nconst difference = new Set([...setA].filter(x => !setB.has(x)));\nconsole.log(difference); // Set(2) { 1, 2 }\n\n// Iteration\nfor (const value of set) {\n  console.log(value); // 1, 2, '2'\n}\n\nset.forEach(value => console.log(value));\n\n// MAP - Key-value pairs with any type keys\nconst map = new Map();\n\n// Setting values\nmap.set('name', 'Alice');\nmap.set(1, 'one');\nmap.set(true, 'boolean key');\n\nconst obj = { id: 1 };\nmap.set(obj, 'object as key'); // Object as key!\n\nconsole.log(map.size); // 4\nconsole.log(map.get('name')); // 'Alice'\nconsole.log(map.get(obj)); // 'object as key'\nconsole.log(map.has(1)); // true\n\n// Map from array of pairs\nconst map2 = new Map([\n  ['a', 1],\n  ['b', 2],\n  ['c', 3]\n]);\n\n// Iteration\nfor (const [key, value] of map) {\n  console.log(key, value);\n}\n\nmap.forEach((value, key) => {\n  console.log(key, value);\n});\n\n// Keys, values, entries\nconsole.log([...map.keys()]);   // ['name', 1, true, {id: 1}]\nconsole.log([...map.values()]); // ['Alice', 'one', 'boolean key', 'object as key']\nconsole.log([...map.entries()]); // [[key, value], ...]\n\n// Object vs Map\nconst plainObj = {};\nplainObj['1'] = 'string one';\nplainObj[1] = 'number one';\nconsole.log(plainObj); // { '1': 'number one' } - keys are strings!\n\nconst mapObj = new Map();\nmapObj.set('1', 'string one');\nmapObj.set(1, 'number one');\nconsole.log(mapObj.get('1')); // 'string one'\nconsole.log(mapObj.get(1));   // 'number one' - keys maintain type!\n\n// Performance comparison\nconst perfMap = new Map();\nconst perfObj = {};\n\n// Map is faster for frequent additions/deletions\n// Object is better for static key-value storage\n// Map maintains insertion order (objects do too in modern JS)"
        },
        {
          "type": "interview-tip",
          "tip": "Set vs Map Comparison",
          "explanation": "SET:\n1. Stores unique values only\n2. Methods: add(), has(), delete(), clear()\n3. Use for: removing duplicates, membership testing\n\nMAP:\n1. Stores key-value pairs\n2. Keys can be any type (objects, functions, primitives)\n3. Methods: set(), get(), has(), delete(), clear()\n4. Better than objects when: frequent add/delete, non-string keys, need size property\n5. Maintains insertion order\n\nBoth are iterable and have size property"
        },
        {
          "type": "title",
          "level": 2,
          "content": "Q4. What are WeakSet and WeakMap?"
        },
        {
          "type": "description",
          "content": "WeakSet and WeakMap hold 'weak' references to objects, allowing garbage collection if no other references exist. Keys must be objects. They're not enumerable and don't prevent garbage collection, useful for memory-sensitive scenarios."
        },
        {
          "type": "code",
          "language": "javascript",
          "title": "WeakSet and WeakMap Examples",
          "code": "// WEAKSET - Weak references to objects only\nconst weakSet = new WeakSet();\n\nlet obj1 = { name: 'Alice' };\nlet obj2 = { name: 'Bob' };\n\nweakSet.add(obj1);\nweakSet.add(obj2);\n\nconsole.log(weakSet.has(obj1)); // true\n\n// Cannot add primitives\n// weakSet.add(1); // TypeError: Invalid value used in weak set\n// weakSet.add('string'); // TypeError\n\n// Not enumerable\n// console.log(weakSet.size); // undefined\n// for (let item of weakSet) {} // TypeError: not iterable\n\n// Garbage collection\nobj1 = null; // Now obj1 can be garbage collected\n// WeakSet doesn't prevent garbage collection\n\n// Use case: Track object visited state\nconst visited = new WeakSet();\n\nfunction traverse(node) {\n  if (visited.has(node)) return; // Already visited\n  \n  visited.add(node);\n  // Process node...\n  \n  if (node.children) {\n    node.children.forEach(child => traverse(child));\n  }\n}\n\n// WEAKMAP - Weak references for keys\nconst weakMap = new WeakMap();\n\nlet user = { id: 1, name: 'Alice' };\nlet metadata = { lastLogin: new Date(), visits: 5 };\n\n// Store metadata associated with user object\nweakMap.set(user, metadata);\n\nconsole.log(weakMap.get(user)); // { lastLogin: ..., visits: 5 }\nconsole.log(weakMap.has(user)); // true\n\nweakMap.delete(user);\n\n// Keys must be objects\n// weakMap.set('key', 'value'); // TypeError\n\n// Not enumerable\n// console.log(weakMap.size); // undefined\n// weakMap.forEach(...); // Not available\n\n// Garbage collection\nuser = null; // metadata can now be garbage collected too\n\n// Use case 1: Private data storage\nconst privateData = new WeakMap();\n\nclass Person {\n  constructor(name, ssn) {\n    this.name = name; // public\n    privateData.set(this, { ssn }); // private via WeakMap\n  }\n  \n  getSSN() {\n    return privateData.get(this).ssn;\n  }\n}\n\nconst person = new Person('Alice', '123-45-6789');\nconsole.log(person.name); // 'Alice'\nconsole.log(person.ssn); // undefined (not accessible)\nconsole.log(person.getSSN()); // '123-45-6789'\n\n// Use case 2: Caching with automatic cleanup\nconst cache = new WeakMap();\n\nfunction computeExpensive(obj) {\n  if (cache.has(obj)) {\n    console.log('Using cached result');\n    return cache.get(obj);\n  }\n  \n  console.log('Computing...');\n  const result = /* expensive computation */ obj.value * 1000;\n  cache.set(obj, result);\n  return result;\n}\n\nlet data = { value: 42 };\ncomputeExpensive(data); // Computing... 42000\ncomputeExpensive(data); // Using cached result 42000\ndata = null; // Cache entry automatically removed when data is garbage collected\n\n// Use case 3: DOM node metadata\nconst elementData = new WeakMap();\n\nfunction attachData(element, data) {\n  elementData.set(element, data);\n}\n\nfunction getData(element) {\n  return elementData.get(element);\n}\n\n// When DOM element is removed, data is automatically cleaned up\nconst div = document.createElement('div');\nattachData(div, { clicks: 0, timestamp: Date.now() });\n// If div is removed from DOM and no references exist, data is GC'd"
        },
        {
          "type": "interview-tip",
          "tip": "Weak Collections Key Points",
          "explanation": "WHEN TO USE:\n1. WeakSet: Track object state without preventing GC (visited nodes, DOM elements)\n2. WeakMap: Associate metadata with objects (private data, caching)\n3. Memory-sensitive applications where cleanup is important\n\nLIMITATIONS:\n1. Keys/values must be objects (no primitives)\n2. Not enumerable (no size, no iteration)\n3. Can't get list of all keys/values\n4. Perfect for temporary associations that should not extend object lifetime"
        }
      ]
    },
    {
      "id": "section-3",
      "title": "JavaScript - Objects",
      "blocks": [
        {
          "type": "title",
          "level": 2,
          "content": "Q1. What is the difference between shallow copy and deep copy? How to implement each?"
        },
        {
          "type": "description",
          "content": "Shallow copy creates a new object but copies references to nested objects (one level deep). Deep copy creates a completely independent copy including all nested objects. Shallow: spread operator, Object.assign(). Deep: JSON.parse(JSON.stringify()), structuredClone(), or custom recursive function."
        },
        {
          "type": "code",
          "language": "javascript",
          "title": "Shallow vs Deep Copy Examples",
          "code": "// Original object with nested structure\nconst original = {\n  name: 'Alice',\n  age: 25,\n  address: {\n    city: 'NYC',\n    zip: '10001'\n  },\n  hobbies: ['reading', 'coding']\n};\n\n// SHALLOW COPY - Method 1: Spread operator\nconst shallow1 = { ...original };\nshallow1.name = 'Bob'; // OK - primitive copied\nshallow1.address.city = 'LA'; // PROBLEM - affects original!\n\nconsole.log(original.address.city); // 'LA' (changed!)\nconsole.log(shallow1.address === original.address); // true (same reference)\n\n// SHALLOW COPY - Method 2: Object.assign()\nconst shallow2 = Object.assign({}, original);\nshallow2.hobbies.push('gaming'); // PROBLEM - affects original!\nconsole.log(original.hobbies); // ['reading', 'coding', 'gaming']\n\n// DEEP COPY - Method 1: JSON (limitations!)\nconst deep1 = JSON.parse(JSON.stringify(original));\ndeep1.address.city = 'SF';\ndeep1.hobbies.push('swimming');\n\nconsole.log(original.address.city); // 'NYC' (unchanged!)\nconsole.log(original.hobbies.length); // 3 (unchanged)\nconsole.log(deep1.address === original.address); // false\n\n// JSON method limitations\nconst withFunctions = {\n  name: 'Test',\n  method: function() { return 'hello'; },\n  date: new Date(),\n  undefined: undefined,\n  symbol: Symbol('test'),\n  circular: null\n};\nwithFunctions.circular = withFunctions; // circular reference\n\nconst jsonCopy = JSON.parse(JSON.stringify(withFunctions));\nconsole.log(jsonCopy.method); // undefined (functions lost!)\nconsole.log(jsonCopy.date); // string, not Date object\nconsole.log(jsonCopy.undefined); // undefined (property lost!)\nconsole.log(jsonCopy.symbol); // undefined (symbols lost!)\n// Circular reference would throw error\n\n// DEEP COPY - Method 2: structuredClone (modern, best)\nconst deep2 = structuredClone(original);\ndeep2.address.city = 'Boston';\nconsole.log(original.address.city); // 'NYC' (unchanged)\n\n// structuredClone handles more types\nconst complex = {\n  date: new Date(),\n  map: new Map([['a', 1]]),\n  set: new Set([1, 2, 3]),\n  arrayBuffer: new ArrayBuffer(8),\n  regex: /test/gi\n};\n\nconst complexCopy = structuredClone(complex);\nconsole.log(complexCopy.date instanceof Date); // true\nconsole.log(complexCopy.map instanceof Map); // true\n\n// structuredClone limitations (no functions, symbols)\nconst withFunc = { fn: () => 'test' };\n// structuredClone(withFunc); // Error: functions not cloneable\n\n// DEEP COPY - Method 3: Custom recursive\nfunction deepClone(obj, hash = new WeakMap()) {\n  // Handle primitives and null\n  if (obj === null || typeof obj !== 'object') return obj;\n  \n  // Handle circular references\n  if (hash.has(obj)) return hash.get(obj);\n  \n  // Handle Date\n  if (obj instanceof Date) return new Date(obj);\n  \n  // Handle RegExp\n  if (obj instanceof RegExp) return new RegExp(obj);\n  \n  // Handle Array\n  if (Array.isArray(obj)) {\n    const arrCopy = [];\n    hash.set(obj, arrCopy);\n    obj.forEach((item, index) => {\n      arrCopy[index] = deepClone(item, hash);\n    });\n    return arrCopy;\n  }\n  \n  // Handle Object\n  const objCopy = {};\n  hash.set(obj, objCopy);\n  \n  Object.keys(obj).forEach(key => {\n    objCopy[key] = deepClone(obj[key], hash);\n  });\n  \n  return objCopy;\n}\n\n// Test custom deep clone\nconst testObj = {\n  a: 1,\n  b: { c: 2 },\n  d: [3, 4],\n  e: new Date(),\n  f: /test/\n};\ntestObj.circular = testObj;\n\nconst cloned = deepClone(testObj);\ncloned.b.c = 999;\nconsole.log(testObj.b.c); // 2 (unchanged)\nconsole.log(cloned.circular === cloned); // true (circular maintained)"
        },
        {
          "type": "interview-tip",
          "tip": "Copy Methods Summary",
          "explanation": "SHALLOW COPY:\n- Spread (...), Object.assign(), Array.slice()\n- Fast, one-level deep only\n- Nested objects share references\n\nDEEP COPY:\n- structuredClone() - BEST for most cases (modern browsers)\n- JSON.parse(JSON.stringify()) - Simple but loses functions, dates become strings\n- Custom recursive - Full control, handles all cases\n- Libraries: lodash.cloneDeep() for production\n\nChoose based on: data complexity, performance needs, browser support"
        },
        {
          "type": "title",
          "level": 2,
          "content": "Q2. Explain Object.assign() and its use cases?"
        },
        {
          "type": "description",
          "content": "Object.assign() copies enumerable own properties from one or more source objects to a target object. Returns the target object. Used for shallow copying, merging objects, and cloning. Syntax: Object.assign(target, ...sources)."
        },
        {
          "type": "code",
          "language": "javascript",
          "title": "Object.assign() Examples",
          "code": "// Basic usage: Object.assign(target, source1, source2, ...)\n\n// 1. Cloning an object (shallow)\nconst original = { a: 1, b: 2 };\nconst clone = Object.assign({}, original);\nclone.a = 99;\nconsole.log(original.a); // 1 (unchanged)\n\n// 2. Merging objects\nconst defaults = { theme: 'light', lang: 'en', timeout: 5000 };\nconst userConfig = { theme: 'dark', timeout: 3000 };\nconst config = Object.assign({}, defaults, userConfig);\nconsole.log(config); // { theme: 'dark', lang: 'en', timeout: 3000 }\n// userConfig properties override defaults\n\n// 3. Adding properties to existing object\nconst user = { name: 'Alice' };\nObject.assign(user, { age: 25, email: 'alice@example.com' });\nconsole.log(user); // { name: 'Alice', age: 25, email: 'alice@example.com' }\n\n// 4. Multiple sources (later sources override earlier)\nconst obj1 = { a: 1, b: 2 };\nconst obj2 = { b: 3, c: 4 };\nconst obj3 = { c: 5, d: 6 };\nconst merged = Object.assign({}, obj1, obj2, obj3);\nconsole.log(merged); // { a: 1, b: 3, c: 5, d: 6 }\n\n// 5. Shallow copy problem\nconst source = {\n  name: 'Alice',\n  address: { city: 'NYC' }\n};\nconst copy = Object.assign({}, source);\ncopy.address.city = 'LA';\nconsole.log(source.address.city); // 'LA' (affected!)\n\n// 6. Only enumerable properties\nconst source2 = Object.create(\n  { inherited: 1 }, // prototype (not copied)\n  {\n    own: { value: 2, enumerable: true },\n    hidden: { value: 3, enumerable: false }\n  }\n);\n\nconst copy2 = Object.assign({}, source2);\nconsole.log(copy2); // { own: 2 } (only enumerable own properties)\nconsole.log(copy2.inherited); // undefined\nconsole.log(copy2.hidden); // undefined\n\n// 7. Copying symbols\nconst sym = Symbol('test');\nconst withSymbol = { [sym]: 'symbol value', regular: 'regular' };\nconst copiedSymbol = Object.assign({}, withSymbol);\nconsole.log(copiedSymbol[sym]); // 'symbol value' (symbols copied!)\n\n// 8. Triggering setters\nconst target = {\n  set name(value) {\n    console.log(`Setting name to ${value}`);\n    this._name = value;\n  }\n};\n\nObject.assign(target, { name: 'Alice' }); // Logs: Setting name to Alice\n\n// 9. Error handling (stops on error)\ntry {\n  const target = {};\n  const source1 = { a: 1 };\n  const source2 = Object.defineProperty({}, 'b', {\n    get() { throw new Error('Error!'); }\n  });\n  const source3 = { c: 3 };\n  \n  Object.assign(target, source1, source2, source3);\n} catch (e) {\n  console.log(e.message); // 'Error!'\n  // target has { a: 1 } but not c: 3 (stopped on error)\n}\n\n// 10. vs Spread operator (similar but different)\nconst a = { x: 1, y: 2 };\nconst b = { y: 3, z: 4 };\n\n// Object.assign modifies first argument\nconst result1 = Object.assign(a, b);\nconsole.log(a); // { x: 1, y: 3, z: 4 } (modified!)\nconsole.log(result1 === a); // true (same object)\n\n// Spread creates new object\nconst c = { x: 1, y: 2 };\nconst d = { y: 3, z: 4 };\nconst result2 = { ...c, ...d };\nconsole.log(c); // { x: 1, y: 2 } (unchanged)\nconsole.log(result2 === c); // false (new object)\n\n// Common patterns\n// Pattern 1: Default options\nfunction createUser(options) {\n  const defaults = {\n    role: 'user',\n    active: true,\n    permissions: ['read']\n  };\n  return Object.assign({}, defaults, options);\n}\n\n// Pattern 2: Immutable update\nfunction updateState(state, updates) {\n  return Object.assign({}, state, updates);\n}\n\nconst state = { count: 0, loading: false };\nconst newState = updateState(state, { count: 1 });\nconsole.log(state); // { count: 0, loading: false } (unchanged)\nconsole.log(newState); // { count: 1, loading: false }"
        },
        {
          "type": "interview-tip",
          "tip": "Object.assign() Key Points",
          "explanation": "1. RETURNS the target object (mutates it)\n2. Shallow copy only (nested objects referenced)\n3. Copies enumerable own properties + symbols\n4. Later sources override earlier ones\n5. Triggers setters on target object\n6. Stops on first error\n\nMODERN ALTERNATIVE:\nSpread operator {...a, ...b} is preferred:\n- More readable\n- Creates new object (doesn't mutate)\n- Same shallow copy behavior\n\nUSE CASES:\n- Merging configs/options\n- Shallow cloning\n- Adding properties\n- Polyfills (older browsers)"
        },
        {
          "type": "title",
          "level": 2,
          "content": "Q3. What are property descriptors? Explain Object.defineProperty()?"
        },
        {
          "type": "description",
          "content": "Property descriptors are objects that define the characteristics of object properties: value, writable, enumerable, configurable, get, set. Object.defineProperty() allows precise control over property behavior. Used for read-only properties, getters/setters, and hiding properties from iteration."
        },
        {
          "type": "code",
          "language": "javascript",
          "title": "Property Descriptors Examples",
          "code": "// Getting property descriptor\nconst obj = { name: 'Alice', age: 25 };\nconst descriptor = Object.getOwnPropertyDescriptor(obj, 'name');\nconsole.log(descriptor);\n// {\n//   value: 'Alice',\n//   writable: true,     // can change value\n//   enumerable: true,   // shows in for...in, Object.keys()\n//   configurable: true  // can delete or change descriptor\n// }\n\n// Defining property with custom descriptor\nconst person = {};\n\nObject.defineProperty(person, 'name', {\n  value: 'Bob',\n  writable: false,     // Read-only!\n  enumerable: true,\n  configurable: false  // Can't delete or reconfigure!\n});\n\nperson.name = 'Charlie'; // Fails silently (strict mode: TypeError)\nconsole.log(person.name); // 'Bob' (unchanged)\n\ndelete person.name; // Fails silently\nconsole.log(person.name); // 'Bob' (still there)\n\n// Attempting to reconfigure\ntry {\n  Object.defineProperty(person, 'name', { writable: true });\n} catch (e) {\n  console.log(e.message); // TypeError: Cannot redefine property\n}\n\n// Non-enumerable property (hidden from iteration)\nconst user = { firstName: 'Alice', lastName: 'Smith' };\n\nObject.defineProperty(user, 'ssn', {\n  value: '123-45-6789',\n  enumerable: false  // Hidden!\n});\n\nconsole.log(user.ssn); // '123-45-6789' (accessible)\nconsole.log(Object.keys(user)); // ['firstName', 'lastName'] (ssn hidden)\nfor (let key in user) {\n  console.log(key); // firstName, lastName (no ssn)\n}\n\n// Get all properties including non-enumerable\nconsole.log(Object.getOwnPropertyNames(user)); // ['firstName', 'lastName', 'ssn']\n\n// Getter and Setter\nconst account = {\n  _balance: 1000 // convention: underscore for 'internal'\n};\n\nObject.defineProperty(account, 'balance', {\n  get() {\n    console.log('Getting balance');\n    return this._balance;\n  },\n  set(value) {\n    if (value < 0) {\n      throw new Error('Balance cannot be negative');\n    }\n    console.log(`Setting balance to ${value}`);\n    this._balance = value;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nconsole.log(account.balance); // Logs 'Getting balance', returns 1000\naccount.balance = 2000; // Logs 'Setting balance to 2000'\ntry {\n  account.balance = -100; // Throws error\n} catch (e) {\n  console.log(e.message);\n}\n\n// Computed property\nconst person2 = {\n  firstName: 'John',\n  lastName: 'Doe'\n};\n\nObject.defineProperty(person2, 'fullName', {\n  get() {\n    return `${this.firstName} ${this.lastName}`;\n  },\n  set(value) {\n    const parts = value.split(' ');\n    this.firstName = parts[0];\n    this.lastName = parts[1];\n  },\n  enumerable: true\n});\n\nconsole.log(person2.fullName); // 'John Doe'\nperson2.fullName = 'Jane Smith';\nconsole.log(person2.firstName); // 'Jane'\nconsole.log(person2.lastName); // 'Smith'\n\n// Define multiple properties\nconst product = {};\n\nObject.defineProperties(product, {\n  id: {\n    value: 1,\n    writable: false,\n    enumerable: true\n  },\n  name: {\n    value: 'Laptop',\n    writable: true,\n    enumerable: true\n  },\n  _price: {\n    value: 1000,\n    writable: true,\n    enumerable: false  // Internal property\n  },\n  price: {\n    get() { return this._price; },\n    set(val) {\n      if (val < 0) throw new Error('Invalid price');\n      this._price = val;\n    },\n    enumerable: true\n  }\n});\n\nconsole.log(product); // { id: 1, name: 'Laptop', price: [Getter/Setter] }\n\n// Preventing object modification\nconst config = { api: 'https://api.example.com', timeout: 5000 };\n\n// Prevent adding new properties\nObject.preventExtensions(config);\nconfig.newProp = 'test'; // Fails silently\nconsole.log(config.newProp); // undefined\nconfig.timeout = 3000; // OK - can still modify existing\n\n// Make all properties non-configurable\nconst settings = { theme: 'dark' };\nObject.seal(settings);\nsettings.theme = 'light'; // OK - can modify value\nsettings.newProp = 'test'; // Fails - can't add\ndelete settings.theme; // Fails - can't delete\n\n// Make all properties read-only\nconst constants = { PI: 3.14159, E: 2.71828 };\nObject.freeze(constants);\nconstants.PI = 3; // Fails\nconstants.newProp = 1; // Fails\ndelete constants.PI; // Fails\nconsole.log(Object.isFrozen(constants)); // true\n\n// Note: freeze/seal are shallow!\nconst data = {\n  user: { name: 'Alice' }\n};\nObject.freeze(data);\ndata.user.name = 'Bob'; // Works! (nested object not frozen)\nconsole.log(data.user.name); // 'Bob'\n\n// Deep freeze implementation\nfunction deepFreeze(obj) {\n  Object.freeze(obj);\n  Object.getOwnPropertyNames(obj).forEach(prop => {\n    if (obj[prop] !== null\n        && (typeof obj[prop] === 'object' || typeof obj[prop] === 'function')\n        && !Object.isFrozen(obj[prop])) {\n      deepFreeze(obj[prop]);\n    }\n  });\n  return obj;\n}"
        },
        {
          "type": "interview-tip",
          "tip": "Property Descriptor Flags",
          "explanation": "DESCRIPTOR PROPERTIES:\n- value: property value\n- writable: can change value (default: false for defineProperty)\n- enumerable: shows in iteration (default: false for defineProperty)\n- configurable: can delete/modify descriptor (default: false for defineProperty)\n- get: getter function\n- set: setter function\n\nOBJECT PROTECTION LEVELS:\n1. Object.preventExtensions() - can't add new properties\n2. Object.seal() - can't add/delete, can modify values\n3. Object.freeze() - completely immutable (shallow)\n\nUSE CASES:\n- Read-only constants\n- Validation in setters\n- Computed properties\n- Hiding internal properties"
        },
        {
          "type": "title",
          "level": 2,
          "content": "Q4. What is optional chaining (?.) and nullish coalescing (???)?"
        },
        {
          "type": "description",
          "content": "Optional chaining (?.) safely accesses nested properties without throwing errors if intermediate values are null/undefined. Nullish coalescing (??) provides default values only for null/undefined (unlike || which treats all falsy values). Both introduced in ES2020."
        },
        {
          "type": "code",
          "language": "javascript",
          "title": "Optional Chaining & Nullish Coalescing",
          "code": "// OPTIONAL CHAINING (?.) - Safe property access\n\n// Without optional chaining (old way)\nconst user = {\n  name: 'Alice',\n  address: {\n    city: 'NYC'\n    // no street property\n  }\n};\n\n// Throws TypeError if address is undefined\n// const street = user.address.street.name; // Error!\n\n// Old defensive approach\nconst street1 = user && user.address && user.address.street && user.address.street.name;\nconsole.log(street1); // undefined (no error)\n\n// With optional chaining (modern)\nconst street2 = user?.address?.street?.name;\nconsole.log(street2); // undefined (clean!)\n\n// Optional chaining short-circuits\nlet count = 0;\nconst result = user?.missing?.prop?.[count++];\nconsole.log(count); // 0 (never incremented, short-circuited at 'missing')\n\n// Optional chaining with methods\nconst api = {\n  getData: () => ({ data: [1, 2, 3] })\n};\n\n// Safe method call\nconst data = api.getData?.();\nconsole.log(data); // { data: [1, 2, 3] }\n\nconst missingData = api.fetchData?.(); // undefined (method doesn't exist)\nconsole.log(missingData); // undefined (no error)\n\n// Optional chaining with arrays\nconst users = [\n  { name: 'Alice', settings: { theme: 'dark' } },\n  { name: 'Bob' } // no settings\n];\n\nconsole.log(users[0]?.settings?.theme); // 'dark'\nconsole.log(users[1]?.settings?.theme); // undefined\nconsole.log(users[5]?.settings?.theme); // undefined (index doesn't exist)\n\n// Dynamic property access\nconst propName = 'address';\nconst city = user?.[propName]?.city;\nconsole.log(city); // 'NYC'\n\n// NULLISH COALESCING (??) - Default values\n\n// Problem with logical OR (||)\nconst config1 = {\n  timeout: 0,      // valid value!\n  retry: '',       // valid value!\n  debug: false     // valid value!\n};\n\n// || treats all falsy values as \"use default\"\nconst timeout1 = config1.timeout || 5000;\nconst retry1 = config1.retry || 'default';\nconst debug1 = config1.debug || true;\n\nconsole.log(timeout1); // 5000 (wanted 0!)\nconsole.log(retry1);   // 'default' (wanted ''!)\nconsole.log(debug1);   // true (wanted false!)\n\n// ?? only treats null/undefined as \"use default\"\nconst timeout2 = config1.timeout ?? 5000;\nconst retry2 = config1.retry ?? 'default';\nconst debug2 = config1.debug ?? true;\n\nconsole.log(timeout2); // 0 (correct!)\nconsole.log(retry2);   // '' (correct!)\nconsole.log(debug2);   // false (correct!)\n\n// Only null/undefined trigger default\nconst value1 = null ?? 'default';      // 'default'\nconst value2 = undefined ?? 'default'; // 'default'\nconst value3 = 0 ?? 'default';         // 0\nconst value4 = '' ?? 'default';        // ''\nconst value5 = false ?? 'default';     // false\nconst value6 = NaN ?? 'default';       // NaN\n\n// Combining both operators\nconst userConfig = {\n  user: {\n    preferences: {\n      notifications: null\n    }\n  }\n};\n\nconst notifications = userConfig?.user?.preferences?.notifications ?? true;\nconsole.log(notifications); // true (null → default)\n\n// Practical example: API response handling\nfunction getUserData(apiResponse) {\n  return {\n    name: apiResponse?.user?.name ?? 'Guest',\n    email: apiResponse?.user?.email ?? 'no-email@example.com',\n    age: apiResponse?.user?.age ?? 0,\n    premium: apiResponse?.user?.premium ?? false,\n    settings: apiResponse?.user?.settings ?? { theme: 'light' }\n  };\n}\n\nconst response1 = { user: { name: 'Alice', age: 0 } };\nconst data1 = getUserData(response1);\nconsole.log(data1);\n// {\n//   name: 'Alice',\n//   email: 'no-email@example.com',\n//   age: 0,  // keeps 0, doesn't use default!\n//   premium: false,\n//   settings: { theme: 'light' }\n// }\n\nconst response2 = null;\nconst data2 = getUserData(response2);\nconsole.log(data2); // All defaults\n\n// Cannot combine with || or &&\n// const x = a ?? b || c;  // SyntaxError!\n// const y = a && b ?? c;  // SyntaxError!\n\n// Must use parentheses\nconst x = (a ?? b) || c;  // OK\nconst y = a && (b ?? c);  // OK\n\n// Nullish coalescing assignment (??=)\nlet config = { timeout: 1000 };\nconfig.timeout ??= 5000;  // 1000 (no change)\nconfig.retry ??= 3;        // 3 (assigned)\nconfig.debug ??= false;    // false (assigned)\nconsole.log(config); // { timeout: 1000, retry: 3, debug: false }\n\n// Real-world: form validation\nfunction validateForm(formData) {\n  return {\n    username: formData?.username ?? '',\n    email: formData?.email ?? '',\n    age: formData?.age ?? null,\n    terms: formData?.terms ?? false\n  };\n}\n\n// Real-world: localStorage with defaults\nfunction getSetting(key, defaultValue) {\n  const stored = localStorage.getItem(key);\n  return stored !== null ? JSON.parse(stored) : defaultValue;\n}\n\n// Using ?? operator\nfunction getSetting2(key, defaultValue) {\n  return JSON.parse(localStorage.getItem(key)) ?? defaultValue;\n}"
        },
        {
          "type": "interview-tip",
          "tip": "Optional Chaining & Nullish Coalescing",
          "explanation": "OPTIONAL CHAINING (?.):\n- Returns undefined if any part is null/undefined\n- Works with: properties (?.), methods (?.()), arrays (?.[i])\n- Short-circuits evaluation (stops at first null/undefined)\n- Can't be used on left side of assignment\n\nNULLISH COALESCING (??):\n- Only null/undefined trigger default (not 0, '', false)\n- Better than || for default values\n- Can't mix with && or || without parentheses\n- Assignment variant: ??=\n\nCOMBINE THEM:\nuser?.profile?.theme ?? 'light'\n\nBROWSER SUPPORT: ES2020+ (most modern browsers)"
        }
      ]
    },
    {
      "id": "section-4",
      "title": "JavaScript - Functions",
      "blocks": [
        {
          "type": "title",
          "level": 2,
          "content": "Q1. Explain 'this' keyword and how its value is determined?"
        },
        {
          "type": "description",
          "content": "The 'this' keyword refers to the object that is executing the current function. Its value is determined by how the function is called (call-site), not where it's defined. Rules: method call (object), standalone function (global/undefined in strict), constructor (new object), explicit binding (call/apply/bind), arrow functions (lexical this)."
        },
        {
          "type": "code",
          "language": "javascript",
          "title": "'this' Keyword Examples",
          "code": "// Rule 1: Method invocation - 'this' is the object\nconst user = {\n  name: 'Alice',\n  greet() {\n    console.log(`Hello, ${this.name}`);\n  }\n};\n\nuser.greet(); // 'Hello, Alice' (this = user)\n\n// Losing 'this' context\nconst greetFunc = user.greet;\ngreetFunc(); // 'Hello, undefined' (this = global/undefined in strict)\n\n// Rule 2: Standalone function - 'this' is global (or undefined in strict mode)\nfunction showThis() {\n  console.log(this);\n}\n\nshowThis(); // Window (browser) or global (Node.js)\n\n'use strict';\nfunction strictThis() {\n  console.log(this);\n}\nstrictThis(); // undefined (in strict mode)\n\n// Rule 3: Constructor invocation - 'this' is the new object\nfunction Person(name) {\n  this.name = name;\n  this.greet = function() {\n    console.log(`Hi, I'm ${this.name}`);\n  };\n}\n\nconst person1 = new Person('Bob');\nperson1.greet(); // 'Hi, I'm Bob' (this = person1)\n\n// Rule 4: Explicit binding - call(), apply(), bind()\nfunction introduce(greeting, punctuation) {\n  console.log(`${greeting}, I'm ${this.name}${punctuation}`);\n}\n\nconst user1 = { name: 'Alice' };\nconst user2 = { name: 'Bob' };\n\n// call() - arguments separately\nintroduce.call(user1, 'Hello', '!'); // 'Hello, I'm Alice!'\nintroduce.call(user2, 'Hi', '.'); // 'Hi, I'm Bob.'\n\n// apply() - arguments as array\nintroduce.apply(user1, ['Hello', '!']); // 'Hello, I'm Alice!'\n\n// bind() - returns new function with fixed 'this'\nconst introduceAlice = introduce.bind(user1);\nintroduceAlice('Hey', '!!!'); // 'Hey, I'm Alice!!!'\n\n// Rule 5: Arrow functions - lexical 'this' (from enclosing scope)\nconst obj = {\n  name: 'Charlie',\n  regularFunc: function() {\n    console.log('Regular:', this.name); // 'Charlie'\n    \n    setTimeout(function() {\n      console.log('Callback regular:', this.name); // undefined (this = global)\n    }, 100);\n    \n    setTimeout(() => {\n      console.log('Callback arrow:', this.name); // 'Charlie' (lexical this)\n    }, 100);\n  },\n  \n  arrowFunc: () => {\n    console.log('Arrow:', this.name); // undefined (this from outer scope)\n  }\n};\n\nobj.regularFunc();\nobj.arrowFunc();\n\n// Practical example: Event handlers\nclass Button {\n  constructor(label) {\n    this.label = label;\n    this.clicks = 0;\n  }\n  \n  // Wrong: loses 'this' context\n  handleClickWrong() {\n    this.clicks++;\n    console.log(`${this.label} clicked ${this.clicks} times`);\n  }\n  \n  // Solution 1: Arrow function (recommended)\n  handleClickArrow = () => {\n    this.clicks++;\n    console.log(`${this.label} clicked ${this.clicks} times`);\n  }\n  \n  // Solution 2: Bind in constructor\n  constructor2(label) {\n    this.label = label;\n    this.clicks = 0;\n    this.handleClickWrong = this.handleClickWrong.bind(this);\n  }\n}\n\nconst btn = new Button('Submit');\n// In browser:\n// element.addEventListener('click', btn.handleClickWrong); // Error! 'this' = element\n// element.addEventListener('click', btn.handleClickArrow); // Works!\n\n// Complex example: method chaining\nclass Calculator {\n  constructor() {\n    this.value = 0;\n  }\n  \n  add(n) {\n    this.value += n;\n    return this; // return 'this' for chaining\n  }\n  \n  subtract(n) {\n    this.value -= n;\n    return this;\n  }\n  \n  multiply(n) {\n    this.value *= n;\n    return this;\n  }\n  \n  getResult() {\n    return this.value;\n  }\n}\n\nconst calc = new Calculator();\nconst result = calc.add(5).multiply(2).subtract(3).getResult();\nconsole.log(result); // 7\n\n// 'this' in nested objects\nconst company = {\n  name: 'TechCorp',\n  employee: {\n    name: 'John',\n    getName() {\n      return this.name; // 'this' = employee, not company\n    }\n  }\n};\n\nconsole.log(company.employee.getName()); // 'John'\n\n// Arrow function can't be used as constructor\ntry {\n  const ArrowPerson = (name) => {\n    this.name = name;\n  };\n  new ArrowPerson('Test'); // TypeError: ArrowPerson is not a constructor\n} catch (e) {\n  console.log(e.message);\n}\n\n// 'this' priority (highest to lowest)\n// 1. new binding\n// 2. explicit binding (call, apply, bind)\n// 3. implicit binding (method call)\n// 4. default binding (global/undefined)\n// Note: Arrow functions ignore all above rules and use lexical scope"
        },
        {
          "type": "interview-tip",
          "tip": "'this' Determination Rules",
          "explanation": "PRIORITY ORDER:\n1. new Constructor() → 'this' = new object\n2. func.call/apply/bind(obj) → 'this' = obj\n3. obj.method() → 'this' = obj\n4. standalone function → 'this' = global (undefined in strict)\n5. Arrow function → 'this' = lexical (from outer scope)\n\nCOMMON PITFALLS:\n- Event handlers lose 'this' (use arrow or bind)\n- Callbacks lose 'this' (use arrow functions)\n- Method extraction loses context\n\nSOLUTIONS:\n- Arrow functions for callbacks\n- bind() for event handlers\n- const self = this (old pattern, avoid)"
        },
        {
          "type": "title",
          "level": 2,
          "content": "Q2. What is the difference between call(), apply(), and bind()?"
        },
        {
          "type": "description",
          "content": "All three methods set the 'this' value for a function. call() invokes immediately with arguments separately. apply() invokes immediately with arguments as array. bind() returns a new function with 'this' bound permanently (doesn't invoke immediately)."
        },
        {
          "type": "code",
          "language": "javascript",
          "title": "call(), apply(), bind() Examples",
          "code": "const person1 = { name: 'Alice', age: 25 };\nconst person2 = { name: 'Bob', age: 30 };\n\nfunction introduce(greeting, punctuation) {\n  console.log(`${greeting}, I'm ${this.name}, ${this.age} years old${punctuation}`);\n}\n\n// CALL - func.call(thisArg, arg1, arg2, ...)\n// Arguments passed individually\nintroduce.call(person1, 'Hello', '!'); // 'Hello, I'm Alice, 25 years old!'\nintroduce.call(person2, 'Hi', '.'); // 'Hi, I'm Bob, 30 years old.'\n\n// APPLY - func.apply(thisArg, [argsArray])\n// Arguments passed as array\nintroduce.apply(person1, ['Hello', '!']); // 'Hello, I'm Alice, 25 years old!'\nintroduce.apply(person2, ['Hi', '.']); // 'Hi, I'm Bob, 30 years old.'\n\n// BIND - func.bind(thisArg, arg1, arg2, ...)\n// Returns NEW function, doesn't invoke immediately\nconst introduceAlice = introduce.bind(person1);\nintroduceAlice('Hey', '!!!'); // 'Hey, I'm Alice, 25 years old!!!'\n\nconst introduceBob = introduce.bind(person2, 'Greetings'); // Partial application\nintroduceBob('...'); // 'Greetings, I'm Bob, 30 years old...'\n\n// Use case 1: Borrowing methods\nconst nums1 = { data: [1, 2, 3] };\nconst nums2 = { data: [4, 5, 6] };\n\nfunction sum() {\n  return this.data.reduce((acc, n) => acc + n, 0);\n}\n\nconsole.log(sum.call(nums1)); // 6\nconsole.log(sum.call(nums2)); // 15\n\n// Use case 2: Array-like objects to arrays\nfunction showArgs() {\n  // arguments is array-like, not real array\n  console.log(arguments); // { 0: 'a', 1: 'b', 2: 'c', length: 3 }\n  \n  // Convert to real array using call\n  const argsArray = Array.prototype.slice.call(arguments);\n  console.log(argsArray); // ['a', 'b', 'c']\n  \n  // Modern way: spread or Array.from()\n  const args1 = [...arguments];\n  const args2 = Array.from(arguments);\n}\n\nshowArgs('a', 'b', 'c');\n\n// Use case 3: Finding max/min with apply\nconst numbers = [5, 6, 2, 3, 7, 1, 9];\n\n// Math.max expects separate arguments, not array\nconst max = Math.max.apply(null, numbers);\nconsole.log(max); // 9\n\n// Modern way: spread\nconst max2 = Math.max(...numbers);\nconsole.log(max2); // 9\n\n// Use case 4: Function currying with bind\nfunction multiply(a, b) {\n  return a * b;\n}\n\nconst double = multiply.bind(null, 2); // Fix first argument\nconsole.log(double(5)); // 10\nconsole.log(double(10)); // 20\n\nconst triple = multiply.bind(null, 3);\nconsole.log(triple(5)); // 15\n\n// Use case 5: Event handlers\nclass Counter {\n  constructor() {\n    this.count = 0;\n    // Bind in constructor\n    this.increment = this.increment.bind(this);\n  }\n  \n  increment() {\n    this.count++;\n    console.log(`Count: ${this.count}`);\n  }\n}\n\nconst counter = new Counter();\n// In browser: button.addEventListener('click', counter.increment);\nsetTimeout(counter.increment, 1000); // Works because bound\n\n// Use case 6: Partial application\nfunction greet(greeting, name, punctuation) {\n  return `${greeting}, ${name}${punctuation}`;\n}\n\nconst sayHelloTo = greet.bind(null, 'Hello');\nconsole.log(sayHelloTo('Alice', '!')); // 'Hello, Alice!'\nconsole.log(sayHelloTo('Bob', '.')); // 'Hello, Bob.'\n\nconst sayHelloToAlice = greet.bind(null, 'Hello', 'Alice');\nconsole.log(sayHelloToAlice('!')); // 'Hello, Alice!'\n\n// Advanced: Implementing bind polyfill\nif (!Function.prototype.bind) {\n  Function.prototype.bind = function(context, ...boundArgs) {\n    const fn = this;\n    return function(...args) {\n      return fn.apply(context, [...boundArgs, ...args]);\n    };\n  };\n}\n\n// Implementing call polyfill\nFunction.prototype.myCall = function(context, ...args) {\n  context = context || globalThis;\n  const fnSymbol = Symbol();\n  context[fnSymbol] = this;\n  const result = context[fnSymbol](...args);\n  delete context[fnSymbol];\n  return result;\n};\n\n// Implementing apply polyfill\nFunction.prototype.myApply = function(context, args = []) {\n  return this.myCall(context, ...args);\n};\n\n// Testing custom implementations\nfunction test(a, b) {\n  console.log(`${this.name}: ${a + b}`);\n}\n\nconst obj = { name: 'Test' };\ntest.myCall(obj, 2, 3); // 'Test: 5'\ntest.myApply(obj, [2, 3]); // 'Test: 5'\n\n// Performance comparison\nconsole.time('call');\nfor (let i = 0; i < 1000000; i++) {\n  introduce.call(person1, 'Hi', '!');\n}\nconsole.timeEnd('call');\n\nconsole.time('apply');\nfor (let i = 0; i < 1000000; i++) {\n  introduce.apply(person1, ['Hi', '!']);\n}\nconsole.timeEnd('apply');\n\nconsole.time('bind');\nconst boundFunc = introduce.bind(person1, 'Hi', '!');\nfor (let i = 0; i < 1000000; i++) {\n  boundFunc();\n}\nconsole.timeEnd('bind');\n// Generally: call ≈ apply > bind (bind creates new function)"
        },
        {
          "type": "interview-tip",
          "tip": "call vs apply vs bind",
          "explanation": "SYNTAX:\n- call(thisArg, arg1, arg2, ...)\n- apply(thisArg, [arg1, arg2, ...])\n- bind(thisArg, arg1, arg2, ...) → returns function\n\nWHEN TO USE:\n- call: Invoke now, few arguments, know them upfront\n- apply: Invoke now, many arguments or have array (now use spread instead)\n- bind: Need function for later (callbacks, event handlers)\n\nMEMORY TIP:\n'A' for Apply = 'A' for Array\n\nMODERN ALTERNATIVES:\n- Spread operator replaces apply: func(...args)\n- Arrow functions replace bind for 'this': () => {}"
        },
        {
          "type": "title",
          "level": 2,
          "content": "Q3. What are closures? Provide practical examples?"
        },
        {
          "type": "description",
          "content": "A closure is a function that has access to variables from its outer (enclosing) scope, even after the outer function has returned. Closures remember the environment in which they were created. Used for data privacy, factory functions, callbacks, and maintaining state."
        },
        {
          "type": "code",
          "language": "javascript",
          "title": "Closures Examples",
          "code": "// Basic closure\nfunction outer() {\n  const message = 'Hello'; // outer scope variable\n  \n  function inner() {\n    console.log(message); // accesses outer variable\n  }\n  \n  return inner;\n}\n\nconst myFunc = outer(); // outer() has finished executing\nmyFunc(); // 'Hello' - still has access to 'message'!\n\n// Practical example 1: Data privacy (private variables)\nfunction createCounter() {\n  let count = 0; // private variable\n  \n  return {\n    increment() {\n      count++;\n      return count;\n    },\n    decrement() {\n      count--;\n      return count;\n    },\n    getCount() {\n      return count;\n    }\n  };\n}\n\nconst counter1 = createCounter();\nconsole.log(counter1.increment()); // 1\nconsole.log(counter1.increment()); // 2\nconsole.log(counter1.getCount()); // 2\nconsole.log(counter1.count); // undefined (private!)\n\nconst counter2 = createCounter(); // separate instance\nconsole.log(counter2.getCount()); // 0 (independent)\n\n// Practical example 2: Function factory\nfunction createMultiplier(multiplier) {\n  return function(number) {\n    return number * multiplier;\n  };\n}\n\nconst double = createMultiplier(2);\nconst triple = createMultiplier(3);\nconst quadruple = createMultiplier(4);\n\nconsole.log(double(5)); // 10\nconsole.log(triple(5)); // 15\nconsole.log(quadruple(5)); // 20\n\n// Practical example 3: Event handlers with private state\nfunction setupButton(buttonId) {\n  let clickCount = 0;\n  \n  const button = document.getElementById(buttonId);\n  button.addEventListener('click', function() {\n    clickCount++;\n    console.log(`Button clicked ${clickCount} times`);\n  });\n}\n\n// Each button maintains its own click count\nsetupButton('btn1');\nsetupButton('btn2');\n\n// Practical example 4: Memoization (caching)\nfunction memoize(fn) {\n  const cache = {}; // closure variable\n  \n  return function(...args) {\n    const key = JSON.stringify(args);\n    if (key in cache) {\n      console.log('Returning cached result');\n      return cache[key];\n    }\n    \n    console.log('Computing result');\n    const result = fn(...args);\n    cache[key] = result;\n    return result;\n  };\n}\n\nfunction slowFunction(n) {\n  // Simulate expensive computation\n  let result = 0;\n  for (let i = 0; i < n * 1000000; i++) {\n    result += i;\n  }\n  return result;\n}\n\nconst memoizedSlow = memoize(slowFunction);\nconsole.log(memoizedSlow(10)); // Computing... (slow)\nconsole.log(memoizedSlow(10)); // Cached! (instant)\n\n// Practical example 5: Module pattern\nconst bankAccount = (function() {\n  let balance = 0; // private\n  const transactions = []; // private\n  \n  return {\n    deposit(amount) {\n      if (amount > 0) {\n        balance += amount;\n        transactions.push({ type: 'deposit', amount, date: new Date() });\n        return balance;\n      }\n    },\n    \n    withdraw(amount) {\n      if (amount > 0 && amount <= balance) {\n        balance -= amount;\n        transactions.push({ type: 'withdraw', amount, date: new Date() });\n        return balance;\n      }\n      return 'Insufficient funds';\n    },\n    \n    getBalance() {\n      return balance;\n    },\n    \n    getTransactions() {\n      return [...transactions]; // return copy, not reference\n    }\n  };\n})(); // IIFE - immediately invoked\n\nbankAccount.deposit(1000);\nbankAccount.withdraw(500);\nconsole.log(bankAccount.getBalance()); // 500\nconsole.log(bankAccount.balance); // undefined (private)\n\n// Common mistake: Closures in loops\n// Wrong way (all buttons log 5)\nfor (var i = 0; i < 5; i++) {\n  setTimeout(function() {\n    console.log(i); // All log 5!\n  }, 1000);\n}\n\n// Solution 1: Use 'let' (block scope)\nfor (let i = 0; i < 5; i++) {\n  setTimeout(function() {\n    console.log(i); // 0, 1, 2, 3, 4\n  }, 1000);\n}\n\n// Solution 2: IIFE to capture value\nfor (var i = 0; i < 5; i++) {\n  (function(j) {\n    setTimeout(function() {\n      console.log(j); // 0, 1, 2, 3, 4\n    }, 1000);\n  })(i);\n}\n\n// Solution 3: bind\nfor (var i = 0; i < 5; i++) {\n  setTimeout(function(i) {\n    console.log(i);\n  }.bind(null, i), 1000);\n}\n\n// Advanced: Closure with multiple levels\nfunction outer1(x) {\n  return function middle(y) {\n    return function inner(z) {\n      return x + y + z;\n    };\n  };\n}\n\nconst step1 = outer1(1);\nconst step2 = step1(2);\nconst result = step2(3);\nconsole.log(result); // 6\n\n// Or in one line\nconsole.log(outer1(1)(2)(3)); // 6\n\n// Memory consideration\nfunction createHeavyClosures() {\n  const hugeArray = new Array(1000000).fill('data');\n  \n  return {\n    // Bad: keeps hugeArray in memory even if not needed\n    getFirst() {\n      return hugeArray[0];\n    },\n    \n    // Better: only keep what you need\n    getFirstOptimized: (function() {\n      const first = hugeArray[0];\n      return function() {\n        return first;\n      };\n    })()\n  };\n}"
        },
        {
          "type": "interview-tip",
          "tip": "Closures Key Concepts",
          "explanation": "WHAT IS A CLOSURE:\nFunction + its lexical environment (outer variables it can access)\n\nUSE CASES:\n1. Data privacy / encapsulation\n2. Factory functions\n3. Callbacks and event handlers\n4. Memoization / caching\n5. Module pattern\n6. Function currying\n\nIMPORTANT:\n- Inner function has access to outer scope even after outer returns\n- Each closure instance has its own scope\n- Be careful with loops (use let, IIFE, or bind)\n- Memory: closures keep referenced variables alive\n\nINTERVIEW QUESTION:\n'What variables does a closure have access to?'\n→ Own variables, outer function variables, global variables"
        },
        {
          "type": "title",
          "level": 2,
          "content": "Q4. What is currying? How to implement it?"
        },
        {
          "type": "description",
          "content": "Currying transforms a function with multiple arguments into a sequence of functions, each taking a single argument. Instead of f(a, b, c), you get f(a)(b)(c). Used for partial application, creating specialized functions, and functional programming patterns."
        },
        {
          "type": "code",
          "language": "javascript",
          "title": "Currying Examples",
          "code": "// Non-curried function\nfunction add(a, b, c) {\n  return a + b + c;\n}\nconsole.log(add(1, 2, 3)); // 6\n\n// Curried version\nfunction curriedAdd(a) {\n  return function(b) {\n    return function(c) {\n      return a + b + c;\n    };\n  };\n}\n\nconsole.log(curriedAdd(1)(2)(3)); // 6\n\n// Arrow function syntax (cleaner)\nconst curriedAddArrow = a => b => c => a + b + c;\nconsole.log(curriedAddArrow(1)(2)(3)); // 6\n\n// Practical use: Partial application\nconst add1 = curriedAdd(1); // fix first arg\nconst add1And2 = add1(2); // fix second arg\nconsole.log(add1And2(3)); // 6\nconsole.log(add1And2(10)); // 13\n\nconst add5 = curriedAdd(5);\nconsole.log(add5(3)(2)); // 10\n\n// Generic curry function - transforms any function\nfunction curry(fn) {\n  return function curried(...args) {\n    if (args.length >= fn.length) {\n      // All arguments provided\n      return fn.apply(this, args);\n    } else {\n      // Return function waiting for more arguments\n      return function(...nextArgs) {\n        return curried.apply(this, [...args, ...nextArgs]);\n      };\n    }\n  };\n}\n\n// Using curry helper\nfunction multiply(a, b, c) {\n  return a * b * c;\n}\n\nconst curriedMultiply = curry(multiply);\n\n// All these work:\nconsole.log(curriedMultiply(2)(3)(4)); // 24\nconsole.log(curriedMultiply(2, 3)(4)); // 24\nconsole.log(curriedMultiply(2)(3, 4)); // 24\nconsole.log(curriedMultiply(2, 3, 4)); // 24\n\n// Practical example 1: API request builder\nconst makeRequest = curry((method, url, data) => {\n  return fetch(url, {\n    method,\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify(data)\n  });\n});\n\nconst get = makeRequest('GET');\nconst post = makeRequest('POST');\nconst put = makeRequest('PUT');\n\n// Specialized functions\nconst getUsersAPI = get('/api/users');\nconst createUserAPI = post('/api/users');\n\n// Usage\ngetUsersAPI(null).then(res => res.json());\ncreateUserAPI({ name: 'Alice' }).then(res => res.json());\n\n// Practical example 2: Validation\nconst validate = curry((regex, message, value) => {\n  return regex.test(value) ? null : message;\n});\n\nconst validateEmail = validate(\n  /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/,\n  'Invalid email'\n);\n\nconst validatePhone = validate(\n  /^\\d{10}$/,\n  'Phone must be 10 digits'\n);\n\nconsole.log(validateEmail('test@example.com')); // null (valid)\nconsole.log(validateEmail('invalid')); // 'Invalid email'\nconsole.log(validatePhone('1234567890')); // null (valid)\nconsole.log(validatePhone('123')); // 'Phone must be 10 digits'\n\n// Practical example 3: Logging with context\nconst log = curry((level, context, message) => {\n  console.log(`[${level}] [${context}] ${message}`);\n});\n\nconst debugLog = log('DEBUG');\nconst infoLog = log('INFO');\nconst errorLog = log('ERROR');\n\nconst dbDebug = debugLog('Database');\nconst apiInfo = infoLog('API');\n\ndbDebug('Connection established');\ndbDebug('Query executed');\napiInfo('Request received');\nerrorLog('Auth')('Invalid token');\n\n// Practical example 4: Discount calculator\nconst calculatePrice = curry((tax, discount, price) => {\n  const afterDiscount = price * (1 - discount);\n  return afterDiscount * (1 + tax);\n});\n\nconst usPrice = calculatePrice(0.08); // 8% tax\nconst euPrice = calculatePrice(0.20); // 20% tax\n\nconst usSale = usPrice(0.10); // 10% discount\nconst usClearance = usPrice(0.50); // 50% discount\n\nconsole.log(usSale(100)); // 100 * 0.9 * 1.08 = 97.2\nconsole.log(usClearance(100)); // 100 * 0.5 * 1.08 = 54\n\n// Advanced: Infinite currying (sum until no args)\nfunction infiniteAdd(a) {\n  let sum = a;\n  \n  function inner(b) {\n    if (b === undefined) {\n      return sum;\n    }\n    sum += b;\n    return inner;\n  }\n  \n  // Allow both call and toString\n  inner.valueOf = () => sum;\n  inner.toString = () => sum.toString();\n  \n  return inner;\n}\n\nconsole.log(infiniteAdd(1)(2)(3)(4)()); // 10\nconsole.log(+infiniteAdd(1)(2)(3)(4)); // 10 (using valueOf)\n\n// Practical example 5: Compose with curry\nconst map = curry((fn, arr) => arr.map(fn));\nconst filter = curry((fn, arr) => arr.filter(fn));\nconst reduce = curry((fn, init, arr) => arr.reduce(fn, init));\n\nconst numbers = [1, 2, 3, 4, 5];\n\nconst double = map(x => x * 2);\nconst onlyEven = filter(x => x % 2 === 0);\nconst sum = reduce((a, b) => a + b, 0);\n\nconsole.log(double(numbers)); // [2, 4, 6, 8, 10]\nconsole.log(onlyEven(numbers)); // [2, 4]\nconsole.log(sum(numbers)); // 15\n\n// Compose functions\nconst doubleEvenSum = arr => sum(onlyEven(double(arr)));\nconsole.log(doubleEvenSum([1, 2, 3, 4, 5])); // 12 (4 + 8)\n\n// Curry vs Partial application\n// Partial: fix some arguments, get function expecting rest\nconst partial = (fn, ...fixedArgs) => {\n  return (...remainingArgs) => {\n    return fn(...fixedArgs, ...remainingArgs);\n  };\n};\n\nfunction greet(greeting, name, punctuation) {\n  return `${greeting}, ${name}${punctuation}`;\n}\n\nconst sayHello = partial(greet, 'Hello'); // fix greeting\nconsole.log(sayHello('Alice', '!')); // 'Hello, Alice!'\nconsole.log(sayHello('Bob', '.')); // 'Hello, Bob.'\n\n// Curried version\nconst curriedGreet = curry(greet);\nconst curriedHello = curriedGreet('Hello');\nconsole.log(curriedHello('Alice')('!')); // 'Hello, Alice!'\n\n// Performance consideration\nfunction normalAdd(a, b, c) {\n  return a + b + c;\n}\n\nconst curriedAddFn = curry(normalAdd);\n\nconsole.time('normal');\nfor (let i = 0; i < 1000000; i++) {\n  normalAdd(1, 2, 3);\n}\nconsole.timeEnd('normal'); // Faster\n\nconsole.time('curried');\nfor (let i = 0; i < 1000000; i++) {\n  curriedAddFn(1)(2)(3);\n}\nconsole.timeEnd('curried'); // Slower (more function calls)"
        },
        {
          "type": "interview-tip",
          "tip": "Currying Key Points",
          "explanation": "DEFINITION:\nTransform f(a, b, c) → f(a)(b)(c)\n\nBENEFITS:\n1. Partial application - create specialized functions\n2. Function reusability\n3. Easier testing (test each step)\n4. Better composition\n5. Cleaner functional programming\n\nIMPLEMENTATION:\n- Manual: nested functions\n- Generic: curry() helper function\n- Arrow syntax: a => b => c => ...\n\nWHEN TO USE:\n- Configuration functions\n- Validation\n- API builders\n- Functional programming patterns\n\nCURRYING vs PARTIAL APPLICATION:\n- Curry: always one arg at a time\n- Partial: fix any number of args"
        },
        {
          "type": "title",
          "level": 2,
          "content": "Q5. What is memoization? Implement a memoize function?"
        },
        {
          "type": "description",
          "content": "Memoization is an optimization technique that caches function results based on inputs. When called with same arguments, returns cached result instead of recomputing. Useful for expensive computations, recursive functions (like Fibonacci), and API calls."
        },
        {
          "type": "code",
          "language": "javascript",
          "title": "Memoization Examples",
          "code": "// Basic memoization implementation\nfunction memoize(fn) {\n  const cache = {};\n  \n  return function(...args) {\n    const key = JSON.stringify(args);\n    \n    if (key in cache) {\n      console.log('Cache hit!');\n      return cache[key];\n    }\n    \n    console.log('Computing...');\n    const result = fn.apply(this, args);\n    cache[key] = result;\n    return result;\n  };\n}\n\n// Example 1: Expensive calculation\nfunction slowSquare(n) {\n  // Simulate expensive operation\n  let result = 0;\n  for (let i = 0; i < 1000000000; i++) {\n    result = n * n;\n  }\n  return result;\n}\n\nconst memoizedSquare = memoize(slowSquare);\n\nconsole.time('first call');\nconsole.log(memoizedSquare(5)); // Computing... 25 (slow)\nconsole.timeEnd('first call');\n\nconsole.time('second call');\nconsole.log(memoizedSquare(5)); // Cache hit! 25 (instant)\nconsole.timeEnd('second call');\n\n// Example 2: Fibonacci (classic use case)\n// Without memoization - exponential time O(2^n)\nfunction fib(n) {\n  if (n <= 1) return n;\n  return fib(n - 1) + fib(n - 2);\n}\n\nconsole.time('fib(40) without memoization');\nconsole.log(fib(40)); // Very slow!\nconsole.timeEnd('fib(40) without memoization');\n\n// With memoization - linear time O(n)\nconst memoizedFib = memoize(function fib(n) {\n  if (n <= 1) return n;\n  return memoizedFib(n - 1) + memoizedFib(n - 2);\n});\n\nconsole.time('fib(40) with memoization');\nconsole.log(memoizedFib(40)); // Fast!\nconsole.timeEnd('fib(40) with memoization');\n\n// Advanced: Memoization with Map (better than object)\nfunction memoizeWithMap(fn) {\n  const cache = new Map();\n  \n  return function(...args) {\n    const key = JSON.stringify(args);\n    \n    if (cache.has(key)) {\n      return cache.get(key);\n    }\n    \n    const result = fn.apply(this, args);\n    cache.set(key, result);\n    return result;\n  };\n}\n\n// Advanced: Memoization with TTL (time-to-live)\nfunction memoizeWithTTL(fn, ttl = 5000) {\n  const cache = new Map();\n  \n  return function(...args) {\n    const key = JSON.stringify(args);\n    const cached = cache.get(key);\n    \n    if (cached && Date.now() - cached.timestamp < ttl) {\n      console.log('Cache hit (within TTL)');\n      return cached.value;\n    }\n    \n    console.log('Computing or cache expired');\n    const result = fn.apply(this, args);\n    cache.set(key, { value: result, timestamp: Date.now() });\n    return result;\n  };\n}\n\nconst apiCall = memoizeWithTTL(function(userId) {\n  return fetch(`/api/users/${userId}`).then(r => r.json());\n}, 60000); // Cache for 1 minute\n\n// Advanced: Memoization with max size (LRU-like)\nfunction memoizeWithMaxSize(fn, maxSize = 100) {\n  const cache = new Map();\n  \n  return function(...args) {\n    const key = JSON.stringify(args);\n    \n    if (cache.has(key)) {\n      const value = cache.get(key);\n      // Move to end (most recently used)\n      cache.delete(key);\n      cache.set(key, value);\n      return value;\n    }\n    \n    const result = fn.apply(this, args);\n    \n    // Remove oldest if at max size\n    if (cache.size >= maxSize) {\n      const firstKey = cache.keys().next().value;\n      cache.delete(firstKey);\n    }\n    \n    cache.set(key, result);\n    return result;\n  };\n}\n\n// Practical example 1: API response caching\nfunction createCachedFetch() {\n  const cache = new Map();\n  \n  return async function cachedFetch(url, options = {}) {\n    const cacheKey = url + JSON.stringify(options);\n    \n    if (cache.has(cacheKey)) {\n      console.log('Returning cached response');\n      return cache.get(cacheKey);\n    }\n    \n    console.log('Fetching from network');\n    const response = await fetch(url, options);\n    const data = await response.json();\n    cache.set(cacheKey, data);\n    return data;\n  };\n}\n\nconst cachedFetch = createCachedFetch();\n\n// First call hits network, subsequent calls use cache\nawait cachedFetch('/api/users');\nawait cachedFetch('/api/users'); // Cached!\n\n// Practical example 2: Memoized factorial\nconst factorial = memoize(function fact(n) {\n  if (n <= 1) return 1;\n  return n * factorial(n - 1);\n});\n\nconsole.log(factorial(5)); // 120 (computes 5, 4, 3, 2, 1)\nconsole.log(factorial(6)); // 720 (only computes 6, rest cached!)\n\n// Practical example 3: Memoized prime checker\nconst isPrime = memoize(function(num) {\n  if (num < 2) return false;\n  for (let i = 2; i <= Math.sqrt(num); i++) {\n    if (num % i === 0) return false;\n  }\n  return true;\n});\n\nconsole.log(isPrime(17)); // Computing... true\nconsole.log(isPrime(17)); // Cache hit! true\n\n// React-style useMemo simulation\nfunction useMemoSimulation(fn, dependencies) {\n  // In real React, this uses internal state\n  // This is just a conceptual example\n  if (!useMemoSimulation.cache) {\n    useMemoSimulation.cache = {};\n  }\n  \n  const key = JSON.stringify(dependencies);\n  \n  if (key in useMemoSimulation.cache) {\n    return useMemoSimulation.cache[key];\n  }\n  \n  const result = fn();\n  useMemoSimulation.cache[key] = result;\n  return result;\n}\n\n// Memoization pitfalls\n\n// Pitfall 1: Mutating cached objects\nconst getUser = memoize(id => ({ id, name: 'User' + id }));\nconst user1 = getUser(1);\nuser1.name = 'Modified'; // Mutates cached object!\nconst user2 = getUser(1); // Returns mutated object\nconsole.log(user2.name); // 'Modified' (unexpected!)\n\n// Solution: Deep clone or return new object\nconst getUserSafe = memoize(id => {\n  return { id, name: 'User' + id };\n});\n// Or use Object.freeze() on cached values\n\n// Pitfall 2: Memory leaks with large cache\nconst memoizedWithLeak = memoize(x => x * 2);\nfor (let i = 0; i < 1000000; i++) {\n  memoizedWithLeak(i); // Cache grows indefinitely!\n}\n\n// Solution: Use memoizeWithMaxSize or WeakMap for objects\n\n// Pitfall 3: Reference types as arguments\nconst memoizedFunc = memoize(obj => obj.value * 2);\nconst obj1 = { value: 5 };\nconst obj2 = { value: 5 };\n\nmemoizedFunc(obj1); // Computing...\nmemoizedFunc(obj2); // Computing... (different object reference!)\n\n// Lodash-style memoize with custom resolver\nfunction memoizeWithResolver(fn, resolver) {\n  const cache = new Map();\n  \n  return function(...args) {\n    const key = resolver ? resolver.apply(this, args) : args[0];\n    \n    if (cache.has(key)) {\n      return cache.get(key);\n    }\n    \n    const result = fn.apply(this, args);\n    cache.set(key, result);\n    return result;\n  };\n}\n\n// Custom key resolver for objects\nconst memoizedObjFunc = memoizeWithResolver(\n  obj => obj.value * 2,\n  obj => obj.value // Use value property as key\n);\n\nmemoizedObjFunc({ value: 5 }); // Computing...\nmemoizedObjFunc({ value: 5 }); // Cache hit! (same value)\n\n// Clear cache utility\nfunction memoizeWithClear(fn) {\n  const cache = new Map();\n  \n  const memoized = function(...args) {\n    const key = JSON.stringify(args);\n    \n    if (cache.has(key)) {\n      return cache.get(key);\n    }\n    \n    const result = fn.apply(this, args);\n    cache.set(key, result);\n    return result;\n  };\n  \n  memoized.clear = () => cache.clear();\n  memoized.delete = (...args) => cache.delete(JSON.stringify(args));\n  memoized.has = (...args) => cache.has(JSON.stringify(args));\n  \n  return memoized;\n}\n\nconst memoizedWithClear = memoizeWithClear(x => x * 2);\nmemoizedWithClear(5); // Computing...\nmemoizedWithClear(5); // Cache hit\nmemoizedWithClear.clear(); // Clear all cache\nmemoizedWithClear(5); // Computing... (cache was cleared)"
        },
        {
          "type": "interview-tip",
          "tip": "Memoization Best Practices",
          "explanation": "WHEN TO USE:\n- Expensive pure functions (same input → same output)\n- Recursive algorithms (Fibonacci, factorial)\n- API calls with same parameters\n- Complex calculations in React components\n\nWHEN NOT TO USE:\n- Functions with side effects\n- Functions that return different values for same input\n- Very cheap computations (overhead not worth it)\n- Infinite possible inputs (memory leak)\n\nCONSIDERATIONS:\n1. Key generation (JSON.stringify limitations)\n2. Memory usage (cache size limits)\n3. Cache invalidation (TTL, max size)\n4. Reference types as arguments\n5. Mutable objects (clone or freeze)\n\nLIBRARIES:\n- lodash.memoize\n- memoizee\n- React.memo, useMemo, useCallback"
        }
      ]
    },
    {
      "id": "section-5",
      "title": "JavaScript - Promises & Async",
      "blocks": [
        {
          "type": "title",
          "level": 2,
          "content": "Q1. Explain Promises and their states? How do they work?"
        },
        {
          "type": "description",
          "content": "A Promise represents the eventual completion or failure of an asynchronous operation. It has three states: Pending (initial), Fulfilled (success), Rejected (failure). Once settled (fulfilled or rejected), a promise cannot change state. Promises provide .then(), .catch(), and .finally() methods for handling results."
        },
        {
          "type": "code",
          "language": "javascript",
          "title": "Promises Examples",
          "code": "// Creating a Promise\nconst promise = new Promise((resolve, reject) => {\n  // Asynchronous operation\n  const success = true;\n  \n  setTimeout(() => {\n    if (success) {\n      resolve('Operation successful!'); // Fulfilled\n    } else {\n      reject('Operation failed!'); // Rejected\n    }\n  }, 1000);\n});\n\n// Consuming a Promise\npromise\n  .then(result => {\n    console.log(result); // 'Operation successful!'\n    return 'Next step';\n  })\n  .then(result => {\n    console.log(result); // 'Next step'\n  })\n  .catch(error => {\n    console.error(error); // Handles rejection\n  })\n  .finally(() => {\n    console.log('Cleanup'); // Always runs\n  });\n\n// Promise states\nconst pending = new Promise(() => {}); // Never resolves\nconst fulfilled = Promise.resolve('Success');\nconst rejected = Promise.reject('Error');\n\nconsole.log(pending); // Promise { <pending> }\nconsole.log(fulfilled); // Promise { 'Success' }\nconsole.log(rejected); // Promise { <rejected> 'Error' }\n\n// Practical example: API call\nfunction fetchUser(userId) {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      if (userId > 0) {\n        resolve({ id: userId, name: `User ${userId}` });\n      } else {\n        reject(new Error('Invalid user ID'));\n      }\n    }, 1000);\n  });\n}\n\nfetchUser(1)\n  .then(user => console.log(user)) // { id: 1, name: 'User 1' }\n  .catch(error => console.error(error.message));\n\n// Chaining promises\nfunction step1() {\n  return Promise.resolve('Step 1 complete');\n}\n\nfunction step2(prevResult) {\n  return new Promise(resolve => {\n    setTimeout(() => resolve(`${prevResult} -> Step 2 complete`), 500);\n  });\n}\n\nfunction step3(prevResult) {\n  return Promise.resolve(`${prevResult} -> Step 3 complete`);\n}\n\nstep1()\n  .then(result1 => step2(result1))\n  .then(result2 => step3(result2))\n  .then(final => console.log(final))\n  // 'Step 1 complete -> Step 2 complete -> Step 3 complete'\n  .catch(error => console.error('Pipeline failed:', error));\n\n// Promise.all - Wait for all promises (parallel)\nconst promise1 = Promise.resolve(1);\nconst promise2 = new Promise(resolve => setTimeout(() => resolve(2), 100));\nconst promise3 = Promise.resolve(3);\n\nPromise.all([promise1, promise2, promise3])\n  .then(results => console.log(results)) // [1, 2, 3]\n  .catch(error => console.error('One failed:', error));\n\n// If any fails, all fails\nPromise.all([\n  Promise.resolve(1),\n  Promise.reject('Error!'),\n  Promise.resolve(3)\n])\n  .then(results => console.log(results)) // Won't run\n  .catch(error => console.error(error)); // 'Error!'\n\n// Promise.allSettled - Wait for all, regardless of outcome (ES2020)\nPromise.allSettled([\n  Promise.resolve(1),\n  Promise.reject('Error!'),\n  Promise.resolve(3)\n])\n  .then(results => console.log(results));\n// [\n//   { status: 'fulfilled', value: 1 },\n//   { status: 'rejected', reason: 'Error!' },\n//   { status: 'fulfilled', value: 3 }\n// ]\n\n// Promise.race - First to settle wins\nPromise.race([\n  new Promise(resolve => setTimeout(() => resolve('slow'), 1000)),\n  new Promise(resolve => setTimeout(() => resolve('fast'), 100))\n])\n  .then(result => console.log(result)); // 'fast'\n\n// Promise.any - First to fulfill wins (ES2021)\nPromise.any([\n  Promise.reject('Error 1'),\n  new Promise(resolve => setTimeout(() => resolve('Success'), 100)),\n  Promise.reject('Error 2')\n])\n  .then(result => console.log(result)) // 'Success'\n  .catch(error => console.error(error)); // AggregateError if all reject\n\n// Error handling: propagation\nPromise.resolve(1)\n  .then(x => {\n    throw new Error('Oops!');\n  })\n  .then(x => console.log('Skipped')) // Skipped!\n  .catch(error => {\n    console.error('Caught:', error.message); // 'Caught: Oops!'\n    return 'Recovered';\n  })\n  .then(x => console.log(x)); // 'Recovered'\n\n// Returning promises from .then()\nfunction getUser(id) {\n  return fetch(`/api/users/${id}`).then(r => r.json());\n}\n\nfunction getPosts(userId) {\n  return fetch(`/api/posts?user=${userId}`).then(r => r.json());\n}\n\ngetUser(1)\n  .then(user => {\n    console.log('User:', user);\n    return getPosts(user.id); // Return promise!\n  })\n  .then(posts => console.log('Posts:', posts))\n  .catch(error => console.error(error));\n\n// vs nested promises (callback hell)\ngetUser(1).then(user => {\n  getPosts(user.id).then(posts => {\n    // Hard to manage!\n  });\n});\n\n// Implementing Promise.all manually\nfunction promiseAll(promises) {\n  return new Promise((resolve, reject) => {\n    if (!Array.isArray(promises)) {\n      return reject(new TypeError('Argument must be an array'));\n    }\n    \n    const results = [];\n    let completed = 0;\n    \n    if (promises.length === 0) {\n      return resolve(results);\n    }\n    \n    promises.forEach((promise, index) => {\n      Promise.resolve(promise)\n        .then(value => {\n          results[index] = value;\n          completed++;\n          \n          if (completed === promises.length) {\n            resolve(results);\n          }\n        })\n        .catch(reject); // Reject on first error\n    });\n  });\n}\n\n// Promise with timeout\nfunction withTimeout(promise, ms) {\n  const timeout = new Promise((_, reject) => {\n    setTimeout(() => reject(new Error('Timeout')), ms);\n  });\n  \n  return Promise.race([promise, timeout]);\n}\n\nconst slowPromise = new Promise(resolve => {\n  setTimeout(() => resolve('Done'), 5000);\n});\n\nwithTimeout(slowPromise, 2000)\n  .then(result => console.log(result))\n  .catch(error => console.error(error.message)); // 'Timeout'\n\n// Retry mechanism\nfunction retry(fn, maxAttempts = 3, delay = 1000) {\n  return new Promise((resolve, reject) => {\n    function attempt(attemptNumber) {\n      fn()\n        .then(resolve)\n        .catch(error => {\n          if (attemptNumber >= maxAttempts) {\n            reject(error);\n          } else {\n            console.log(`Attempt ${attemptNumber} failed, retrying...`);\n            setTimeout(() => attempt(attemptNumber + 1), delay);\n          }\n        });\n    }\n    \n    attempt(1);\n  });\n}\n\nretry(() => fetch('/api/data'), 3, 1000)\n  .then(response => response.json())\n  .catch(error => console.error('All attempts failed'));"
        },
        {
          "type": "interview-tip",
          "tip": "Promises Key Points",
          "explanation": "STATES:\n- Pending → initial state\n- Fulfilled → operation succeeded (resolve())\n- Rejected → operation failed (reject())\n- Once settled, cannot change\n\nMETHODS:\n- .then(onFulfilled, onRejected)\n- .catch(onRejected) - sugar for .then(null, onRejected)\n- .finally(onFinally) - always runs\n\nSTATIC METHODS:\n- Promise.all() - all must succeed, parallel execution\n- Promise.allSettled() - wait for all, get all results\n- Promise.race() - first to settle wins\n- Promise.any() - first to fulfill wins\n- Promise.resolve/reject() - create settled promises\n\nBEST PRACTICES:\n- Always handle errors (.catch)\n- Return promises in .then() for chaining\n- Avoid nesting (use chaining)"
        },
        {
          "type": "title",
          "level": 2,
          "content": "Q2. What is async/await? How is it different from Promises?"
        },
        {
          "type": "description",
          "content": "async/await is syntactic sugar over Promises, making asynchronous code look and behave more like synchronous code. 'async' keyword makes a function return a Promise. 'await' keyword pauses execution until Promise settles. Improves readability and error handling with try/catch."
        },
        {
          "type": "code",
          "language": "javascript",
          "title": "async/await Examples",
          "code": "// Basic async function\nasync function fetchData() {\n  return 'Data'; // Automatically wrapped in Promise.resolve()\n}\n\nfetchData().then(data => console.log(data)); // 'Data'\n\n// async function always returns a Promise\nasync function example() {\n  return 42;\n}\n\nconsole.log(example()); // Promise { 42 }\n\n// await keyword (only works inside async functions)\nasync function getData() {\n  const response = await fetch('/api/data');\n  const data = await response.json();\n  return data;\n}\n\n// Error handling with try/catch\nasync function fetchUserSafe(id) {\n  try {\n    const response = await fetch(`/api/users/${id}`);\n    \n    if (!response.ok) {\n      throw new Error(`HTTP error! status: ${response.status}`);\n    }\n    \n    const user = await response.json();\n    return user;\n  } catch (error) {\n    console.error('Failed to fetch user:', error);\n    throw error; // Re-throw if needed\n  }\n}\n\n// Comparison: Promises vs async/await\n\n// With Promises (chaining)\nfunction getUserPosts_Promise(userId) {\n  return fetch(`/api/users/${userId}`)\n    .then(response => response.json())\n    .then(user => {\n      console.log('User:', user.name);\n      return fetch(`/api/posts?userId=${userId}`);\n    })\n    .then(response => response.json())\n    .then(posts => {\n      console.log('Posts:', posts.length);\n      return posts;\n    })\n    .catch(error => {\n      console.error('Error:', error);\n      throw error;\n    });\n}\n\n// With async/await (cleaner)\nasync function getUserPosts_Async(userId) {\n  try {\n    const userResponse = await fetch(`/api/users/${userId}`);\n    const user = await userResponse.json();\n    console.log('User:', user.name);\n    \n    const postsResponse = await fetch(`/api/posts?userId=${userId}`);\n    const posts = await postsResponse.json();\n    console.log('Posts:', posts.length);\n    \n    return posts;\n  } catch (error) {\n    console.error('Error:', error);\n    throw error;\n  }\n}\n\n// Parallel execution with Promise.all\nasync function fetchMultipleUsers(ids) {\n  // Sequential (slow - one after another)\n  const users1 = [];\n  for (const id of ids) {\n    const user = await fetchUser(id); // Waits for each!\n    users1.push(user);\n  }\n  \n  // Parallel (fast - all at once)\n  const promises = ids.map(id => fetchUser(id));\n  const users2 = await Promise.all(promises);\n  \n  return users2;\n}\n\n// Real-world example: Multiple API calls\nasync function getDashboardData(userId) {\n  try {\n    // Parallel execution\n    const [user, posts, comments, notifications] = await Promise.all([\n      fetch(`/api/users/${userId}`).then(r => r.json()),\n      fetch(`/api/posts?userId=${userId}`).then(r => r.json()),\n      fetch(`/api/comments?userId=${userId}`).then(r => r.json()),\n      fetch(`/api/notifications?userId=${userId}`).then(r => r.json())\n    ]);\n    \n    return { user, posts, comments, notifications };\n  } catch (error) {\n    console.error('Dashboard data fetch failed:', error);\n    throw error;\n  }\n}\n\n// await with Promise.race\nasync function fetchWithTimeout(url, timeout = 5000) {\n  const controller = new AbortController();\n  const timeoutId = setTimeout(() => controller.abort(), timeout);\n  \n  try {\n    const response = await fetch(url, { signal: controller.signal });\n    clearTimeout(timeoutId);\n    return await response.json();\n  } catch (error) {\n    if (error.name === 'AbortError') {\n      throw new Error('Request timeout');\n    }\n    throw error;\n  }\n}\n\n// Top-level await (ES2022, module only)\n// In module files:\n// const data = await fetch('/api/config').then(r => r.json());\n// console.log(data);\n\n// IIFE for top-level await in non-module\n(async () => {\n  const data = await fetch('/api/config').then(r => r.json());\n  console.log(data);\n})();\n\n// Error handling patterns\n\n// Pattern 1: try/catch per operation\nasync function pattern1() {\n  let user, posts;\n  \n  try {\n    user = await fetchUser(1);\n  } catch (error) {\n    console.error('User fetch failed:', error);\n    user = null;\n  }\n  \n  try {\n    posts = await fetchPosts(1);\n  } catch (error) {\n    console.error('Posts fetch failed:', error);\n    posts = [];\n  }\n  \n  return { user, posts };\n}\n\n// Pattern 2: Single try/catch\nasync function pattern2() {\n  try {\n    const user = await fetchUser(1);\n    const posts = await fetchPosts(1);\n    return { user, posts };\n  } catch (error) {\n    console.error('Operation failed:', error);\n    return { user: null, posts: [] };\n  }\n}\n\n// Pattern 3: Promise-style error handling\nasync function pattern3() {\n  const user = await fetchUser(1).catch(err => null);\n  const posts = await fetchPosts(1).catch(err => []);\n  return { user, posts };\n}\n\n// Returning from async function\nasync function returnExample() {\n  return 'value'; // Returns Promise.resolve('value')\n}\n\nasync function returnPromise() {\n  return Promise.resolve('value'); // Same as above (unwrapped)\n}\n\nasync function throwError() {\n  throw new Error('Oops'); // Returns Promise.reject(Error)\n}\n\n// await in loops\n\n// Sequential processing\nasync function processSequential(items) {\n  const results = [];\n  \n  for (const item of items) {\n    const result = await processItem(item); // One at a time\n    results.push(result);\n  }\n  \n  return results;\n}\n\n// Parallel processing\nasync function processParallel(items) {\n  const promises = items.map(item => processItem(item));\n  return await Promise.all(promises); // All at once\n}\n\n// Controlled concurrency\nasync function processBatch(items, batchSize = 3) {\n  const results = [];\n  \n  for (let i = 0; i < items.length; i += batchSize) {\n    const batch = items.slice(i, i + batchSize);\n    const batchResults = await Promise.all(\n      batch.map(item => processItem(item))\n    );\n    results.push(...batchResults);\n  }\n  \n  return results;\n}\n\n// Common mistakes\n\n// Mistake 1: Forgetting await\nasync function mistake1() {\n  const data = fetchData(); // Forgot await! Returns Promise\n  console.log(data); // Promise { <pending> }\n}\n\n// Mistake 2: Using await in non-async function\nfunction mistake2() {\n  const data = await fetchData(); // SyntaxError!\n}\n\n// Mistake 3: Not handling errors\nasync function mistake3() {\n  const data = await fetchData(); // Unhandled rejection if fails!\n  return data;\n}\n\n// Mistake 4: Sequential when could be parallel\nasync function mistake4() {\n  const user = await fetchUser(1); // Wait\n  const posts = await fetchPosts(1); // Wait\n  // Should use Promise.all if independent!\n}\n\n// Correct version\nasync function correct4() {\n  const [user, posts] = await Promise.all([\n    fetchUser(1),\n    fetchPosts(1)\n  ]);\n}\n\n// Advanced: Async iteration\nasync function* asyncGenerator() {\n  yield await Promise.resolve(1);\n  yield await Promise.resolve(2);\n  yield await Promise.resolve(3);\n}\n\n(async () => {\n  for await (const value of asyncGenerator()) {\n    console.log(value); // 1, 2, 3\n  }\n})();\n\n// Practical: Retry with exponential backoff\nasync function retryWithBackoff(fn, maxRetries = 3) {\n  for (let i = 0; i < maxRetries; i++) {\n    try {\n      return await fn();\n    } catch (error) {\n      if (i === maxRetries - 1) throw error;\n      \n      const delay = Math.pow(2, i) * 1000; // 1s, 2s, 4s\n      console.log(`Retry ${i + 1} after ${delay}ms`);\n      await new Promise(resolve => setTimeout(resolve, delay));\n    }\n  }\n}\n\nretryWithBackoff(() => fetch('/api/data'))\n  .then(response => response.json())\n  .catch(error => console.error('All retries failed'));"
        },
        {
          "type": "interview-tip",
          "tip": "async/await vs Promises",
          "explanation": "ASYNC/AWAIT BENEFITS:\n- More readable (looks synchronous)\n- Better error handling (try/catch)\n- Easier debugging (better stack traces)\n- Less nesting\n\nKEY RULES:\n- async function always returns Promise\n- await only works in async functions (or top-level in modules)\n- await pauses execution until Promise settles\n- Thrown errors become rejected Promises\n\nCOMMON PATTERNS:\n- Promise.all() for parallel execution\n- try/catch for error handling\n- .catch() for individual error handling\n\nPERFORMANCE:\n- Use Promise.all() for independent operations\n- Avoid sequential awaits when parallel is possible\n\nWHEN TO USE PROMISES:\n- Complex chaining logic\n- Multiple catch blocks\n- Promise utilities (race, any)"
        },
        {
          "type": "title",
          "level": 2,
          "content": "Q3. What is Promise chaining? How to handle errors in chains?"
        },
        {
          "type": "description",
          "content": "Promise chaining connects multiple asynchronous operations by returning promises from .then() handlers. Each .then() returns a new promise, allowing sequential async operations. Errors propagate down the chain until caught. .catch() handles errors, and .finally() runs regardless of outcome."
        },
        {
          "type": "code",
          "language": "javascript",
          "title": "Promise Chaining Examples",
          "code": "// Basic chaining\nPromise.resolve(1)\n  .then(x => x + 1)      // 2\n  .then(x => x * 2)      // 4\n  .then(x => x - 1)      // 3\n  .then(result => console.log(result)); // 3\n\n// Chaining with async operations\nfetch('/api/user/1')\n  .then(response => {\n    console.log('Got response');\n    return response.json(); // Returns promise!\n  })\n  .then(user => {\n    console.log('User:', user.name);\n    return fetch(`/api/posts?userId=${user.id}`);\n  })\n  .then(response => response.json())\n  .then(posts => {\n    console.log('Posts:', posts.length);\n    return posts;\n  })\n  .catch(error => console.error('Error:', error));\n\n// Error propagation\nPromise.resolve(1)\n  .then(x => {\n    throw new Error('Oops!'); // or return Promise.reject()\n  })\n  .then(x => {\n    console.log('Skipped!'); // Not executed\n    return x + 1;\n  })\n  .then(x => {\n    console.log('Also skipped!'); // Not executed\n    return x * 2;\n  })\n  .catch(error => {\n    console.error('Caught:', error.message); // 'Caught: Oops!'\n    return 'recovered'; // Can recover!\n  })\n  .then(x => {\n    console.log('Continues:', x); // 'Continues: recovered'\n  });\n\n// Multiple catch handlers\nPromise.resolve(1)\n  .then(x => {\n    throw new Error('Error 1');\n  })\n  .catch(error => {\n    console.error('First catch:', error.message);\n    throw new Error('Error 2'); // Re-throw or new error\n  })\n  .catch(error => {\n    console.error('Second catch:', error.message);\n    return 'final';\n  })\n  .then(x => console.log('Final:', x)); // 'Final: final'\n\n// .finally() always runs\nfetch('/api/data')\n  .then(response => response.json())\n  .then(data => processData(data))\n  .catch(error => console.error(error))\n  .finally(() => {\n    console.log('Cleanup'); // Always runs\n    // Good for: hiding spinners, closing connections, etc.\n  });\n\n// Real-world: User authentication flow\nfunction authenticateUser(credentials) {\n  return fetch('/api/login', {\n    method: 'POST',\n    body: JSON.stringify(credentials)\n  })\n    .then(response => {\n      if (!response.ok) {\n        throw new Error('Authentication failed');\n      }\n      return response.json();\n    })\n    .then(data => {\n      localStorage.setItem('token', data.token);\n      return data.user;\n    })\n    .then(user => {\n      return fetch(`/api/users/${user.id}/profile`);\n    })\n    .then(response => response.json())\n    .then(profile => {\n      console.log('Login successful:', profile);\n      return profile;\n    })\n    .catch(error => {\n      console.error('Login failed:', error);\n      localStorage.removeItem('token');\n      throw error;\n    })\n    .finally(() => {\n      console.log('Login attempt completed');\n    });\n}\n\n// Returning values vs promises\nPromise.resolve(1)\n  .then(x => x + 1)           // Returns value → wrapped in Promise.resolve()\n  .then(x => Promise.resolve(x * 2)) // Returns promise → chained directly\n  .then(x => {\n    // Both work the same!\n    console.log(x); // 4\n  });\n\n// Conditional chaining\nfunction processUser(userId, includeStats = false) {\n  let promise = fetch(`/api/users/${userId}`)\n    .then(r => r.json());\n  \n  if (includeStats) {\n    promise = promise\n      .then(user => {\n        return fetch(`/api/stats/${user.id}`);\n      })\n      .then(r => r.json());\n  }\n  \n  return promise;\n}\n\n// Error recovery patterns\n\n// Pattern 1: Default value on error\nfetch('/api/config')\n  .then(r => r.json())\n  .catch(error => {\n    console.warn('Using default config');\n    return { theme: 'light', lang: 'en' }; // Default\n  })\n  .then(config => applyConfig(config));\n\n// Pattern 2: Retry on error\nfunction fetchWithRetry(url, retries = 3) {\n  return fetch(url)\n    .then(r => r.json())\n    .catch(error => {\n      if (retries > 0) {\n        console.log(`Retrying... (${retries} left)`);\n        return fetchWithRetry(url, retries - 1);\n      }\n      throw error; // No more retries\n    });\n}\n\n// Pattern 3: Fallback chain\nfetch('/api/primary')\n  .catch(() => fetch('/api/backup1'))\n  .catch(() => fetch('/api/backup2'))\n  .catch(() => fetch('/api/backup3'))\n  .then(response => response.json())\n  .catch(() => {\n    console.error('All endpoints failed');\n    return null;\n  });\n\n// Advanced: Combining multiple chains\nfunction getFullUserData(userId) {\n  const userPromise = fetch(`/api/users/${userId}`)\n    .then(r => r.json());\n  \n  const postsPromise = userPromise\n    .then(user => fetch(`/api/posts?author=${user.id}`))\n    .then(r => r.json());\n  \n  const commentsPromise = userPromise\n    .then(user => fetch(`/api/comments?author=${user.id}`))\n    .then(r => r.json());\n  \n  return Promise.all([userPromise, postsPromise, commentsPromise])\n    .then(([user, posts, comments]) => ({\n      user,\n      posts,\n      comments\n    }));\n}\n\n// Error handling with Promise.all\nPromise.all([\n  fetch('/api/users').then(r => r.json()),\n  fetch('/api/posts').then(r => r.json()),\n  fetch('/api/comments').then(r => r.json())\n])\n  .then(([users, posts, comments]) => {\n    console.log('All succeeded');\n  })\n  .catch(error => {\n    console.error('At least one failed:', error);\n    // Can't tell which one failed!\n  });\n\n// Better: Individual error handling\nPromise.all([\n  fetch('/api/users').then(r => r.json()).catch(() => []),\n  fetch('/api/posts').then(r => r.json()).catch(() => []),\n  fetch('/api/comments').then(r => r.json()).catch(() => [])\n])\n  .then(([users, posts, comments]) => {\n    console.log('All completed (some may have failed)');\n    console.log({ users, posts, comments });\n  });\n\n// Or use allSettled\nPromise.allSettled([\n  fetch('/api/users').then(r => r.json()),\n  fetch('/api/posts').then(r => r.json()),\n  fetch('/api/comments').then(r => r.json())\n])\n  .then(results => {\n    const users = results[0].status === 'fulfilled' ? results[0].value : [];\n    const posts = results[1].status === 'fulfilled' ? results[1].value : [];\n    const comments = results[2].status === 'fulfilled' ? results[2].value : [];\n    console.log({ users, posts, comments });\n  });\n\n// Chaining with transformation\nfetch('/api/data')\n  .then(response => response.json())\n  .then(data => data.filter(item => item.active))\n  .then(activeItems => activeItems.map(item => item.name))\n  .then(names => names.sort())\n  .then(sortedNames => {\n    console.log('Active names:', sortedNames);\n    return sortedNames;\n  })\n  .catch(error => console.error(error));\n\n// Avoiding callback hell (pyramid of doom)\n\n// Bad: Nested promises\nfetch('/api/user/1')\n  .then(r1 => r1.json())\n  .then(user => {\n    fetch(`/api/posts?userId=${user.id}`)\n      .then(r2 => r2.json())\n      .then(posts => {\n        fetch(`/api/comments?postId=${posts[0].id}`)\n          .then(r3 => r3.json())\n          .then(comments => {\n            console.log(comments); // Deep nesting!\n          });\n      });\n  });\n\n// Good: Flat chain\nlet userId;\nfetch('/api/user/1')\n  .then(r => r.json())\n  .then(user => {\n    userId = user.id;\n    return fetch(`/api/posts?userId=${userId}`);\n  })\n  .then(r => r.json())\n  .then(posts => {\n    return fetch(`/api/comments?postId=${posts[0].id}`);\n  })\n  .then(r => r.json())\n  .then(comments => {\n    console.log(comments); // Flat!\n  })\n  .catch(error => console.error(error));\n\n// Even better: async/await\nasync function betterVersion() {\n  try {\n    const userRes = await fetch('/api/user/1');\n    const user = await userRes.json();\n    \n    const postsRes = await fetch(`/api/posts?userId=${user.id}`);\n    const posts = await postsRes.json();\n    \n    const commentsRes = await fetch(`/api/comments?postId=${posts[0].id}`);\n    const comments = await commentsRes.json();\n    \n    console.log(comments);\n  } catch (error) {\n    console.error(error);\n  }\n}"
        },
        {
          "type": "interview-tip",
          "tip": "Promise Chaining Best Practices",
          "explanation": "KEY CONCEPTS:\n- Each .then() returns new Promise\n- Return value/promise to chain\n- Errors skip to next .catch()\n- .finally() always executes\n\nERROR HANDLING:\n- Single .catch() at end for all errors\n- Multiple .catch() for different error types\n- Return default values in .catch() to recover\n- Use .catch() after individual promises in Promise.all()\n\nCOMMON MISTAKES:\n- Forgetting to return in .then()\n- Nesting promises (use flat chains)\n- Not handling errors\n- Creating unnecessary intermediate variables\n\nWHEN TO CHAIN:\n- Sequential dependencies\n- Data transformation pipelines\n- Multi-step async operations\n\nALTERNATIVES:\n- async/await for better readability\n- Promise.all() for parallel operations"
        },
        {
          "type": "title",
          "level": 2,
          "content": "Q4. What is the microtask queue? How do Promises relate to the event loop?"
        },
        {
          "type": "description",
          "content": "The microtask queue (or job queue) handles Promise callbacks, with higher priority than the regular task queue (macrotask queue). After each macrotask, all microtasks are executed before the next macrotask. Promise .then/.catch/.finally callbacks are microtasks, while setTimeout/setInterval are macrotasks."
        },
        {
          "type": "code",
          "language": "javascript",
          "title": "Microtask Queue Examples",
          "code": "// Event loop priorities: Microtasks > Macrotasks\n\nconsole.log('1: Synchronous');\n\nsetTimeout(() => {\n  console.log('2: Macrotask (setTimeout)');\n}, 0);\n\nPromise.resolve().then(() => {\n  console.log('3: Microtask (Promise)');\n});\n\nconsole.log('4: Synchronous');\n\n// Output:\n// 1: Synchronous\n// 4: Synchronous\n// 3: Microtask (Promise)  ← Runs before setTimeout!\n// 2: Macrotask (setTimeout)\n\n// Microtasks run BEFORE next macrotask\nconsole.log('Start');\n\nsetTimeout(() => console.log('setTimeout 1'), 0);\n\nPromise.resolve()\n  .then(() => console.log('Promise 1'))\n  .then(() => console.log('Promise 2'));\n\nsetTimeout(() => console.log('setTimeout 2'), 0);\n\nPromise.resolve().then(() => console.log('Promise 3'));\n\nconsole.log('End');\n\n// Output:\n// Start\n// End\n// Promise 1\n// Promise 2\n// Promise 3\n// setTimeout 1\n// setTimeout 2\n\n// Microtasks can create more microtasks\nPromise.resolve()\n  .then(() => {\n    console.log('Microtask 1');\n    return Promise.resolve();\n  })\n  .then(() => {\n    console.log('Microtask 2');\n  });\n\nsetTimeout(() => {\n  console.log('Macrotask');\n}, 0);\n\n// Output:\n// Microtask 1\n// Microtask 2\n// Macrotask\n\n// Infinite microtask loop (freezes browser!)\nfunction infiniteMicrotasks() {\n  Promise.resolve().then(() => {\n    console.log('Microtask');\n    infiniteMicrotasks(); // Creates another microtask\n  });\n}\n// infiniteMicrotasks(); // DON'T RUN - will freeze!\n\n// Event loop phases:\n// 1. Execute synchronous code\n// 2. Execute ALL microtasks\n// 3. Execute ONE macrotask\n// 4. Execute ALL microtasks (created by that macrotask)\n// 5. Render (if needed)\n// 6. Repeat from step 3\n\n// Microtasks vs Macrotasks\n\n// Macrotasks:\n// - setTimeout, setInterval\n// - setImmediate (Node.js)\n// - I/O operations\n// - UI rendering\n// - requestAnimationFrame (browser)\n\n// Microtasks:\n// - Promise.then/catch/finally\n// - queueMicrotask()\n// - MutationObserver (browser)\n// - process.nextTick (Node.js - even higher priority!)\n\n// Demonstration with all types\nconsole.log('Script start');\n\nsetTimeout(() => {\n  console.log('setTimeout');\n}, 0);\n\nPromise.resolve()\n  .then(() => {\n    console.log('Promise 1');\n  })\n  .then(() => {\n    console.log('Promise 2');\n  });\n\nqueueMicrotask(() => {\n  console.log('queueMicrotask');\n});\n\nconsole.log('Script end');\n\n// Output:\n// Script start\n// Script end\n// Promise 1\n// queueMicrotask\n// Promise 2\n// setTimeout\n\n// Complex example\nconsole.log('1');\n\nsetTimeout(() => console.log('2'), 0);\n\nPromise.resolve()\n  .then(() => console.log('3'))\n  .then(() => {\n    console.log('4');\n    setTimeout(() => console.log('5'), 0);\n  });\n\nsetTimeout(() => {\n  console.log('6');\n  Promise.resolve().then(() => console.log('7'));\n}, 0);\n\nPromise.resolve().then(() => console.log('8'));\n\nconsole.log('9');\n\n// Output:\n// 1, 9 (synchronous)\n// 3, 4, 8 (all microtasks)\n// 2 (first macrotask)\n// 6 (second macrotask)\n// 7 (microtask from macrotask 6)\n// 5 (third macrotask, queued from microtask 4)\n\n// Async/await and microtasks\nasync function example() {\n  console.log('1');\n  \n  await Promise.resolve();\n  // Everything after 'await' is like .then()\n  \n  console.log('2'); // This is a microtask\n}\n\nconsole.log('3');\nexample();\nconsole.log('4');\n\n// Output:\n// 3\n// 1\n// 4\n// 2 (microtask)\n\n// Equivalent to:\nfunction exampleWithPromise() {\n  console.log('1');\n  \n  Promise.resolve().then(() => {\n    console.log('2');\n  });\n}\n\n// Race conditions due to microtask timing\nlet data = { value: 0 };\n\nPromise.resolve().then(() => {\n  data.value = 1; // Runs before setTimeout\n});\n\nsetTimeout(() => {\n  console.log(data.value); // 1 (promise ran first)\n}, 0);\n\n// Practical: Batching updates\nclass StateManager {\n  constructor() {\n    this.state = {};\n    this.listeners = [];\n    this.pending = false;\n  }\n  \n  setState(updates) {\n    Object.assign(this.state, updates);\n    \n    if (!this.pending) {\n      this.pending = true;\n      // Use microtask to batch multiple setState calls\n      queueMicrotask(() => {\n        this.notifyListeners();\n        this.pending = false;\n      });\n    }\n  }\n  \n  notifyListeners() {\n    this.listeners.forEach(listener => listener(this.state));\n  }\n  \n  subscribe(listener) {\n    this.listeners.push(listener);\n  }\n}\n\nconst store = new StateManager();\nstore.subscribe(state => console.log('State:', state));\n\nstore.setState({ a: 1 });\nstore.setState({ b: 2 });\nstore.setState({ c: 3 });\n// Only triggers ONE notification (batched)!\n\n// Node.js: process.nextTick (runs BEFORE microtasks!)\n// In Node.js:\nprocess.nextTick(() => console.log('nextTick'));\nPromise.resolve().then(() => console.log('Promise'));\nsetTimeout(() => console.log('setTimeout'), 0);\n// Output: nextTick, Promise, setTimeout\n\n// Browser: MutationObserver (microtask)\nconst observer = new MutationObserver(() => {\n  console.log('DOM changed (microtask)');\n});\n\nconst element = document.createElement('div');\nobserver.observe(element, { attributes: true });\n\nelement.setAttribute('data-test', '1');\nconsole.log('After setAttribute');\n\n// Output:\n// After setAttribute\n// DOM changed (microtask)\n\n// Debugging event loop\nfunction logWithType(message, type) {\n  console.log(`[${type}] ${message}`);\n}\n\nlogWithType('Start', 'sync');\n\nsetTimeout(() => logWithType('Timeout 1', 'macro'), 0);\n\nPromise.resolve()\n  .then(() => logWithType('Promise 1', 'micro'))\n  .then(() => {\n    logWithType('Promise 2', 'micro');\n    setTimeout(() => logWithType('Timeout 2', 'macro'), 0);\n  });\n\nqueueMicrotask(() => logWithType('queueMicrotask', 'micro'));\n\nsetTimeout(() => {\n  logWithType('Timeout 3', 'macro');\n  Promise.resolve().then(() => logWithType('Promise 3', 'micro'));\n}, 0);\n\nlogWithType('End', 'sync');\n\n// Visualizing the queue\nfunction visualizeEventLoop() {\n  const events = [];\n  \n  const log = (msg, type) => {\n    events.push({ msg, type, time: performance.now() });\n  };\n  \n  log('Start', 'sync');\n  \n  setTimeout(() => log('Macro 1', 'macro'), 0);\n  Promise.resolve().then(() => log('Micro 1', 'micro'));\n  Promise.resolve().then(() => log('Micro 2', 'micro'));\n  setTimeout(() => log('Macro 2', 'macro'), 0);\n  \n  log('End', 'sync');\n  \n  setTimeout(() => {\n    console.table(events);\n  }, 100);\n}"
        },
        {
          "type": "interview-tip",
          "tip": "Microtask Queue Key Points",
          "explanation": "EVENT LOOP ORDER:\n1. Execute synchronous code\n2. Execute ALL microtasks\n3. Execute ONE macrotask\n4. Execute ALL microtasks (from step 3)\n5. Render (if needed)\n6. Repeat from step 3\n\nMICROTASKS (high priority):\n- Promise.then/catch/finally\n- queueMicrotask()\n- MutationObserver\n- process.nextTick (Node.js)\n\nMACROTASKS (lower priority):\n- setTimeout/setInterval\n- setImmediate (Node.js)\n- I/O operations\n- UI events\n\nKEY INSIGHT:\nALL microtasks run before NEXT macrotask\n\nPRACTICAL:\n- Promises execute faster than setTimeout\n- Can cause UI freezes if too many microtasks\n- Use for batching updates\n- Understand for debugging async code"
        }
      ]
    },
    {
      "id": "section-6",
      "title": "JavaScript - Classes & OOP",
      "blocks": [
        {
          "type": "title",
          "level": 2,
          "content": "Q1. What are JavaScript classes? How do they compare to constructor functions?"
        },
        {
          "type": "description",
          "content": "Classes are syntactic sugar over JavaScript's prototype-based inheritance (ES6+). They provide a cleaner syntax for creating objects and implementing inheritance. Classes use the 'class' keyword, have constructor methods, and support inheritance via 'extends'. Under the hood, they still use prototypes."
        },
        {
          "type": "code",
          "language": "javascript",
          "title": "Classes vs Constructor Functions",
          "code": "// Constructor Function (ES5)\nfunction PersonConstructor(name, age) {\n  this.name = name;\n  this.age = age;\n}\n\nPersonConstructor.prototype.greet = function() {\n  return `Hi, I'm ${this.name}`;\n};\n\nconst person1 = new PersonConstructor('Alice', 25);\nconsole.log(person1.greet()); // 'Hi, I'm Alice'\n\n// Class (ES6+)\nclass PersonClass {\n  constructor(name, age) {\n    this.name = name;\n    this.age = age;\n  }\n  \n  greet() {\n    return `Hi, I'm ${this.name}`;\n  }\n}\n\nconst person2 = new PersonClass('Bob', 30);\nconsole.log(person2.greet()); // 'Hi, I'm Bob'\n\n// Both produce similar objects\nconsole.log(typeof PersonConstructor); // 'function'\nconsole.log(typeof PersonClass); // 'function'\nconsole.log(person1 instanceof PersonConstructor); // true\nconsole.log(person2 instanceof PersonClass); // true\n\n// Key difference: Classes must be called with 'new'\n// PersonClass(); // TypeError: Class constructor cannot be invoked without 'new'\nPersonConstructor(); // Works (but creates global variables - bad!)\n\n// Static methods\nclass MathHelper {\n  static PI = 3.14159;\n  \n  static square(n) {\n    return n * n;\n  }\n  \n  static cube(n) {\n    return n * n * n;\n  }\n}\n\nconsole.log(MathHelper.square(5)); // 25\nconsole.log(MathHelper.PI); // 3.14159\n\n// Can't call static methods on instances\nconst helper = new MathHelper();\n// helper.square(5); // TypeError\n\n// Getters and setters\nclass User {\n  constructor(firstName, lastName) {\n    this.firstName = firstName;\n    this.lastName = lastName;\n  }\n  \n  get fullName() {\n    return `${this.firstName} ${this.lastName}`;\n  }\n  \n  set fullName(name) {\n    const parts = name.split(' ');\n    this.firstName = parts[0];\n    this.lastName = parts[1];\n  }\n  \n  get initials() {\n    return `${this.firstName[0]}${this.lastName[0]}`;\n  }\n}\n\nconst user = new User('John', 'Doe');\nconsole.log(user.fullName); // 'John Doe' (no parentheses!)\nuser.fullName = 'Jane Smith';\nconsole.log(user.firstName); // 'Jane'\nconsole.log(user.initials); // 'JS'\n\n// Inheritance with extends\nclass Animal {\n  constructor(name) {\n    this.name = name;\n  }\n  \n  speak() {\n    return `${this.name} makes a sound`;\n  }\n}\n\nclass Dog extends Animal {\n  constructor(name, breed) {\n    super(name); // Must call super() first!\n    this.breed = breed;\n  }\n  \n  speak() {\n    return `${this.name} barks`;\n  }\n  \n  wagTail() {\n    return `${this.name} wags tail`;\n  }\n}\n\nconst dog = new Dog('Rex', 'German Shepherd');\nconsole.log(dog.speak()); // 'Rex barks'\nconsole.log(dog.wagTail()); // 'Rex wags tail'\nconsole.log(dog instanceof Dog); // true\nconsole.log(dog instanceof Animal); // true\n\n// Super to call parent methods\nclass Cat extends Animal {\n  speak() {\n    const parentSound = super.speak();\n    return `${parentSound}, meow!`;\n  }\n}\n\nconst cat = new Cat('Whiskers');\nconsole.log(cat.speak()); // 'Whiskers makes a sound, meow!'\n\n// Private fields (ES2022)\nclass BankAccount {\n  #balance = 0; // Private field (must be declared)\n  \n  deposit(amount) {\n    if (amount > 0) {\n      this.#balance += amount;\n    }\n  }\n  \n  withdraw(amount) {\n    if (amount > 0 && amount <= this.#balance) {\n      this.#balance -= amount;\n      return amount;\n    }\n    return 0;\n  }\n  \n  getBalance() {\n    return this.#balance;\n  }\n  \n  #auditLog(action) { // Private method\n    console.log(`Audit: ${action}`);\n  }\n}\n\nconst account = new BankAccount();\naccount.deposit(1000);\nconsole.log(account.getBalance()); // 1000\n// console.log(account.#balance); // SyntaxError: Private field\n\n// Public class fields (ES2022)\nclass Counter {\n  count = 0; // Public field (no need for constructor)\n  \n  increment() {\n    this.count++;\n  }\n}\n\nconst counter = new Counter();\ncounter.increment();\nconsole.log(counter.count); // 1\n\n// Arrow methods (automatically bound)\nclass Button {\n  label = 'Click me';\n  clicks = 0;\n  \n  // Regular method (this depends on how it's called)\n  handleClickRegular() {\n    this.clicks++;\n  }\n  \n  // Arrow function (this always refers to instance)\n  handleClickArrow = () => {\n    this.clicks++;\n  }\n}\n\nconst btn = new Button();\nconst regularHandler = btn.handleClickRegular;\nconst arrowHandler = btn.handleClickArrow;\n\n// regularHandler(); // Error: this is undefined\narrowHandler(); // Works! Arrow function preserves 'this'\n\n// Abstract pattern (no native abstract classes)\nclass Shape {\n  constructor() {\n    if (new.target === Shape) {\n      throw new Error('Cannot instantiate abstract class');\n    }\n  }\n  \n  area() {\n    throw new Error('Must implement area()');\n  }\n}\n\nclass Circle extends Shape {\n  constructor(radius) {\n    super();\n    this.radius = radius;\n  }\n  \n  area() {\n    return Math.PI * this.radius ** 2;\n  }\n}\n\n// const shape = new Shape(); // Error: Cannot instantiate abstract class\nconst circle = new Circle(5);\nconsole.log(circle.area()); // 78.53981633974483\n\n// Mixins (multiple inheritance pattern)\nconst Flyable = {\n  fly() {\n    return `${this.name} is flying`;\n  }\n};\n\nconst Swimmable = {\n  swim() {\n    return `${this.name} is swimming`;\n  }\n};\n\nclass Duck extends Animal {\n  // Duck can fly and swim\n}\n\nObject.assign(Duck.prototype, Flyable, Swimmable);\n\nconst duck = new Duck('Donald');\nconsole.log(duck.fly()); // 'Donald is flying'\nconsole.log(duck.swim()); // 'Donald is swimming'\n\n// Complex example: Observable pattern\nclass Observable {\n  #observers = [];\n  \n  subscribe(observer) {\n    this.#observers.push(observer);\n    return () => this.unsubscribe(observer); // Return unsubscribe function\n  }\n  \n  unsubscribe(observer) {\n    this.#observers = this.#observers.filter(obs => obs !== observer);\n  }\n  \n  notify(data) {\n    this.#observers.forEach(observer => observer(data));\n  }\n}\n\nclass Store extends Observable {\n  #state = {};\n  \n  getState() {\n    return { ...this.#state };\n  }\n  \n  setState(updates) {\n    this.#state = { ...this.#state, ...updates };\n    this.notify(this.#state);\n  }\n}\n\nconst store = new Store();\n\nconst unsubscribe = store.subscribe(state => {\n  console.log('State updated:', state);\n});\n\nstore.setState({ count: 1 }); // Logs: State updated: { count: 1 }\nstore.setState({ count: 2 }); // Logs: State updated: { count: 2 }\nunsubscribe();\nstore.setState({ count: 3 }); // No log (unsubscribed)"
        },
        {
          "type": "interview-tip",
          "tip": "Classes Key Points",
          "explanation": "CLASSES vs CONSTRUCTOR FUNCTIONS:\n- Classes are syntactic sugar over prototypes\n- Classes must use 'new' keyword\n- Class methods are non-enumerable\n- Classes have 'use strict' by default\n- Constructor functions are hoisted, classes are not\n\nKEY FEATURES:\n- constructor() method for initialization\n- Methods (prototype methods)\n- Static methods/fields (class-level)\n- Getters/setters (computed properties)\n- extends for inheritance\n- super() to call parent\n- Private fields (#field) - ES2022\n- Public fields - ES2022\n\nBEST PRACTICES:\n- Use classes for clear OOP patterns\n- Private fields for encapsulation\n- Arrow methods for event handlers\n- super() first in child constructor\n- Prefer composition over inheritance"
        },
        {
          "type": "title",
          "level": 2,
          "content": "Q2. Explain prototypal inheritance in JavaScript?"
        },
        {
          "type": "description",
          "content": "JavaScript uses prototypal inheritance where objects inherit from other objects. Every object has an internal [[Prototype]] link (accessed via __proto__ or Object.getPrototypeOf()) to another object. When accessing a property, JavaScript searches up the prototype chain until found or reaching null."
        },
        {
          "type": "code",
          "language": "javascript",
          "title": "Prototypal Inheritance Examples",
          "code": "// Every object has a prototype\nconst obj = { name: 'Test' };\nconsole.log(Object.getPrototypeOf(obj) === Object.prototype); // true\n\n// Prototype chain\nconst animal = {\n  eats: true,\n  walk() {\n    console.log('Animal walks');\n  }\n};\n\nconst rabbit = {\n  jumps: true,\n  __proto__: animal // Set prototype (not recommended in production)\n};\n\nconsole.log(rabbit.eats); // true (inherited from animal)\nconsole.log(rabbit.jumps); // true (own property)\nrabbit.walk(); // 'Animal walks' (inherited method)\n\n// Property lookup: own properties first, then prototype chain\nconst longEar = {\n  earLength: 10,\n  __proto__: rabbit\n};\n\nconsole.log(longEar.jumps); // true (from rabbit)\nconsole.log(longEar.eats); // true (from animal, up the chain)\nconsole.log(longEar.earLength); // 10 (own property)\n\n// Better way: Object.create()\nconst animal2 = {\n  eats: true,\n  walk() {\n    console.log('Walking');\n  }\n};\n\nconst rabbit2 = Object.create(animal2);\nrabbit2.jumps = true;\n\nconsole.log(rabbit2.eats); // true (inherited)\nconsole.log(Object.getPrototypeOf(rabbit2) === animal2); // true\n\n// Constructor function and prototype\nfunction Person(name) {\n  this.name = name;\n}\n\nPerson.prototype.greet = function() {\n  return `Hi, I'm ${this.name}`;\n};\n\nconst alice = new Person('Alice');\nconst bob = new Person('Bob');\n\nconsole.log(alice.greet()); // 'Hi, I'm Alice'\nconsole.log(bob.greet()); // 'Hi, I'm Bob'\n\n// Both instances share the same prototype\nconsole.log(alice.greet === bob.greet); // true (same function)\n\n// Prototype chain with constructor\nconsole.log(alice.__proto__ === Person.prototype); // true\nconsole.log(Person.prototype.__proto__ === Object.prototype); // true\nconsole.log(Object.prototype.__proto__); // null (end of chain)\n\n// Own vs inherited properties\nfunction Car(brand) {\n  this.brand = brand; // Own property\n}\n\nCar.prototype.wheels = 4; // Inherited property\n\nconst car = new Car('Toyota');\n\nconsole.log(car.hasOwnProperty('brand')); // true\nconsole.log(car.hasOwnProperty('wheels')); // false (inherited)\nconsole.log('wheels' in car); // true (checks entire chain)\n\n// Modifying prototype affects all instances\nconst car1 = new Car('Honda');\nconst car2 = new Car('Ford');\n\nCar.prototype.type = 'vehicle';\n\nconsole.log(car1.type); // 'vehicle'\nconsole.log(car2.type); // 'vehicle'\n\n// But own properties shadow prototype properties\ncar1.wheels = 6; // Own property\nconsole.log(car1.wheels); // 6 (own property)\nconsole.log(car2.wheels); // 4 (from prototype)\n\ndelete car1.wheels; // Remove own property\nconsole.log(car1.wheels); // 4 (now uses prototype)\n\n// Inheritance with constructor functions\nfunction Animal(name) {\n  this.name = name;\n}\n\nAnimal.prototype.eat = function() {\n  return `${this.name} is eating`;\n};\n\nfunction Dog(name, breed) {\n  Animal.call(this, name); // Call parent constructor\n  this.breed = breed;\n}\n\n// Set up inheritance\nDog.prototype = Object.create(Animal.prototype);\nDog.prototype.constructor = Dog; // Fix constructor reference\n\nDog.prototype.bark = function() {\n  return `${this.name} barks`;\n};\n\nconst dog = new Dog('Rex', 'Labrador');\nconsole.log(dog.eat()); // 'Rex is eating' (from Animal)\nconsole.log(dog.bark()); // 'Rex barks' (from Dog)\nconsole.log(dog instanceof Dog); // true\nconsole.log(dog instanceof Animal); // true\n\n// Prototype chain visualization\nfunction showPrototypeChain(obj) {\n  let current = obj;\n  let level = 0;\n  \n  while (current !== null) {\n    console.log('  '.repeat(level) + (current.constructor?.name || 'Object'));\n    current = Object.getPrototypeOf(current);\n    level++;\n  }\n  console.log('  '.repeat(level) + 'null');\n}\n\nshowPrototypeChain(dog);\n// Dog\n//   Animal\n//     Object\n//       null\n\n// Object.create() with properties\nconst vehicle = {\n  type: 'vehicle',\n  start() {\n    console.log('Starting...');\n  }\n};\n\nconst bike = Object.create(vehicle, {\n  wheels: {\n    value: 2,\n    writable: true,\n    enumerable: true,\n    configurable: true\n  },\n  brand: {\n    value: 'Yamaha',\n    writable: true,\n    enumerable: true\n  }\n});\n\nconsole.log(bike.wheels); // 2\nconsole.log(bike.type); // 'vehicle' (inherited)\nbike.start(); // 'Starting...'\n\n// Object.setPrototypeOf() (slower than Object.create)\nconst obj1 = { a: 1 };\nconst obj2 = { b: 2 };\n\nObject.setPrototypeOf(obj1, obj2);\nconsole.log(obj1.b); // 2 (inherited from obj2)\n\n// Checking prototype relationship\nconsole.log(Object.prototype.isPrototypeOf(obj1)); // true\nconsole.log(obj2.isPrototypeOf(obj1)); // true\n\n// Pure prototypal inheritance (no constructors)\nconst personPrototype = {\n  greet() {\n    return `Hello, I'm ${this.name}`;\n  }\n};\n\nfunction createPerson(name, age) {\n  const person = Object.create(personPrototype);\n  person.name = name;\n  person.age = age;\n  return person;\n}\n\nconst person1 = createPerson('Alice', 25);\nconst person2 = createPerson('Bob', 30);\n\nconsole.log(person1.greet()); // 'Hello, I'm Alice'\nconsole.log(person2.greet()); // 'Hello, I'm Bob'\n\n// Prototype pollution (security issue)\nconst obj3 = JSON.parse('{\"__proto__\": {\"isAdmin\": true}}');\n// This can pollute Object.prototype!\n\n// Safe version\nconst obj4 = Object.create(null); // No prototype\nobj4.name = 'Safe';\nconsole.log(obj4.__proto__); // undefined (no prototype chain)\n\n// Enumeration and prototype\nfunction MyClass() {\n  this.ownProp = 1;\n}\nMyClass.prototype.inheritedProp = 2;\n\nconst instance = new MyClass();\n\n// for...in iterates over enumerable properties (own + inherited)\nfor (let key in instance) {\n  console.log(key); // 'ownProp', 'inheritedProp'\n}\n\n// Object.keys() only own properties\nconsole.log(Object.keys(instance)); // ['ownProp']\n\n// Get only own enumerable properties\nfor (let key in instance) {\n  if (instance.hasOwnProperty(key)) {\n    console.log(key); // 'ownProp' only\n  }\n}\n\n// Modern classes still use prototypes\nclass Modern {\n  constructor() {\n    this.own = 1;\n  }\n  \n  method() {\n    return 'method';\n  }\n}\n\nconst modern = new Modern();\nconsole.log(modern.own); // 1 (own property)\nconsole.log(modern.method); // 'method' (from prototype)\nconsole.log(modern.hasOwnProperty('method')); // false\nconsole.log(Modern.prototype.hasOwnProperty('method')); // true"
        },
        {
          "type": "interview-tip",
          "tip": "Prototypal Inheritance Key Points",
          "explanation": "PROTOTYPE CHAIN:\n- Every object has [[Prototype]] (internal link)\n- Access via Object.getPrototypeOf() or __proto__ (deprecated)\n- Chain ends at Object.prototype → null\n- Property lookup: object → prototype → prototype → ... → null\n\nCREATING INHERITANCE:\n- Object.create(proto) - best way\n- Constructor.prototype = Object.create(Parent.prototype)\n- Class extends (modern, preferred)\n\nKEY METHODS:\n- Object.getPrototypeOf(obj)\n- Object.setPrototypeOf(obj, proto) - slow!\n- obj.hasOwnProperty(prop)\n- proto.isPrototypeOf(obj)\n\nCOMMON PATTERNS:\n- Constructor functions + prototype\n- Object.create() for delegation\n- Factory functions\n- ES6 classes (still uses prototypes)\n\nBEST PRACTICES:\n- Prefer Object.create() over __proto__\n- Use classes for clarity\n- Check hasOwnProperty() when iterating\n- Object.create(null) for dictionaries"
        },
        {
          "type": "title",
          "level": 2,
          "content": "Q3. What are static methods? When to use them?"
        },
        {
          "type": "description",
          "content": "Static methods belong to the class itself, not instances. Called on the class directly (ClassName.method()), not on objects. Used for utility functions, factory methods, or operations that don't require instance data. Cannot access instance properties (no 'this')."
        },
        {
          "type": "code",
          "language": "javascript",
          "title": "Static Methods Examples",
          "code": "// Basic static method\nclass Calculator {\n  static add(a, b) {\n    return a + b;\n  }\n  \n  static multiply(a, b) {\n    return a * b;\n  }\n}\n\n// Call on class, not instance\nconsole.log(Calculator.add(5, 3)); // 8\nconsole.log(Calculator.multiply(4, 2)); // 8\n\n// Can't call on instance\nconst calc = new Calculator();\n// calc.add(5, 3); // TypeError: calc.add is not a function\n\n// Static properties (ES2022)\nclass Config {\n  static API_URL = 'https://api.example.com';\n  static TIMEOUT = 5000;\n  static VERSION = '1.0.0';\n}\n\nconsole.log(Config.API_URL); // 'https://api.example.com'\n\n// Use case 1: Factory methods\nclass User {\n  constructor(name, email, role) {\n    this.name = name;\n    this.email = email;\n    this.role = role;\n  }\n  \n  static createAdmin(name, email) {\n    return new User(name, email, 'admin');\n  }\n  \n  static createGuest(name) {\n    return new User(name, 'guest@example.com', 'guest');\n  }\n  \n  static fromJSON(json) {\n    const data = JSON.parse(json);\n    return new User(data.name, data.email, data.role);\n  }\n}\n\nconst admin = User.createAdmin('Alice', 'alice@example.com');\nconst guest = User.createGuest('Bob');\nconst fromJson = User.fromJSON('{\"name\":\"Charlie\",\"email\":\"charlie@example.com\",\"role\":\"user\"}');\n\nconsole.log(admin); // User { name: 'Alice', email: 'alice@example.com', role: 'admin' }\n\n// Use case 2: Validation utilities\nclass Validator {\n  static isEmail(str) {\n    return /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/.test(str);\n  }\n  \n  static isPhone(str) {\n    return /^\\d{10}$/.test(str);\n  }\n  \n  static isURL(str) {\n    try {\n      new URL(str);\n      return true;\n    } catch {\n      return false;\n    }\n  }\n}\n\nconsole.log(Validator.isEmail('test@example.com')); // true\nconsole.log(Validator.isPhone('1234567890')); // true\n\n// Use case 3: Counter/singleton pattern\nclass IDGenerator {\n  static #currentId = 0;\n  \n  static generate() {\n    return ++this.#currentId;\n  }\n  \n  static reset() {\n    this.#currentId = 0;\n  }\n  \n  static getCurrent() {\n    return this.#currentId;\n  }\n}\n\nconsole.log(IDGenerator.generate()); // 1\nconsole.log(IDGenerator.generate()); // 2\nconsole.log(IDGenerator.generate()); // 3\nconsole.log(IDGenerator.getCurrent()); // 3\nIDGenerator.reset();\nconsole.log(IDGenerator.generate()); // 1\n\n// Use case 4: Comparison/sorting\nclass Person {\n  constructor(name, age) {\n    this.name = name;\n    this.age = age;\n  }\n  \n  static compareByAge(a, b) {\n    return a.age - b.age;\n  }\n  \n  static compareByName(a, b) {\n    return a.name.localeCompare(b.name);\n  }\n}\n\nconst people = [\n  new Person('Charlie', 25),\n  new Person('Alice', 30),\n  new Person('Bob', 20)\n];\n\npeople.sort(Person.compareByAge);\nconsole.log(people.map(p => p.name)); // ['Bob', 'Charlie', 'Alice']\n\npeople.sort(Person.compareByName);\nconsole.log(people.map(p => p.name)); // ['Alice', 'Bob', 'Charlie']\n\n// Static this refers to the class\nclass Animal {\n  static className = 'Animal';\n  \n  static getClassName() {\n    return this.className; // 'this' is the class\n  }\n  \n  static create(name) {\n    return new this(name); // 'this' is the class\n  }\n}\n\nclass Dog extends Animal {\n  static className = 'Dog';\n  \n  constructor(name) {\n    super();\n    this.name = name;\n  }\n}\n\nconsole.log(Animal.getClassName()); // 'Animal'\nconsole.log(Dog.getClassName()); // 'Dog' (inherited, uses Dog's className)\n\nconst dog = Dog.create('Rex');\nconsole.log(dog instanceof Dog); // true\n\n// Static inheritance\nclass Parent {\n  static parentMethod() {\n    return 'parent';\n  }\n}\n\nclass Child extends Parent {\n  static childMethod() {\n    return 'child';\n  }\n  \n  static combinedMethod() {\n    return super.parentMethod() + ' + child';\n  }\n}\n\nconsole.log(Child.parentMethod()); // 'parent' (inherited)\nconsole.log(Child.childMethod()); // 'child'\nconsole.log(Child.combinedMethod()); // 'parent + child'\n\n// Real-world: Database model\nclass Model {\n  static tableName = '';\n  static #cache = new Map();\n  \n  static async find(id) {\n    if (this.#cache.has(id)) {\n      return this.#cache.get(id);\n    }\n    \n    const data = await fetch(`/api/${this.tableName}/${id}`)\n      .then(r => r.json());\n    \n    const instance = new this(data);\n    this.#cache.set(id, instance);\n    return instance;\n  }\n  \n  static async findAll() {\n    const data = await fetch(`/api/${this.tableName}`)\n      .then(r => r.json());\n    return data.map(item => new this(item));\n  }\n  \n  static clearCache() {\n    this.#cache.clear();\n  }\n}\n\nclass UserModel extends Model {\n  static tableName = 'users';\n  \n  constructor(data) {\n    super();\n    Object.assign(this, data);\n  }\n}\n\n// Usage\nconst user = await UserModel.find(1);\nconst allUsers = await UserModel.findAll();\n\n// Built-in examples\nconsole.log(Array.isArray([1, 2, 3])); // true (static method)\nconsole.log(Object.keys({ a: 1 })); // ['a'] (static method)\nconsole.log(Math.max(1, 2, 3)); // 3 (static method)\nconsole.log(Number.parseInt('42')); // 42 (static method)\n\n// Static vs instance methods\nclass Example {\n  constructor(value) {\n    this.value = value;\n  }\n  \n  // Instance method - needs instance data\n  instanceMethod() {\n    return this.value * 2;\n  }\n  \n  // Static method - doesn't need instance\n  static staticMethod(value) {\n    return value * 2;\n  }\n}\n\nconst ex = new Example(5);\nconsole.log(ex.instanceMethod()); // 10 (uses instance data)\nconsole.log(Example.staticMethod(5)); // 10 (no instance needed)\n\n// Static blocks (ES2022) - initialization\nclass DatabaseConnection {\n  static #connection = null;\n  \n  static {\n    // Static initialization block\n    console.log('Initializing database connection...');\n    this.#connection = { connected: true };\n  }\n  \n  static getConnection() {\n    return this.#connection;\n  }\n}\n\n// Private static fields\nclass SecretKeeper {\n  static #secret = 'top-secret';\n  \n  static getSecret(password) {\n    if (password === 'admin123') {\n      return this.#secret;\n    }\n    throw new Error('Access denied');\n  }\n}\n\nconsole.log(SecretKeeper.getSecret('admin123')); // 'top-secret'\n// console.log(SecretKeeper.#secret); // SyntaxError"
        },
        {
          "type": "interview-tip",
          "tip": "Static Methods Best Practices",
          "explanation": "WHEN TO USE STATIC:\n- Utility/helper functions (no instance data needed)\n- Factory methods (create instances)\n- Constants and configuration\n- Counters/singletons\n- Validation functions\n- Comparison functions for sorting\n\nSTATIC vs INSTANCE:\n- Static: belongs to class, no 'this' instance access\n- Instance: belongs to objects, has 'this' access\n\nKEY FEATURES:\n- Called on class: ClassName.method()\n- Can't access instance properties\n- Can access other static members\n- Inherited by child classes\n- 'this' refers to the class\n\nCOMMON PATTERNS:\n- Math utilities\n- Factory methods\n- Validation\n- ORM/Model methods (find, findAll)\n\nEXAMPLES IN WILD:\n- Array.isArray()\n- Object.keys()\n- Math.max()\n- Number.parseInt()"
        },
        {
          "type": "title",
          "level": 2,
          "content": "Q4. What are getters and setters? How do they work?"
        },
        {
          "type": "description",
          "content": "Getters and setters are special methods that allow you to define how properties are accessed and modified. Getters (get) execute when reading a property, setters (set) execute when writing. Used for computed properties, validation, data transformation, and controlled access to private fields."
        },
        {
          "type": "code",
          "language": "javascript",
          "title": "Getters & Setters Examples",
          "code": "// Basic getter and setter\nclass Person {\n  constructor(firstName, lastName) {\n    this.firstName = firstName;\n    this.lastName = lastName;\n  }\n  \n  // Getter - accessed like a property\n  get fullName() {\n    return `${this.firstName} ${this.lastName}`;\n  }\n  \n  // Setter - assigned like a property\n  set fullName(name) {\n    const parts = name.split(' ');\n    this.firstName = parts[0];\n    this.lastName = parts[1] || '';\n  }\n}\n\nconst person = new Person('John', 'Doe');\nconsole.log(person.fullName); // 'John Doe' (no parentheses!)\n\nperson.fullName = 'Jane Smith'; // Calls setter\nconsole.log(person.firstName); // 'Jane'\nconsole.log(person.lastName); // 'Smith'\n\n// Getter for computed property\nclass Circle {\n  constructor(radius) {\n    this.radius = radius;\n  }\n  \n  get diameter() {\n    return this.radius * 2;\n  }\n  \n  get circumference() {\n    return 2 * Math.PI * this.radius;\n  }\n  \n  get area() {\n    return Math.PI * this.radius ** 2;\n  }\n}\n\nconst circle = new Circle(5);\nconsole.log(circle.diameter); // 10\nconsole.log(circle.circumference); // 31.41592653589793\nconsole.log(circle.area); // 78.53981633974483\n\n// Setter with validation\nclass User {\n  #age = 0; // Private field\n  \n  get age() {\n    return this.#age;\n  }\n  \n  set age(value) {\n    if (typeof value !== 'number') {\n      throw new TypeError('Age must be a number');\n    }\n    if (value < 0 || value > 150) {\n      throw new RangeError('Age must be between 0 and 150');\n    }\n    this.#age = value;\n  }\n}\n\nconst user = new User();\nuser.age = 25; // Valid\nconsole.log(user.age); // 25\n\ntry {\n  user.age = -5; // Invalid\n} catch (e) {\n  console.error(e.message); // 'Age must be between 0 and 150'\n}\n\n// Read-only property (getter without setter)\nclass Product {\n  constructor(price, taxRate = 0.1) {\n    this.price = price;\n    this.taxRate = taxRate;\n  }\n  \n  get totalPrice() {\n    return this.price * (1 + this.taxRate);\n  }\n}\n\nconst product = new Product(100);\nconsole.log(product.totalPrice); // 110\nproduct.totalPrice = 200; // Silently ignored (no setter)\nconsole.log(product.totalPrice); // Still 110\n\n// Write-only property (setter without getter) - rare\nclass Logger {\n  set log(message) {\n    console.log(`[${new Date().toISOString()}] ${message}`);\n  }\n}\n\nconst logger = new Logger();\nlogger.log = 'User logged in'; // Calls setter\n// console.log(logger.log); // undefined (no getter)\n\n// Getter/setter with private field\nclass Temperature {\n  #celsius = 0;\n  \n  get celsius() {\n    return this.#celsius;\n  }\n  \n  set celsius(value) {\n    this.#celsius = value;\n  }\n  \n  get fahrenheit() {\n    return this.#celsius * 9/5 + 32;\n  }\n  \n  set fahrenheit(value) {\n    this.#celsius = (value - 32) * 5/9;\n  }\n}\n\nconst temp = new Temperature();\ntemp.celsius = 0;\nconsole.log(temp.fahrenheit); // 32\n\ntemp.fahrenheit = 212;\nconsole.log(temp.celsius); // 100\n\n// Lazy initialization with getter\nclass DataLoader {\n  #data = null;\n  \n  get data() {\n    if (this.#data === null) {\n      console.log('Loading data...');\n      this.#data = this.#loadData();\n    }\n    return this.#data;\n  }\n  \n  #loadData() {\n    // Expensive operation\n    return Array.from({ length: 1000 }, (_, i) => i);\n  }\n}\n\nconst loader = new DataLoader();\nconsole.log('Created loader');\nconsole.log(loader.data.length); // Logs 'Loading data...' then 1000\nconsole.log(loader.data.length); // 1000 (no loading, cached)\n\n// Object literal getters/setters\nconst account = {\n  balance: 1000,\n  transactions: [],\n  \n  get formattedBalance() {\n    return `$${this.balance.toFixed(2)}`;\n  },\n  \n  set deposit(amount) {\n    if (amount > 0) {\n      this.balance += amount;\n      this.transactions.push({ type: 'deposit', amount });\n    }\n  },\n  \n  set withdraw(amount) {\n    if (amount > 0 && amount <= this.balance) {\n      this.balance -= amount;\n      this.transactions.push({ type: 'withdraw', amount });\n    }\n  }\n};\n\nconsole.log(account.formattedBalance); // '$1000.00'\naccount.deposit = 500;\naccount.withdraw = 200;\nconsole.log(account.formattedBalance); // '$1300.00'\nconsole.log(account.transactions);\n\n// Defining getter/setter with Object.defineProperty\nconst obj = {};\n\nObject.defineProperty(obj, 'name', {\n  get() {\n    return this._name || 'Unknown';\n  },\n  set(value) {\n    this._name = value.toUpperCase();\n  },\n  enumerable: true,\n  configurable: true\n});\n\nobj.name = 'alice';\nconsole.log(obj.name); // 'ALICE'\n\n// Chaining setters\nclass Builder {\n  #config = {};\n  \n  set name(value) {\n    this.#config.name = value;\n    return this; // Return 'this' for chaining\n  }\n  \n  set age(value) {\n    this.#config.age = value;\n    return this;\n  }\n  \n  build() {\n    return { ...this.#config };\n  }\n}\n\nconst builder = new Builder();\n// Note: Setters can't actually return values that are used\n// This pattern doesn't work with setters\n// builder.name = 'Alice'.age = 25; // Doesn't work\n\n// Better: Use methods for chaining\nclass FluentBuilder {\n  #config = {};\n  \n  name(value) {\n    this.#config.name = value;\n    return this;\n  }\n  \n  age(value) {\n    this.#config.age = value;\n    return this;\n  }\n  \n  build() {\n    return { ...this.#config };\n  }\n}\n\nconst config = new FluentBuilder()\n  .name('Alice')\n  .age(25)\n  .build();\n\nconsole.log(config); // { name: 'Alice', age: 25 }\n\n// Getter/setter performance\nclass WithGetter {\n  get value() {\n    return this._value;\n  }\n  set value(v) {\n    this._value = v;\n  }\n}\n\nclass WithProperty {\n  // Direct property access is faster\n}\n\n// For simple cases, direct property is faster\n// For computed/validated values, getters/setters are worth it\n\n// Real-world: Form validation\nclass FormField {\n  #value = '';\n  #errors = [];\n  \n  get value() {\n    return this.#value;\n  }\n  \n  set value(val) {\n    this.#value = val;\n    this.#validate();\n  }\n  \n  get isValid() {\n    return this.#errors.length === 0;\n  }\n  \n  get errors() {\n    return [...this.#errors];\n  }\n  \n  #validate() {\n    this.#errors = [];\n    if (this.#value.length < 3) {\n      this.#errors.push('Too short');\n    }\n  }\n}\n\nconst field = new FormField();\nfield.value = 'ab';\nconsole.log(field.isValid); // false\nconsole.log(field.errors); // ['Too short']\n\nfield.value = 'abc';\nconsole.log(field.isValid); // true"
        },
        {
          "type": "interview-tip",
          "tip": "Getters & Setters Key Points",
          "explanation": "SYNTAX:\n- get propertyName() { return value; }\n- set propertyName(value) { this.field = value; }\n- Accessed like properties: obj.prop (no parentheses)\n\nUSE CASES:\n1. Computed properties (derived from other values)\n2. Validation (check before setting)\n3. Data transformation (format, normalize)\n4. Lazy loading (compute on first access)\n5. Controlled access to private fields\n6. Read-only properties (getter only)\n7. Side effects (logging, notifications)\n\nBENEFITS:\n- Cleaner API (looks like property access)\n- Encapsulation (hide implementation)\n- Validation on assignment\n- Backward compatibility (can change internal implementation)\n\nLIMITATIONS:\n- Getters should be fast (no heavy computation)\n- Setters can't return values (for chaining)\n- Can't be async\n\nBEST PRACTICES:\n- Use with private fields for encapsulation\n- Keep getters simple and fast\n- Validate in setters\n- Don't perform side effects in getters"
        }
      ]
    },
    {
      "id": "section-7",
      "title": "JavaScript - Event Loop",
      "blocks": [
        {
          "type": "title",
          "level": 2,
          "content": "Q1. Explain the JavaScript Event Loop?"
        },
        {
          "type": "description",
          "content": "Event Loop enables async JavaScript. Call Stack executes synchronous code. Web APIs handle async operations (setTimeout, fetch). Callback Queue holds callbacks. Event Loop checks if Call Stack is empty, then moves callbacks from Queue to Stack. This allows non-blocking I/O."
        },
        {
          "type": "code",
          "language": "javascript",
          "title": "Event Loop Example",
          "code": "console.log('1');\nsetTimeout(() => console.log('2'), 0);\nPromise.resolve().then(() => console.log('3'));\nconsole.log('4');\n// Output: 1, 4, 3, 2\n// Sync code → Microtasks (Promise) → Macrotasks (setTimeout)"
        },
        {
          "type": "interview-tip",
          "tip": "Event Loop Key Points",
          "explanation": "1. JavaScript is single-threaded\n2. Event Loop coordinates Call Stack, Web APIs, and Queues\n3. Microtasks (Promises) run before macrotasks (setTimeout)\n4. Each iteration: sync code → all microtasks → one macrotask"
        },
        {
          "type": "title",
          "level": 2,
          "content": "Q2. What is the difference between microtasks and macrotasks?"
        },
        {
          "type": "description",
          "content": "Microtasks (Promise callbacks, queueMicrotask) have higher priority and execute after current script but before next macrotask. Macrotasks (setTimeout, setInterval, I/O) execute one per event loop cycle. Order: Call Stack → Microtask Queue → Macrotask Queue."
        },
        {
          "type": "code",
          "language": "javascript",
          "title": "Microtasks vs Macrotasks",
          "code": "setTimeout(() => console.log('timeout'), 0);\nPromise.resolve().then(() => console.log('promise'));\n// Output: promise, timeout\n// ALL microtasks complete before ANY macrotask"
        },
        {
          "type": "interview-tip",
          "tip": "Microtask vs Macrotask",
          "explanation": "MICROTASKS: Promise callbacks, queueMicrotask()\nMACROTASKS: setTimeout, setInterval, I/O\nKey: All microtasks execute before next macrotask\nMicrotasks can starve macrotasks if endless"
        },
        {
          "type": "title",
          "level": 2,
          "content": "Q3. Explain Node.js Event Loop phases?"
        },
        {
          "type": "description",
          "content": "Node.js Event Loop has phases: 1) Timers (setTimeout/setInterval), 2) Pending callbacks (I/O), 3) Idle/Prepare, 4) Poll (retrieve I/O events), 5) Check (setImmediate), 6) Close callbacks. Process.nextTick() and Promise callbacks run between phases in microtask queue."
        },
        {
          "type": "code",
          "language": "javascript",
          "title": "Node.js Event Loop",
          "code": "// Inside I/O cycle:\nfs.readFile(__filename, () => {\n  setTimeout(() => console.log('timeout'), 0);\n  setImmediate(() => console.log('immediate'));\n});\n// Output: immediate, timeout\n// After poll → check (setImmediate) → next iteration timers"
        },
        {
          "type": "interview-tip",
          "tip": "Node.js Event Loop Phases",
          "explanation": "PHASES: Timers → Pending → Poll → Check → Close\nprocess.nextTick() runs before entering next phase\nsetImmediate after I/O runs before setTimeout\nRecursive setImmediate allows I/O (non-blocking)\nRecursive nextTick blocks event loop (dangerous!)"
        }
      ]
    },
    {
      "id": "section-8",
      "title": "TypeScript",
      "blocks": [
        {
          "type": "title",
          "level": 2,
          "content": "Q1. What are TypeScript generics and why use them?"
        },
        {
          "type": "description",
          "content": "Generics allow creating reusable components that work with multiple types while maintaining type safety. Syntax: function identity<T>(arg: T): T { return arg; }. Benefits: type safety, code reusability, better IDE support. Use for arrays, promises, functions, and classes."
        },
        {
          "type": "code",
          "language": "typescript",
          "title": "TypeScript Generics",
          "code": "// Generic function\nfunction identity<T>(arg: T): T {\n  return arg;\n}\n\nconst num = identity<number>(42);\nconst str = identity<string>('hello');\n\n// Generic interface\ninterface Box<T> {\n  value: T;\n}\n\nconst numBox: Box<number> = { value: 42 };\nconst strBox: Box<string> = { value: 'hello' };"
        },
        {
          "type": "interview-tip",
          "tip": "Generics Key Points",
          "explanation": "1. Type variables: <T>, <K, V>, <T extends BaseType>\n2. Use for arrays, promises, API responses\n3. Constraints: <T extends SomeType>\n4. Default types: <T = string>\n5. Benefits: Type safety + Reusability"
        },
        {
          "type": "title",
          "level": 2,
          "content": "Q2. Explain TypeScript utility types: Partial, Omit, ReturnType?"
        },
        {
          "type": "description",
          "content": "Partial<T> makes all properties optional. Omit<T, K> removes specified properties. ReturnType<T> extracts function return type. Example: type User = {name: string; age: number}; type PartialUser = Partial<User>; type NoAge = Omit<User, 'age'>; type Result = ReturnType<typeof func>;"
        },
        {
          "type": "code",
          "language": "typescript",
          "title": "Utility Types",
          "code": "type User = { name: string; age: number; email: string };\n\n// Partial - all optional\ntype PartialUser = Partial<User>;\nconst user1: PartialUser = { name: 'Alice' }; // OK\n\n// Omit - remove properties\ntype UserWithoutEmail = Omit<User, 'email'>;\n\n// ReturnType - extract return type\nfunction getUser() { return { name: 'Alice', age: 25 }; }\ntype UserType = ReturnType<typeof getUser>;\n\n// Pick - select properties\ntype UserNameAge = Pick<User, 'name' | 'age'>;"
        },
        {
          "type": "interview-tip",
          "tip": "Common Utility Types",
          "explanation": "Partial<T>: All optional\nRequired<T>: All required\nReadonly<T>: All readonly\nPick<T, K>: Select properties\nOmit<T, K>: Remove properties\nReturnType<T>: Extract return type\nParameters<T>: Extract parameter types"
        },
        {
          "type": "title",
          "level": 2,
          "content": "Q3. What are type guards in TypeScript?"
        },
        {
          "type": "description",
          "content": "Type guards narrow down types within conditional blocks. Built-in: typeof, instanceof. Custom: user-defined type predicates. Example: function isString(x: any): x is string { return typeof x === 'string'; }. TypeScript narrows type after guard check."
        },
        {
          "type": "code",
          "language": "typescript",
          "title": "Type Guards",
          "code": "// typeof guard\nfunction print(x: string | number) {\n  if (typeof x === 'string') {\n    console.log(x.toUpperCase()); // x is string\n  } else {\n    console.log(x.toFixed(2)); // x is number\n  }\n}\n\n// Custom type guard\nfunction isString(x: any): x is string {\n  return typeof x === 'string';\n}\n\nif (isString(value)) {\n  console.log(value.toUpperCase()); // Type narrowed\n}"
        },
        {
          "type": "interview-tip",
          "tip": "Type Guards Summary",
          "explanation": "BUILT-IN:\n- typeof: for primitives\n- instanceof: for classes\n- in: for property check\n\nCUSTOM:\n- Type predicates: x is Type\n- Used in if/switch statements\n- TypeScript narrows type automatically"
        },
        {
          "type": "title",
          "level": 2,
          "content": "Q4. Explain the 'infer' keyword in TypeScript?"
        },
        {
          "type": "description",
          "content": "infer introduces a type variable within conditional types to capture and use types. Example: type ReturnType<T> = T extends (...args: any[]) => infer R ? R : never; This extracts return type from function signature. Useful for advanced type manipulations."
        },
        {
          "type": "code",
          "language": "typescript",
          "title": "Infer Keyword",
          "code": "// Extract return type\ntype ReturnType<T> = T extends (...args: any[]) => infer R ? R : never;\n\nfunction getUser() {\n  return { name: 'Alice', age: 25 };\n}\n\ntype User = ReturnType<typeof getUser>; // { name: string; age: number }\n\n// Extract array element type\ntype Flatten<T> = T extends Array<infer U> ? U : T;\n\ntype Num = Flatten<number[]>; // number\ntype Str = Flatten<string>; // string"
        },
        {
          "type": "interview-tip",
          "tip": "Infer Usage",
          "explanation": "1. Used in conditional types only\n2. Extracts types from generic parameters\n3. Common uses: ReturnType, Parameters, ElementType\n4. Syntax: T extends SomeType<infer U> ? U : never\n5. Advanced type-level programming"
        }
      ]
    },
    {
      "id": "section-9",
      "title": "Web Security",
      "blocks": [
        {
          "type": "title",
          "level": 2,
          "content": "Q1. What is CORS and why is it important?"
        },
        {
          "type": "description",
          "content": "CORS (Cross-Origin Resource Sharing) is a security mechanism that allows controlled access to resources from different origins. Browser blocks cross-origin requests by default. Server must send Access-Control-Allow-Origin header. Prevents malicious sites from accessing user data from other sites."
        },
        {
          "type": "code",
          "language": "javascript",
          "title": "CORS Example",
          "code": "// Server-side (Node.js/Express)\napp.use((req, res, next) => {\n  res.header('Access-Control-Allow-Origin', '*');\n  res.header('Access-Control-Allow-Methods', 'GET, POST, PUT');\n  res.header('Access-Control-Allow-Headers', 'Content-Type');\n  next();\n});\n\n// Specific origin\nres.header('Access-Control-Allow-Origin', 'https://example.com');\n\n// With credentials\nres.header('Access-Control-Allow-Credentials', 'true');"
        },
        {
          "type": "interview-tip",
          "tip": "CORS Key Points",
          "explanation": "1. Browser security feature, not server-side\n2. Preflight requests for complex requests (OPTIONS)\n3. Simple requests: GET, POST with simple headers\n4. Credentials require explicit Allow-Credentials header\n5. '*' wildcard not allowed with credentials\n6. Set on server, enforced by browser"
        },
        {
          "type": "title",
          "level": 2,
          "content": "Q2. Explain XSS (Cross-Site Scripting) attacks and prevention?"
        },
        {
          "type": "description",
          "content": "XSS injects malicious scripts into trusted websites. Types: Stored, Reflected, DOM-based. Prevention: sanitize user input, use Content Security Policy, escape output, use textContent instead of innerHTML, validate on server, use frameworks with built-in protection."
        },
        {
          "type": "code",
          "language": "javascript",
          "title": "XSS Prevention",
          "code": "// BAD - Vulnerable to XSS\ndiv.innerHTML = userInput; // Can execute scripts!\n\n// GOOD - Safe\ndiv.textContent = userInput; // Treats as text\n\n// Sanitization\nfunction sanitize(input) {\n  const div = document.createElement('div');\n  div.textContent = input;\n  return div.innerHTML;\n}\n\n// CSP Header\nContent-Security-Policy: default-src 'self'; script-src 'self'\n\n// React auto-escapes\n<div>{userInput}</div> // Safe in React"
        },
        {
          "type": "interview-tip",
          "tip": "XSS Prevention",
          "explanation": "TYPES:\n1. Stored: Saved in database\n2. Reflected: In URL parameters\n3. DOM-based: Client-side only\n\nPREVENTION:\n- Sanitize input\n- Escape output\n- Use textContent, not innerHTML\n- Content Security Policy\n- HTTPOnly cookies\n- Framework protection (React, Angular)"
        },
        {
          "type": "title",
          "level": 2,
          "content": "Q3. What is CSRF (Cross-Site Request Forgery) and how to prevent it?"
        },
        {
          "type": "description",
          "content": "CSRF tricks users into executing unwanted actions on authenticated sites. Prevention: use CSRF tokens, SameSite cookie attribute, verify origin/referer headers, require re-authentication for sensitive actions, use custom headers for API requests."
        },
        {
          "type": "code",
          "language": "javascript",
          "title": "CSRF Prevention",
          "code": "// CSRF Token (server generates)\nconst token = generateSecureToken();\n\n// Include in form\n<input type=\"hidden\" name=\"csrf_token\" value={token} />\n\n// Verify on server\nif (req.body.csrf_token !== req.session.csrf_token) {\n  throw new Error('Invalid CSRF token');\n}\n\n// SameSite cookie\nres.cookie('session', value, { sameSite: 'strict' });\n\n// Custom header for AJAX\nfetch('/api/data', {\n  headers: { 'X-Requested-With': 'XMLHttpRequest' }\n});"
        },
        {
          "type": "interview-tip",
          "tip": "CSRF Prevention",
          "explanation": "METHODS:\n1. CSRF tokens (synchronizer token pattern)\n2. SameSite cookies (Strict/Lax)\n3. Verify Origin/Referer headers\n4. Double-submit cookie pattern\n5. Custom request headers\n6. Re-authentication for sensitive ops\n\nBEST: Combine multiple methods"
        },
        {
          "type": "title",
          "level": 2,
          "content": "Q4. Explain JWT (JSON Web Token) authentication?"
        },
        {
          "type": "description",
          "content": "JWT is a compact token format for securely transmitting information. Structure: Header.Payload.Signature (base64 encoded). Server signs token with secret. Client includes in Authorization header. Stateless authentication. Pros: scalable, works across domains. Cons: can't revoke before expiry, size larger than session ID."
        },
        {
          "type": "code",
          "language": "javascript",
          "title": "JWT Example",
          "code": "// Server: Generate JWT\nconst jwt = require('jsonwebtoken');\nconst token = jwt.sign(\n  { userId: 123, role: 'admin' },\n  process.env.SECRET_KEY,\n  { expiresIn: '1h' }\n);\n\n// Client: Send token\nfetch('/api/data', {\n  headers: {\n    'Authorization': `Bearer ${token}`\n  }\n});\n\n// Server: Verify token\nconst decoded = jwt.verify(token, process.env.SECRET_KEY);\nconsole.log(decoded.userId); // 123"
        },
        {
          "type": "interview-tip",
          "tip": "JWT Key Points",
          "explanation": "STRUCTURE:\nHeader.Payload.Signature (base64)\n\nPROS:\n- Stateless (no server storage)\n- Scalable\n- Cross-domain\n- Self-contained\n\nCONS:\n- Can't revoke before expiry\n- Larger than session ID\n- Exposed if XSS vulnerable\n\nBEST PRACTICES:\n- Short expiry time\n- Refresh tokens\n- HTTPOnly cookies for storage\n- Verify signature\n- Don't store sensitive data"
        }
      ]
    },
    {
      "id": "section-10",
      "title": "Node.js",
      "blocks": [
        {
          "type": "title",
          "level": 2,
          "content": "Q1. Explain the difference between require() and import?"
        },
        {
          "type": "description",
          "content": "require() is CommonJS, synchronous, can be called conditionally, returns module.exports. import is ES6 modules, asynchronous, must be at top level, allows named imports. Node.js supports both but import requires .mjs extension or \"type\": \"module\" in package.json."
        },
        {
          "type": "code",
          "language": "javascript",
          "title": "require vs import",
          "code": "// CommonJS - require()\nconst express = require('express');\nconst { Router } = require('express');\n\n// Can be conditional\nif (condition) {\n  const module = require('./module');\n}\n\n// ES6 Modules - import\nimport express from 'express';\nimport { Router } from 'express';\nimport * as utils from './utils.js';\n\n// Must be at top level (not in if block)\n// import is hoisted"
        },
        {
          "type": "interview-tip",
          "tip": "require vs import",
          "explanation": "REQUIRE (CommonJS):\n- Synchronous\n- Dynamic (can be conditional)\n- Returns module.exports\n- Runtime\n- Default in Node.js\n\nIMPORT (ES Modules):\n- Asynchronous\n- Static (top level only)\n- Named + default imports\n- Compile-time\n- Needs .mjs or type: module\n\nBEST: Use import for new projects"
        },
        {
          "type": "title",
          "level": 2,
          "content": "Q2. What is the Node.js Event Loop and how does it differ from browser?"
        },
        {
          "type": "description",
          "content": "Node.js Event Loop handles async I/O operations. Phases: timers, pending callbacks, poll, check, close. Uses libuv for cross-platform async I/O. Browser event loop simpler: microtasks, macrotasks, rendering. Node.js optimized for server I/O, browser for user interactions and rendering."
        },
        {
          "type": "code",
          "language": "javascript",
          "title": "Node.js vs Browser Event Loop",
          "code": "// Node.js specific\nprocess.nextTick(() => console.log('nextTick'));\nsetImmediate(() => console.log('setImmediate'));\n\n// Browser doesn't have:\n// - process.nextTick()\n// - setImmediate()\n\n// Browser has:\n// - requestAnimationFrame()\n// - requestIdleCallback()\n\n// Both have:\nsetTimeout(() => console.log('timeout'), 0);\nPromise.resolve().then(() => console.log('promise'));"
        },
        {
          "type": "interview-tip",
          "tip": "Node vs Browser Event Loop",
          "explanation": "NODE.JS:\n- Multiple phases (timers, poll, check, etc.)\n- process.nextTick(), setImmediate()\n- Optimized for I/O\n- libuv for async\n\nBROWSER:\n- Simpler (macrotasks, microtasks, render)\n- requestAnimationFrame(), requestIdleCallback()\n- Optimized for UI\n- Web APIs for async\n\nBOTH:\n- Single-threaded\n- setTimeout, Promises"
        },
        {
          "type": "title",
          "level": 2,
          "content": "Q3. Explain streams in Node.js and their types?"
        },
        {
          "type": "description",
          "content": "Streams handle reading/writing data in chunks, efficient for large data. Types: Readable (read data), Writable (write data), Duplex (both), Transform (modify data). Benefits: memory efficient, time efficient. Example: fs.createReadStream().pipe(response)."
        },
        {
          "type": "code",
          "language": "javascript",
          "title": "Node.js Streams",
          "code": "const fs = require('fs');\n\n// Readable stream\nconst readStream = fs.createReadStream('large-file.txt');\nreadStream.on('data', (chunk) => {\n  console.log('Received chunk:', chunk.length);\n});\n\n// Writable stream\nconst writeStream = fs.createWriteStream('output.txt');\nwriteStream.write('Hello ');\nwriteStream.end('World!');\n\n// Pipe (readable to writable)\nreadStream.pipe(writeStream);\n\n// Transform stream\nconst { Transform } = require('stream');\nconst upperCase = new Transform({\n  transform(chunk, encoding, callback) {\n    callback(null, chunk.toString().toUpperCase());\n  }\n});\n\nreadStream.pipe(upperCase).pipe(writeStream);"
        },
        {
          "type": "interview-tip",
          "tip": "Streams Summary",
          "explanation": "TYPES:\n1. Readable: fs.createReadStream(), HTTP request\n2. Writable: fs.createWriteStream(), HTTP response\n3. Duplex: TCP socket (both directions)\n4. Transform: zlib, crypto (modify data)\n\nBENEFITS:\n- Memory efficient (chunks, not whole file)\n- Time efficient (start processing immediately)\n- Composable (pipe)\n\nUSE CASES:\n- Large files\n- Network I/O\n- Data transformation"
        },
        {
          "type": "title",
          "level": 2,
          "content": "Q4. What is the difference between fork() and spawn() in child processes?"
        },
        {
          "type": "description",
          "content": "spawn() launches a new process for any command, returns stdout/stderr streams. fork() is special case of spawn() for Node.js processes, enables IPC (Inter-Process Communication) via send()/on('message'). Use fork() for Node scripts, spawn() for any command."
        },
        {
          "type": "code",
          "language": "javascript",
          "title": "fork vs spawn",
          "code": "const { spawn, fork } = require('child_process');\n\n// spawn - for any command\nconst ls = spawn('ls', ['-lh', '/usr']);\nls.stdout.on('data', (data) => {\n  console.log(`Output: ${data}`);\n});\n\n// fork - for Node.js scripts (with IPC)\nconst child = fork('worker.js');\nchild.send({ task: 'process-data', data: [1,2,3] });\nchild.on('message', (result) => {\n  console.log('Result from child:', result);\n});\n\n// worker.js\nprocess.on('message', (msg) => {\n  const result = msg.data.reduce((a,b) => a+b, 0);\n  process.send({ result });\n});"
        },
        {
          "type": "interview-tip",
          "tip": "fork vs spawn",
          "explanation": "SPAWN:\n- Any command (ls, python, etc.)\n- Returns streams (stdout, stderr)\n- No built-in IPC\n- More generic\n\nFORK:\n- Node.js scripts only\n- Built-in IPC (send/on('message'))\n- Specialized spawn for Node\n- Communication-friendly\n\nOTHERS:\n- exec(): buffers output\n- execFile(): like exec but for files\n\nUSE:\n- fork() for Node worker processes\n- spawn() for shell commands"
        }
      ]
    },
    {
      "id": "section-11",
      "title": "Angular",
      "blocks": [
        {
          "type": "title",
          "level": 2,
          "content": "Q1. Explain Angular Change Detection strategies?"
        },
        {
          "type": "description",
          "content": "Default: checks entire component tree on events. OnPush: checks only when @Input reference changes or events occur within component. Benefits: performance improvement. Use ChangeDetectorRef to manually trigger. NgZone tracks async operations. markForCheck() marks path to root for checking."
        },
        {
          "type": "code",
          "language": "typescript",
          "title": "Change Detection Strategies",
          "code": "// Default strategy - checks on every event\n@Component({\n  selector: 'app-default',\n  template: `<div>{{ data.value }}</div>`\n})\nexport class DefaultComponent {}\n\n// OnPush strategy - checks only on @Input changes\n@Component({\n  selector: 'app-optimized',\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  template: `<div>{{ data.value }}</div>`\n})\nexport class OptimizedComponent {\n  @Input() data: any;\n  \n  constructor(private cdr: ChangeDetectorRef) {}\n  \n  updateManually() {\n    this.cdr.markForCheck(); // Mark for check\n    this.cdr.detectChanges(); // Run immediately\n  }\n}"
        },
        {
          "type": "interview-tip",
          "tip": "Change Detection",
          "explanation": "DEFAULT:\n- Checks entire tree\n- On every event\n- Simple but slower\n\nONPUSH:\n- Checks only on @Input reference change\n- Or component events\n- Better performance\n- Use with immutable data\n\nMANUAL:\n- markForCheck(): schedule check\n- detectChanges(): run immediately\n- detach(): stop checking\n- reattach(): resume checking"
        },
        {
          "type": "title",
          "level": 2,
          "content": "Q2. What is the difference between template-driven and reactive forms?"
        },
        {
          "type": "description",
          "content": "Template-driven: logic in template, uses ngModel, async, easier for simple forms. Reactive: logic in component class, uses FormControl/FormGroup, synchronous, better for complex forms, more testable, better validation control."
        },
        {
          "type": "code",
          "language": "typescript",
          "title": "Forms Comparison",
          "code": "// Template-driven form\n@Component({\n  template: `\n    <form #form=\"ngForm\" (ngSubmit)=\"onSubmit(form)\">\n      <input name=\"name\" [(ngModel)]=\"user.name\" required>\n      <button [disabled]=\"!form.valid\">Submit</button>\n    </form>\n  `\n})\nexport class TemplateFormComponent {\n  user = { name: '' };\n  onSubmit(form: NgForm) {\n    console.log(form.value);\n  }\n}\n\n// Reactive form\n@Component({\n  template: `\n    <form [formGroup]=\"form\" (ngSubmit)=\"onSubmit()\">\n      <input formControlName=\"name\">\n      <button [disabled]=\"!form.valid\">Submit</button>\n    </form>\n  `\n})\nexport class ReactiveFormComponent {\n  form = new FormGroup({\n    name: new FormControl('', Validators.required)\n  });\n  \n  onSubmit() {\n    console.log(this.form.value);\n  }\n}"
        },
        {
          "type": "interview-tip",
          "tip": "Forms Comparison",
          "explanation": "TEMPLATE-DRIVEN:\n- Logic in template\n- ngModel, #form\n- Async (forms module)\n- Simple forms\n- Less testable\n\nREACTIVE:\n- Logic in component\n- FormControl, FormGroup\n- Synchronous\n- Complex forms\n- More testable\n- Better validation\n- Programmatic control\n\nBEST: Reactive for most cases"
        },
        {
          "type": "title",
          "level": 2,
          "content": "Q3. Explain RxJS operators: map, switchMap, mergeMap, concatMap?"
        },
        {
          "type": "description",
          "content": "map: transforms emitted values. switchMap: cancels previous inner observable, use for search/autocomplete. mergeMap: runs inner observables concurrently, maintains order not guaranteed. concatMap: queues inner observables, maintains order. Choose based on whether you need cancellation, concurrency, or ordering."
        },
        {
          "type": "code",
          "language": "typescript",
          "title": "RxJS Operators",
          "code": "// map - transform values\nof(1, 2, 3).pipe(\n  map(x => x * 2)\n).subscribe(x => console.log(x)); // 2, 4, 6\n\n// switchMap - cancel previous\nsearchBox.valueChanges.pipe(\n  switchMap(term => this.api.search(term))\n).subscribe(results => {...});\n// Cancels previous search if new input\n\n// mergeMap - concurrent\nof(1, 2, 3).pipe(\n  mergeMap(x => this.api.getData(x))\n).subscribe(result => {...});\n// All requests run concurrently\n\n// concatMap - sequential\nof(1, 2, 3).pipe(\n  concatMap(x => this.api.saveData(x))\n).subscribe(result => {...});\n// Waits for each to complete before next"
        },
        {
          "type": "interview-tip",
          "tip": "RxJS Operators Summary",
          "explanation": "MAP:\n- Transforms values\n- Synchronous\n\nSWITCHMAP:\n- Cancels previous\n- Use: search, autocomplete\n- Latest value wins\n\nMERGEMAP:\n- Concurrent\n- No cancellation\n- Order not guaranteed\n\nCONCATMAP:\n- Sequential queue\n- Order maintained\n- Use: sequential operations\n\nCHOOSE:\n- Need cancel? switchMap\n- Need order? concatMap\n- Need speed? mergeMap"
        },
        {
          "type": "title",
          "level": 2,
          "content": "Q4. What is Dependency Injection in Angular?"
        },
        {
          "type": "description",
          "content": "DI is a design pattern where dependencies are provided to a class rather than created by it. Angular's DI system: @Injectable() marks service, providers array registers, constructor injection receives. Benefits: testability, loose coupling, code reuse. Hierarchical injector tree from root to component."
        },
        {
          "type": "code",
          "language": "typescript",
          "title": "Dependency Injection",
          "code": "// Service with @Injectable\n@Injectable({ providedIn: 'root' })\nexport class DataService {\n  getData() { return [1, 2, 3]; }\n}\n\n// Component injects service\n@Component({\n  selector: 'app-my-component',\n  template: `<div>{{ data }}</div>`\n})\nexport class MyComponent {\n  data: number[];\n  \n  // Constructor injection\n  constructor(private dataService: DataService) {\n    this.data = dataService.getData();\n  }\n}\n\n// Module-level provider\n@NgModule({\n  providers: [\n    { provide: API_URL, useValue: 'https://api.example.com' }\n  ]\n})\nexport class AppModule {}"
        },
        {
          "type": "interview-tip",
          "tip": "Dependency Injection",
          "explanation": "BENEFITS:\n1. Testability (mock dependencies)\n2. Loose coupling\n3. Code reuse\n4. Configuration management\n\nPROVIDERS:\n- providedIn: 'root' (singleton)\n- providers: [] in module/component\n- useClass, useValue, useFactory\n\nINJECTOR TREE:\n- Root injector\n- Module injectors\n- Component injectors\n\nLIFETIME:\n- Root: app lifetime\n- Module: lazy-loaded lifetime\n- Component: component lifetime"
        }
      ]
    },
    {
      "id": "section-12",
      "title": "Testing",
      "blocks": [
        {
          "type": "title",
          "level": 2,
          "content": "Q1. Explain the Testing Pyramid?"
        },
        {
          "type": "description",
          "content": "Testing Pyramid shows test distribution: base is Unit tests (most, fast, isolated), middle is Integration tests (moderate, test interactions), top is E2E tests (few, slow, test full system). More unit tests provide fast feedback, fewer E2E reduce maintenance and execution time."
        },
        {
          "type": "code",
          "language": "text",
          "title": "Testing Pyramid",
          "code": "       /\\        E2E Tests (Few, Slow, Expensive)\n      /  \\       - Test full user flows\n     /    \\      - Browser automation\n    /------\\     Integration Tests (Some, Medium)\n   / INTEGR \\    - Test component interactions\n  /----------\\   - API + DB tests\n /   UNIT     \\  Unit Tests (Many, Fast, Cheap)\n/--------------\\ - Test individual functions\n                 - Isolated, mocked dependencies"
        },
        {
          "type": "interview-tip",
          "tip": "Testing Pyramid",
          "explanation": "UNIT TESTS (70%):\n- Fast, isolated\n- Test functions/methods\n- Mock dependencies\n- High coverage\n\nINTEGRATION (20%):\n- Test interactions\n- API + DB\n- Component integration\n\nE2E (10%):\n- Full user flows\n- Slow, expensive\n- Critical paths only\n\nBENEFITS:\n- Fast feedback (unit)\n- Confidence (E2E)\n- Balance cost/value"
        },
        {
          "type": "title",
          "level": 2,
          "content": "Q2. What is the difference between unit, integration, and E2E testing?"
        },
        {
          "type": "description",
          "content": "Unit: test individual functions/components in isolation, fast, mocked dependencies. Integration: test interaction between components/modules, moderate speed. E2E: test entire application flow from user perspective, slow, most realistic. Each serves different purpose in quality assurance."
        },
        {
          "type": "code",
          "language": "javascript",
          "title": "Test Types Examples",
          "code": "// Unit test - isolated function\ndescribe('calculateTotal', () => {\n  it('should sum prices', () => {\n    expect(calculateTotal([10, 20, 30])).toBe(60);\n  });\n});\n\n// Integration test - component + service\ndescribe('UserComponent + UserService', () => {\n  it('should load user data', async () => {\n    const component = new UserComponent(userService);\n    await component.loadUser(123);\n    expect(component.user.name).toBe('Alice');\n  });\n});\n\n// E2E test - full user flow\ntest('user can complete checkout', async () => {\n  await page.goto('/shop');\n  await page.click('.add-to-cart');\n  await page.click('.checkout');\n  await page.fill('#card-number', '4111111111111111');\n  await page.click('.submit-order');\n  await expect(page.locator('.success')).toBeVisible();\n});"
        },
        {
          "type": "interview-tip",
          "tip": "Test Types Comparison",
          "explanation": "UNIT:\n- Scope: Single function/class\n- Speed: Fast (milliseconds)\n- Dependencies: Mocked\n- Isolation: High\n- Tools: Jest, Mocha\n\nINTEGRATION:\n- Scope: Multiple components\n- Speed: Medium (seconds)\n- Dependencies: Real or partial mocks\n- Isolation: Medium\n- Tools: Jest + testing-library\n\nE2E:\n- Scope: Full application\n- Speed: Slow (minutes)\n- Dependencies: Real (browser, DB)\n- Isolation: Low\n- Tools: Cypress, Playwright, Selenium"
        },
        {
          "type": "title",
          "level": 2,
          "content": "Q3. Explain test doubles: mock, stub, spy, fake?"
        },
        {
          "type": "description",
          "content": "Stub: provides predetermined responses. Mock: verifies interactions, expectations set beforehand. Spy: wraps real object, records interactions. Fake: working implementation but simplified. Use based on whether you're testing behavior (mock) or state (stub), or need partial functionality (spy)."
        },
        {
          "type": "code",
          "language": "javascript",
          "title": "Test Doubles",
          "code": "// Stub - returns predefined values\nconst userServiceStub = {\n  getUser: () => ({ id: 1, name: 'Alice' })\n};\n\n// Mock - verifies interactions\nconst mockService = jest.fn();\nmockService.getUser = jest.fn().mockResolvedValue({ id: 1 });\nexpect(mockService.getUser).toHaveBeenCalledWith(123);\n\n// Spy - wraps real object\nconst spy = jest.spyOn(userService, 'getUser');\nawait component.loadUser(123);\nexpect(spy).toHaveBeenCalledTimes(1);\nspy.mockRestore();\n\n// Fake - simplified working implementation\nclass FakeDatabase {\n  private data = new Map();\n  save(key, value) { this.data.set(key, value); }\n  get(key) { return this.data.get(key); }\n}"
        },
        {
          "type": "interview-tip",
          "tip": "Test Doubles Summary",
          "explanation": "STUB:\n- Returns fixed values\n- State verification\n- Simple, predictable\n\nMOCK:\n- Behavior verification\n- Expectations set before\n- Verifies calls, arguments\n\nSPY:\n- Wraps real object\n- Records calls\n- Can call through or mock\n\nFAKE:\n- Working implementation\n- Simplified (in-memory DB)\n- Not production-ready\n\nDUMMY:\n- Placeholder\n- Never used\n- Fill parameters"
        }
      ]
    },
    {
      "id": "section-13",
      "title": "CI/CD & DevOps",
      "blocks": [
        {
          "type": "title",
          "level": 2,
          "content": "Q1. What is the difference between CI and CD?"
        },
        {
          "type": "description",
          "content": "CI (Continuous Integration): automatically build and test code on each commit, detect integration issues early. CD (Continuous Delivery): automated deployment to staging, manual production release. CD (Continuous Deployment): fully automated deployment to production. CI focuses on quality, CD on deployment."
        },
        {
          "type": "code",
          "language": "yaml",
          "title": "CI/CD Pipeline Example",
          "code": "# .github/workflows/ci-cd.yml\nname: CI/CD Pipeline\n\non: [push, pull_request]\n\njobs:\n  # Continuous Integration\n  test:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v2\n      - run: npm install\n      - run: npm test\n      - run: npm run lint\n  \n  # Continuous Deployment\n  deploy:\n    needs: test\n    if: github.ref == 'refs/heads/main'\n    runs-on: ubuntu-latest\n    steps:\n      - run: npm run build\n      - run: npm run deploy"
        },
        {
          "type": "interview-tip",
          "tip": "CI vs CD",
          "explanation": "CI (Continuous Integration):\n- Merge code frequently\n- Auto build + test\n- Fast feedback\n- Catch bugs early\n\nCD (Continuous Delivery):\n- Auto deploy to staging\n- Manual prod deploy\n- Release-ready always\n\nCD (Continuous Deployment):\n- Auto deploy to prod\n- No manual gate\n- Full automation\n\nBENEFITS:\n- Faster releases\n- Lower risk\n- Better quality\n- Team efficiency"
        },
        {
          "type": "title",
          "level": 2,
          "content": "Q2. Explain different deployment strategies?"
        },
        {
          "type": "description",
          "content": "Blue-Green: two identical environments, switch traffic. Canary: gradual rollout to subset of users. Rolling: update instances incrementally. A/B Testing: route users to different versions. Feature Flags: control feature availability. Choose based on risk tolerance, rollback needs, and testing requirements."
        },
        {
          "type": "code",
          "language": "text",
          "title": "Deployment Strategies",
          "code": "BLUE-GREEN:\n  Blue (old) ← 100% traffic\n  Green (new) ← 0% traffic\n  → Switch → Green gets 100%\n  → Quick rollback to Blue if issues\n\nCANARY:\n  v1.0 ← 90% traffic\n  v2.0 ← 10% traffic (canary)\n  → Gradually increase v2.0\n  → Monitor metrics\n  → Rollback if errors spike\n\nROLLING:\n  Instances: [v1, v1, v1, v1]\n  → Update 1: [v2, v1, v1, v1]\n  → Update 2: [v2, v2, v1, v1]\n  → Update 3: [v2, v2, v2, v1]\n  → Update 4: [v2, v2, v2, v2]"
        },
        {
          "type": "interview-tip",
          "tip": "Deployment Strategies",
          "explanation": "BLUE-GREEN:\n- Zero downtime\n- Quick rollback\n- 2x infrastructure cost\n\nCANARY:\n- Gradual rollout\n- Monitor subset\n- Detect issues early\n\nROLLING:\n- No extra infrastructure\n- Gradual update\n- Mixed versions running\n\nFEATURE FLAGS:\n- Toggle features\n- A/B testing\n- Gradual rollout\n- No deployment needed\n\nCHOOSE BASED ON:\n- Risk tolerance\n- Infrastructure cost\n- Rollback speed needed"
        },
        {
          "type": "title",
          "level": 2,
          "content": "Q3. What is Infrastructure as Code (IaC)?"
        },
        {
          "type": "description",
          "content": "IaC manages infrastructure through code files rather than manual processes. Benefits: version control, reproducibility, automation. Tools: Terraform (cloud-agnostic), CloudFormation (AWS), Kubernetes manifests. Enables consistent environments, faster provisioning, and infrastructure versioning."
        },
        {
          "type": "code",
          "language": "hcl",
          "title": "Infrastructure as Code Example",
          "code": "# Terraform example\nresource \"aws_instance\" \"web_server\" {\n  ami           = \"ami-0c55b159cbfafe1f0\"\n  instance_type = \"t2.micro\"\n  \n  tags = {\n    Name = \"WebServer\"\n    Environment = \"Production\"\n  }\n}\n\nresource \"aws_s3_bucket\" \"assets\" {\n  bucket = \"my-app-assets\"\n  acl    = \"private\"\n}\n\n# Apply with:\n# terraform init\n# terraform plan\n# terraform apply"
        },
        {
          "type": "interview-tip",
          "tip": "Infrastructure as Code",
          "explanation": "BENEFITS:\n1. Version control (Git)\n2. Reproducibility\n3. Documentation as code\n4. Automation\n5. Consistent environments\n6. Disaster recovery\n\nTOOLS:\n- Terraform: Multi-cloud\n- CloudFormation: AWS\n- Pulumi: Real programming languages\n- Ansible: Configuration management\n- Kubernetes: Container orchestration\n\nBEST PRACTICES:\n- Modular code\n- Environment separation\n- State management\n- Code review\n- Automated testing"
        }
      ]
    },
    {
      "id": "section-14",
      "title": "Databases",
      "blocks": [
        {
          "type": "title",
          "level": 2,
          "content": "Q1. Explain ACID properties in databases?"
        },
        {
          "type": "description",
          "content": "Atomicity: all operations succeed or all fail. Consistency: data remains valid after transaction. Isolation: concurrent transactions don't interfere. Durability: completed transactions persist despite failures. Ensures data integrity in RDBMS. NoSQL databases often trade ACID for performance/scalability (BASE model)."
        },
        {
          "type": "code",
          "language": "sql",
          "title": "ACID Example",
          "code": "-- Atomicity: All or nothing\nBEGIN TRANSACTION;\n  UPDATE accounts SET balance = balance - 100 WHERE id = 1;\n  UPDATE accounts SET balance = balance + 100 WHERE id = 2;\nCOMMIT; -- Both succeed or both fail\n\n-- Isolation: Concurrent transactions don't interfere\n-- Transaction 1:\nBEGIN TRANSACTION;\n  SELECT balance FROM accounts WHERE id = 1; -- 1000\n  -- Another transaction updates balance here\n  UPDATE accounts SET balance = balance - 100 WHERE id = 1;\nCOMMIT;\n\n-- Consistency: Constraints enforced\nCREATE TABLE users (\n  id INT PRIMARY KEY,\n  age INT CHECK (age >= 0 AND age <= 150)\n);\n-- Invalid age throws error\n\n-- Durability: Persists after commit\nCOMMIT; -- Data written to disk, survives crashes"
        },
        {
          "type": "interview-tip",
          "tip": "ACID Properties",
          "explanation": "ATOMICITY:\n- All or nothing\n- Transaction unit\n- Rollback on failure\n\nCONSISTENCY:\n- Valid state always\n- Constraints enforced\n- Integrity maintained\n\nISOLATION:\n- Concurrent transactions\n- Levels: Read Uncommitted, Read Committed, Repeatable Read, Serializable\n- Prevent dirty reads, phantom reads\n\nDURABILITY:\n- Persists on commit\n- Survives crashes\n- Write-ahead logging\n\nVS BASE (NoSQL):\n- Basically Available\n- Soft state\n- Eventual consistency"
        },
        {
          "type": "title",
          "level": 2,
          "content": "Q2. What is database normalization?"
        },
        {
          "type": "description",
          "content": "Normalization organizes data to reduce redundancy and improve integrity. 1NF: atomic values, unique rows. 2NF: no partial dependencies. 3NF: no transitive dependencies. Benefits: less redundancy, easier maintenance. Drawbacks: more joins, potential performance impact. Denormalization trades redundancy for read performance."
        },
        {
          "type": "code",
          "language": "sql",
          "title": "Normalization Example",
          "code": "-- Unnormalized (redundant data)\nCREATE TABLE orders (\n  order_id INT,\n  customer_name VARCHAR(100),\n  customer_email VARCHAR(100),\n  product_name VARCHAR(100),\n  product_price DECIMAL\n);\n-- Customer data repeated for each order!\n\n-- 1NF: Atomic values, no repeating groups\n-- 2NF: Separate customers\nCREATE TABLE customers (\n  customer_id INT PRIMARY KEY,\n  name VARCHAR(100),\n  email VARCHAR(100)\n);\n\n-- 3NF: Separate products\nCREATE TABLE products (\n  product_id INT PRIMARY KEY,\n  name VARCHAR(100),\n  price DECIMAL\n);\n\nCREATE TABLE orders (\n  order_id INT PRIMARY KEY,\n  customer_id INT,\n  product_id INT,\n  FOREIGN KEY (customer_id) REFERENCES customers(customer_id),\n  FOREIGN KEY (product_id) REFERENCES products(product_id)\n);\n\n-- Benefits: No redundancy, easier updates\n-- Drawback: Joins needed for queries"
        },
        {
          "type": "interview-tip",
          "tip": "Normalization",
          "explanation": "NORMAL FORMS:\n1NF:\n- Atomic values\n- No repeating groups\n- Unique rows (primary key)\n\n2NF:\n- 1NF +\n- No partial dependencies\n- Non-key attributes depend on whole key\n\n3NF:\n- 2NF +\n- No transitive dependencies\n- Non-key attributes depend only on key\n\nBENEFITS:\n- Reduced redundancy\n- Data integrity\n- Easier updates\n\nDRAWBACKS:\n- More joins\n- Potential performance impact\n\nDENORMALIZATION:\n- Add redundancy for performance\n- Fewer joins\n- Faster reads, slower writes"
        },
        {
          "type": "title",
          "level": 2,
          "content": "Q3. Explain the difference between SQL and NoSQL databases?"
        },
        {
          "type": "description",
          "content": "SQL: relational, structured schema, ACID, vertical scaling, complex queries (joins). Examples: PostgreSQL, MySQL. NoSQL: non-relational, flexible schema, eventual consistency (often), horizontal scaling, simple queries. Types: Document (MongoDB), Key-Value (Redis), Column (Cassandra), Graph (Neo4j). Choose based on data structure, scale, consistency needs."
        },
        {
          "type": "code",
          "language": "javascript",
          "title": "SQL vs NoSQL Examples",
          "code": "// SQL (PostgreSQL)\nCREATE TABLE users (\n  id SERIAL PRIMARY KEY,\n  name VARCHAR(100),\n  email VARCHAR(100) UNIQUE\n);\n\nSELECT u.name, o.total\nFROM users u\nJOIN orders o ON u.id = o.user_id\nWHERE o.total > 100;\n\n// NoSQL (MongoDB) - Document\ndb.users.insertOne({\n  _id: ObjectId(\"...\"),\n  name: \"Alice\",\n  email: \"alice@example.com\",\n  orders: [\n    { id: 1, total: 150, items: [...] },\n    { id: 2, total: 200, items: [...] }\n  ]\n});\n\n// Query embedded documents\ndb.users.find({\n  \"orders.total\": { $gt: 100 }\n});\n\n// NoSQL (Redis) - Key-Value\nSET user:123:name \"Alice\"\nGET user:123:name\nSETEX session:abc123 3600 \"user_data\" // Expires in 1 hour"
        },
        {
          "type": "interview-tip",
          "tip": "SQL vs NoSQL",
          "explanation": "SQL (Relational):\n- Structured schema\n- ACID transactions\n- Joins, complex queries\n- Vertical scaling\n- Use: Financial, ERP, traditional apps\n- Examples: PostgreSQL, MySQL, Oracle\n\nNOSQL (Non-relational):\n- Flexible schema\n- Eventual consistency (often)\n- Simple queries\n- Horizontal scaling\n- Types:\n  * Document: MongoDB, CouchDB\n  * Key-Value: Redis, DynamoDB\n  * Column: Cassandra, HBase\n  * Graph: Neo4j, ArangoDB\n\nCHOOSE SQL:\n- Structured data\n- Complex relationships\n- ACID requirements\n- Strong consistency\n\nCHOOSE NOSQL:\n- Unstructured/semi-structured data\n- Massive scale\n- High write throughput\n- Flexible schema"
        },
        {
          "type": "title",
          "level": 2,
          "content": "Q4. What is the CAP theorem?"
        },
        {
          "type": "description",
          "content": "CAP states distributed systems can only guarantee 2 of 3: Consistency (all nodes see same data), Availability (every request gets response), Partition tolerance (system continues despite network issues). In practice, partition tolerance is required, so choose between CP (consistency) or AP (availability). MongoDB: CP, Cassandra: AP."
        },
        {
          "type": "code",
          "language": "text",
          "title": "CAP Theorem",
          "code": "CAP Theorem: Choose 2 of 3\n\n┌─────────────────────────────────┐\n│  CONSISTENCY (C)                │\n│  All nodes see same data        │\n│  at same time                   │\n└─────────────────────────────────┘\n         ↙        ↘\n    CP Systems  CA Systems\n    (MongoDB)   (Traditional RDBMS)\n         ↖        ↗\n┌─────────────────────────────────┐\n│  PARTITION TOLERANCE (P)        │\n│  System works despite           │\n│  network partitions             │\n└─────────────────────────────────┘\n         ↙        ↘\n    CP Systems  AP Systems\n               (Cassandra, DynamoDB)\n         ↖        ↗\n┌─────────────────────────────────┐\n│  AVAILABILITY (A)               │\n│  Every request gets response    │\n│  (no guarantees on data)        │\n└─────────────────────────────────┘\n\nREALITY: Must have P (partition tolerance)\nSo really: Choose C or A\n\nCP: Consistency over Availability\n- MongoDB, HBase, Redis\n- Sacrifice availability during partition\n\nAP: Availability over Consistency\n- Cassandra, DynamoDB, CouchDB\n- Sacrifice consistency (eventual)"
        },
        {
          "type": "interview-tip",
          "tip": "CAP Theorem",
          "explanation": "PROPERTIES:\nC (Consistency):\n- All nodes same data\n- Linearizability\n- Strong consistency\n\nA (Availability):\n- Every request responds\n- No timeouts\n- Always accessible\n\nP (Partition Tolerance):\n- Works despite network split\n- Required in distributed systems\n\nTRADEOFFS:\nCP (Consistency + Partition):\n- Reject writes during partition\n- MongoDB, HBase\n- Use: Financial, inventory\n\nAP (Availability + Partition):\n- Accept writes, eventual consistency\n- Cassandra, DynamoDB\n- Use: Social media, analytics\n\nREAL WORLD:\n- P is mandatory\n- Choose C or A based on needs\n- Often tunable per operation"
        }
      ]
    },
    {
      "id": "section-15",
      "title": "Performance Optimization",
      "blocks": [
        {
          "type": "title",
          "level": 2,
          "content": "Q1. Explain Critical Rendering Path?"
        },
        {
          "type": "description",
          "content": "Sequence browser follows to render page: 1) Parse HTML → DOM, 2) Parse CSS → CSSOM, 3) Combine into Render Tree, 4) Layout (calculate positions), 5) Paint (pixels). Optimize: minimize critical resources, reduce file sizes, use async/defer for scripts, inline critical CSS."
        },
        {
          "type": "code",
          "language": "html",
          "title": "Critical Rendering Path Optimization",
          "code": "<!-- 1. Minimize critical resources -->\n<!-- Inline critical CSS -->\n<style>\n  /* Above-the-fold styles */\n  body { margin: 0; font-family: Arial; }\n  .header { height: 60px; background: #333; }\n</style>\n\n<!-- Defer non-critical CSS -->\n<link rel=\"preload\" href=\"styles.css\" as=\"style\"\n      onload=\"this.onload=null;this.rel='stylesheet'\">\n\n<!-- 2. Async/Defer scripts -->\n<script src=\"analytics.js\" async></script>\n<script src=\"app.js\" defer></script>\n\n<!-- 3. Resource hints -->\n<link rel=\"dns-prefetch\" href=\"//cdn.example.com\">\n<link rel=\"preconnect\" href=\"https://api.example.com\">\n\n<!-- 4. Minimize render-blocking -->\n<!-- Bad: blocks rendering -->\n<script src=\"large-library.js\"></script>\n\n<!-- Good: doesn't block -->\n<script src=\"large-library.js\" defer></script>"
        },
        {
          "type": "interview-tip",
          "tip": "Critical Rendering Path",
          "explanation": "STEPS:\n1. Parse HTML → DOM\n2. Parse CSS → CSSOM\n3. DOM + CSSOM → Render Tree\n4. Layout (box model, positions)\n5. Paint (pixels to screen)\n\nOPTIMIZATIONS:\n- Minimize critical resources\n- Reduce file sizes (minify, compress)\n- Inline critical CSS\n- Async/defer non-critical JS\n- Resource hints (dns-prefetch, preconnect)\n- Lazy load below-fold content\n\nMETRICS:\n- First Contentful Paint (FCP)\n- Largest Contentful Paint (LCP)\n- Time to Interactive (TTI)"
        },
        {
          "type": "title",
          "level": 2,
          "content": "Q2. What causes reflow and repaint, and how to minimize?"
        },
        {
          "type": "description",
          "content": "Reflow: browser recalculates layout (adding/removing elements, changing dimensions). Repaint: browser redraws pixels (color changes). Reflow triggers repaint. Minimize: batch DOM changes, use transform/opacity for animations (compositing), avoid forced synchronous layout, use requestAnimationFrame()."
        },
        {
          "type": "code",
          "language": "javascript",
          "title": "Reflow and Repaint",
          "code": "// CAUSES REFLOW (expensive):\nelement.style.width = '100px'; // Geometry change\nelement.classList.add('visible'); // May affect layout\nconst height = element.offsetHeight; // Forces layout calculation\n\n// CAUSES REPAINT (cheaper):\nelement.style.color = 'red'; // Visual change only\nelement.style.backgroundColor = 'blue';\n\n// BAD: Multiple reflows\nelement.style.width = '100px';  // Reflow 1\nelement.style.height = '100px'; // Reflow 2\nelement.style.margin = '10px';  // Reflow 3\n\n// GOOD: Batch changes\nelement.style.cssText = 'width: 100px; height: 100px; margin: 10px';\n// or\nelement.className = 'new-class'; // Single reflow\n\n// BAD: Forced synchronous layout\nfor (let i = 0; i < 100; i++) {\n  element.style.width = i + 'px';\n  const width = element.offsetWidth; // Forces layout each iteration!\n}\n\n// GOOD: Read then write\nconst widths = [];\nfor (let i = 0; i < 100; i++) {\n  widths.push(element.offsetWidth); // Batch reads\n}\nfor (let i = 0; i < 100; i++) {\n  element.style.width = widths[i] + 10 + 'px'; // Batch writes\n}\n\n// BEST: Use transform (no reflow!)\n// Bad: Causes reflow\nelement.style.left = '100px';\n\n// Good: Uses compositing\nelement.style.transform = 'translateX(100px)';\n\n// Animations\n// Bad: Reflows on every frame\nlet pos = 0;\nsetInterval(() => {\n  element.style.left = pos++ + 'px';\n}, 16);\n\n// Good: Uses compositing\nlet pos = 0;\nfunction animate() {\n  element.style.transform = `translateX(${pos++}px)`;\n  requestAnimationFrame(animate);\n}\nrequestAnimationFrame(animate);"
        },
        {
          "type": "interview-tip",
          "tip": "Reflow and Repaint",
          "explanation": "REFLOW (Layout):\n- Geometry changes (width, height, position)\n- Adding/removing elements\n- Changing text content\n- Window resize\n- Expensive (recalculates positions)\n\nREPAINT (Paint):\n- Visual changes only (color, visibility)\n- Follows reflow\n- Cheaper than reflow\n\nMINIMIZE:\n1. Batch DOM changes\n2. Use transform/opacity (compositing)\n3. Avoid forced sync layout\n4. Use requestAnimationFrame()\n5. CSS containment\n6. Virtual scrolling\n\nCOMPOSITING (Best):\n- transform, opacity\n- No reflow or repaint\n- GPU accelerated\n- Smoothest animations"
        },
        {
          "type": "title",
          "level": 2,
          "content": "Q3. Explain different types of caching?"
        },
        {
          "type": "description",
          "content": "Browser: Cache-Control headers, Service Workers. Application: in-memory (Redis, Memcached), HTTP caching. CDN: edge caching for static assets. Database: query results caching. Strategies: Cache-aside, Write-through, Write-behind. Choose based on data volatility, read/write patterns, consistency requirements."
        },
        {
          "type": "code",
          "language": "javascript",
          "title": "Caching Strategies",
          "code": "// 1. HTTP Caching Headers\n// Server response:\nCache-Control: public, max-age=3600\nETag: \"abc123\"\n\n// 2. Service Worker Cache\nself.addEventListener('install', (event) => {\n  event.waitUntil(\n    caches.open('v1').then((cache) => {\n      return cache.addAll([\n        '/styles.css',\n        '/script.js',\n        '/logo.png'\n      ]);\n    })\n  );\n});\n\nself.addEventListener('fetch', (event) => {\n  event.respondWith(\n    caches.match(event.request).then((response) => {\n      return response || fetch(event.request);\n    })\n  );\n});\n\n// 3. In-memory cache (simple)\nconst cache = new Map();\n\nfunction getData(key) {\n  if (cache.has(key)) {\n    return cache.get(key); // Cache hit\n  }\n  \n  const data = expensiveOperation(key);\n  cache.set(key, data);\n  return data;\n}\n\n// 4. Cache with TTL\nclass CacheWithTTL {\n  constructor(ttl = 60000) {\n    this.cache = new Map();\n    this.ttl = ttl;\n  }\n  \n  set(key, value) {\n    this.cache.set(key, {\n      value,\n      expiry: Date.now() + this.ttl\n    });\n  }\n  \n  get(key) {\n    const item = this.cache.get(key);\n    if (!item) return null;\n    \n    if (Date.now() > item.expiry) {\n      this.cache.delete(key);\n      return null; // Expired\n    }\n    \n    return item.value;\n  }\n}\n\n// 5. LRU Cache\nclass LRUCache {\n  constructor(capacity) {\n    this.capacity = capacity;\n    this.cache = new Map();\n  }\n  \n  get(key) {\n    if (!this.cache.has(key)) return null;\n    \n    // Move to end (most recently used)\n    const value = this.cache.get(key);\n    this.cache.delete(key);\n    this.cache.set(key, value);\n    return value;\n  }\n  \n  set(key, value) {\n    if (this.cache.has(key)) {\n      this.cache.delete(key);\n    }\n    \n    this.cache.set(key, value);\n    \n    // Evict least recently used if over capacity\n    if (this.cache.size > this.capacity) {\n      const firstKey = this.cache.keys().next().value;\n      this.cache.delete(firstKey);\n    }\n  }\n}"
        },
        {
          "type": "interview-tip",
          "tip": "Caching Types",
          "explanation": "BROWSER:\n- HTTP headers (Cache-Control, ETag)\n- Service Workers\n- LocalStorage (small data)\n\nAPPLICATION:\n- In-memory (Redis, Memcached)\n- HTTP caching\n- CDN (static assets)\n\nSTRATEGIES:\n1. Cache-aside: App checks cache, loads on miss\n2. Write-through: Write to cache + DB\n3. Write-behind: Write to cache, async to DB\n4. Read-through: Cache loads data on miss\n\nEVICTION:\n- LRU (Least Recently Used)\n- LFU (Least Frequently Used)\n- TTL (Time To Live)\n- FIFO (First In First Out)\n\nCONSIDERATIONS:\n- Invalidation strategy\n- Data volatility\n- Memory limits\n- Consistency needs"
        },
        {
          "type": "title",
          "level": 2,
          "content": "Q4. What are Web Workers and when to use them?"
        },
        {
          "type": "description",
          "content": "Web Workers run JavaScript in background threads, don't block UI. Use for: heavy computations, data processing, real-time features. Communication via postMessage(). Types: Dedicated (single page), Shared (multiple pages), Service Workers (PWA features). Limitations: no DOM access, separate scope."
        },
        {
          "type": "code",
          "language": "javascript",
          "title": "Web Workers",
          "code": "// Main thread (app.js)\nconst worker = new Worker('worker.js');\n\n// Send data to worker\nworker.postMessage({\n  type: 'PROCESS_DATA',\n  data: largeDataArray\n});\n\n// Receive result from worker\nworker.onmessage = (event) => {\n  const result = event.data;\n  updateUI(result);\n};\n\nworker.onerror = (error) => {\n  console.error('Worker error:', error);\n};\n\n// Worker thread (worker.js)\nself.onmessage = (event) => {\n  const { type, data } = event.data;\n  \n  if (type === 'PROCESS_DATA') {\n    // Heavy computation (doesn't block UI)\n    const result = data.map(item => {\n      return expensiveCalculation(item);\n    });\n    \n    // Send result back to main thread\n    self.postMessage(result);\n  }\n};\n\nfunction expensiveCalculation(item) {\n  let sum = 0;\n  for (let i = 0; i < 1000000; i++) {\n    sum += Math.sqrt(item * i);\n  }\n  return sum;\n}\n\n// Real-world example: Image processing\n// worker.js\nself.onmessage = (event) => {\n  const imageData = event.data;\n  const pixels = imageData.data;\n  \n  // Apply grayscale filter\n  for (let i = 0; i < pixels.length; i += 4) {\n    const avg = (pixels[i] + pixels[i + 1] + pixels[i + 2]) / 3;\n    pixels[i] = pixels[i + 1] = pixels[i + 2] = avg;\n  }\n  \n  self.postMessage(imageData);\n};\n\n// Shared Worker (multiple pages)\n// shared-worker.js\nconst connections = [];\n\nself.onconnect = (event) => {\n  const port = event.ports[0];\n  connections.push(port);\n  \n  port.onmessage = (e) => {\n    // Broadcast to all connected pages\n    connections.forEach(p => p.postMessage(e.data));\n  };\n};\n\n// Using shared worker\nconst sharedWorker = new SharedWorker('shared-worker.js');\nsharedWorker.port.postMessage('Hello');\nsharedWorker.port.onmessage = (e) => {\n  console.log('Received:', e.data);\n};"
        },
        {
          "type": "interview-tip",
          "tip": "Web Workers",
          "explanation": "TYPES:\n1. Dedicated Worker:\n   - Single page/script\n   - new Worker('worker.js')\n   \n2. Shared Worker:\n   - Multiple pages/tabs\n   - new SharedWorker('worker.js')\n   \n3. Service Worker:\n   - PWA features\n   - Offline, push notifications\n\nUSE CASES:\n- Heavy computations\n- Large data processing\n- Real-time data parsing\n- Image/video processing\n- Encryption/decryption\n- Background sync\n\nLIMITATIONS:\n- No DOM access\n- No window object\n- Separate global scope\n- Communication overhead\n\nBEST PRACTICES:\n- Offload CPU-intensive tasks\n- Keep data transfer minimal\n- Use Transferable Objects for large data\n- Terminate when done"
        }
      ]
    }
  ]
}