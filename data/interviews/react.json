{
  "id": "react-redux-complete",
  "title": "Complete React & Redux Interview Preparation",
  "description": "The ultimate guide to master React and Redux interview concepts - from fundamentals to advanced patterns, with code examples, diagrams, and interview tips",
  "difficulty": "beginner-to-advanced",
  "estimatedTime": "15-20 hours",
  "sections": [
    {
      "id": "section-1",
      "title": "React Fundamentals",
      "blocks": [
        {
          "type": "title",
          "level": 1,
          "content": "What is React?"
        },
        {
          "type": "description",
          "content": "React is an open-source JavaScript library developed by Facebook (now Meta) for building user interfaces, particularly single-page applications. It allows developers to create reusable UI components and manage the view layer of web and mobile applications efficiently."
        },
        {
          "type": "code",
          "language": "javascript",
          "title": "First React Component",
          "code": "import React from 'react';\n\nfunction App() {\n  return (\n    <div>\n      <h1>Hello, React!</h1>\n      <p>Welcome to React development</p>\n    </div>\n  );\n}\n\nexport default App;"
        },
        {
          "type": "interview-tip",
          "tip": "Key Points to Mention About React",
          "explanation": "1. Component-based architecture for reusability\n2. Virtual DOM for performance optimization\n3. Unidirectional data flow for predictable state management\n4. Declarative approach - describe what you want, not how\n5. Large ecosystem with extensive community support\n6. Can be used for web (ReactDOM) and mobile (React Native)"
        },
        {
          "type": "title",
          "level": 2,
          "content": "React vs Other Frameworks"
        },
        {
          "type": "description",
          "content": "React is a library focused on the view layer, while Angular and Vue are full frameworks. React provides flexibility in choosing additional tools but requires more decisions from developers."
        },
        {
          "type": "code",
          "language": "text",
          "title": "Comparison Chart",
          "code": "┌─────────────────┬──────────────┬──────────────┬──────────────┐\n│ Feature         │ React        │ Angular      │ Vue          │\n├─────────────────┼──────────────┼──────────────┼──────────────┤\n│ Type            │ Library      │ Framework    │ Framework    │\n│ Data Binding    │ One-way      │ Two-way      │ Two-way      │\n│ DOM             │ Virtual      │ Real + Change│ Virtual      │\n│ Architecture    │ Component    │ MVC          │ Component    │\n│ Learning Curve  │ Moderate     │ Steep        │ Easy         │\n│ Size            │ ~42KB        │ ~500KB       │ ~80KB        │\n│ Language        │ JSX          │ TypeScript   │ Template     │\n└─────────────────┴──────────────┴──────────────┴──────────────┘"
        },
        {
          "type": "title",
          "level": 2,
          "content": "JSX - JavaScript XML"
        },
        {
          "type": "description",
          "content": "JSX is a syntax extension for JavaScript that looks similar to HTML/XML. It allows you to write HTML-like code in your JavaScript files, which gets compiled to React.createElement() calls by Babel. JSX is not required to use React, but it makes the code more readable and intuitive."
        },
        {
          "type": "code",
          "language": "javascript",
          "title": "JSX Compilation Process",
          "code": "// What you write (JSX)\nconst element = (\n  <div className=\"container\">\n    <h1>Hello, {userName}!</h1>\n    <button onClick={handleClick}>Click Me</button>\n  </div>\n);\n\n// What Babel compiles it to (JavaScript)\nconst element = React.createElement(\n  'div',\n  { className: 'container' },\n  React.createElement('h1', null, 'Hello, ', userName, '!'),\n  React.createElement('button', { onClick: handleClick }, 'Click Me')\n);\n\n// React 17+ with new JSX Transform\nimport { jsx as _jsx } from 'react/jsx-runtime';\nconst element = _jsx('div', {\n  className: 'container',\n  children: [\n    _jsx('h1', { children: ['Hello, ', userName, '!'] }),\n    _jsx('button', { onClick: handleClick, children: 'Click Me' })\n  ]\n});"
        },
        {
          "type": "interview-tip",
          "tip": "JSX Rules You Must Know",
          "explanation": "1. Return single root element (use Fragment <> </> or div)\n2. Close all tags including self-closing (<img />, <br />)\n3. Use camelCase for attributes (className, onClick, htmlFor)\n4. JavaScript expressions go in curly braces {}\n5. Inline styles use objects: style={{ color: 'red' }}\n6. Comments use {/* comment */}\n7. Can't use 'class' - use 'className'\n8. Can't use 'for' - use 'htmlFor'"
        },
        {
          "type": "code",
          "language": "javascript",
          "title": "JSX Rules & Best Practices",
          "code": "function JSXExamples() {\n  const items = ['Apple', 'Banana', 'Cherry'];\n  const isLoggedIn = true;\n  const style = { color: 'blue', fontSize: '20px' };\n\n  return (\n    // Rule 1: Single root element\n    <>\n      {/* Rule 6: Comments syntax */}\n      \n      {/* Rule 3: camelCase attributes */}\n      <label htmlFor=\"name\" className=\"label\">\n        Name:\n      </label>\n      <input id=\"name\" type=\"text\" />\n      \n      {/* Rule 5: Inline styles as objects */}\n      <p style={style}>Styled text</p>\n      <p style={{ backgroundColor: 'yellow' }}>Another style</p>\n      \n      {/* Rule 4: JavaScript expressions in curly braces */}\n      <p>2 + 2 = {2 + 2}</p>\n      \n      {/* Conditional rendering */}\n      {isLoggedIn && <p>Welcome back!</p>}\n      {isLoggedIn ? <LogoutButton /> : <LoginButton />}\n      \n      {/* Rendering lists */}\n      <ul>\n        {items.map((item, index) => (\n          <li key={index}>{item}</li>\n        ))}\n      </ul>\n      \n      {/* Rule 2: Self-closing tags */}\n      <img src=\"logo.png\" alt=\"Logo\" />\n      <br />\n      <hr />\n    </>\n  );\n}"
        },
        {
          "type": "title",
          "level": 2,
          "content": "Virtual DOM"
        },
        {
          "type": "description",
          "content": "The Virtual DOM is a lightweight JavaScript representation of the actual DOM. When state changes, React creates a new Virtual DOM tree, compares it with the previous one (diffing), and updates only the changed parts in the real DOM (reconciliation). This makes updates efficient."
        },
        {
          "type": "code",
          "language": "text",
          "title": "Virtual DOM Process",
          "code": "┌─────────────────────────────────────────────────────────────────┐\n│                    VIRTUAL DOM PROCESS                          │\n├─────────────────────────────────────────────────────────────────┤\n│                                                                 │\n│   1. STATE CHANGE                                               │\n│      setState({ count: 1 })                                     │\n│              │                                                  │\n│              ▼                                                  │\n│   2. CREATE NEW VIRTUAL DOM                                     │\n│      ┌─────────────┐    ┌─────────────┐                        │\n│      │   Old VDOM  │    │   New VDOM  │                        │\n│      │  count: 0   │    │  count: 1   │                        │\n│      └─────────────┘    └─────────────┘                        │\n│              │                │                                 │\n│              └────────┬───────┘                                 │\n│                       ▼                                         │\n│   3. DIFFING (Reconciliation)                                   │\n│      Compare old and new VDOM trees                             │\n│      Find minimal set of changes                                │\n│                       │                                         │\n│                       ▼                                         │\n│   4. BATCH UPDATE REAL DOM                                      │\n│      Only update what changed                                   │\n│      Real DOM: <span>1</span>                                   │\n│                                                                 │\n└─────────────────────────────────────────────────────────────────┘"
        },
        {
          "type": "interview-tip",
          "tip": "Why Virtual DOM is Faster",
          "explanation": "Direct DOM manipulation is slow because:\n1. Browser recalculates CSS, layouts, and repaints\n2. Each manipulation can trigger reflow\n\nVirtual DOM is faster because:\n1. JavaScript object operations are fast\n2. Batches multiple changes together\n3. Minimizes actual DOM manipulations\n4. Uses efficient diffing algorithm (O(n) complexity)"
        },
        {
          "type": "title",
          "level": 2,
          "content": "React Fiber Architecture"
        },
        {
          "type": "description",
          "content": "React Fiber is the reconciliation engine introduced in React 16. It's a complete rewrite of the core algorithm that enables incremental rendering - the ability to split rendering work into chunks and spread it over multiple frames."
        },
        {
          "type": "code",
          "language": "text",
          "title": "Fiber Architecture Explained",
          "code": "┌─────────────────────────────────────────────────────────────────┐\n│                    REACT FIBER ARCHITECTURE                     │\n├─────────────────────────────────────────────────────────────────┤\n│                                                                 │\n│  OLD RECONCILER (Stack)          NEW RECONCILER (Fiber)        │\n│  ─────────────────────           ─────────────────────          │\n│  • Synchronous                   • Asynchronous                 │\n│  • Can't be interrupted          • Can pause and resume         │\n│  • Blocks main thread            • Doesn't block UI             │\n│  • No prioritization             • Priority-based updates       │\n│                                                                 │\n│  FIBER NODE STRUCTURE:                                          │\n│  ┌──────────────────────────────────────────────────────┐      │\n│  │  {                                                    │      │\n│  │    type: 'div',           // Element type            │      │\n│  │    key: null,             // Unique identifier       │      │\n│  │    stateNode: DOMNode,    // Reference to DOM        │      │\n│  │    child: Fiber,          // First child             │      │\n│  │    sibling: Fiber,        // Next sibling            │      │\n│  │    return: Fiber,         // Parent fiber            │      │\n│  │    pendingProps: {},      // New props               │      │\n│  │    memoizedProps: {},     // Props used to create    │      │\n│  │    memoizedState: {},     // State used to create    │      │\n│  │    updateQueue: [],       // State updates queue     │      │\n│  │    effectTag: 'PLACEMENT' // Side effect type        │      │\n│  │  }                                                    │      │\n│  └──────────────────────────────────────────────────────┘      │\n│                                                                 │\n│  TWO PHASES:                                                    │\n│  1. RENDER PHASE (Interruptible)                               │\n│     - Creates Fiber tree                                        │\n│     - Marks effects                                             │\n│     - Can be paused/resumed                                     │\n│                                                                 │\n│  2. COMMIT PHASE (Not Interruptible)                           │\n│     - Applies changes to DOM                                    │\n│     - Runs lifecycle methods                                    │\n│     - Must complete in one go                                   │\n│                                                                 │\n└─────────────────────────────────────────────────────────────────┘"
        },
        {
          "type": "interview-tip",
          "tip": "Fiber Key Benefits",
          "explanation": "1. Ability to pause, abort, or reuse work\n2. Assign priority to different types of updates\n3. Concurrent rendering (React 18+)\n4. Better error handling with error boundaries\n5. Support for fragments and portals\n6. Smoother UI with time-slicing"
        },
        {
          "type": "title",
          "level": 2,
          "content": "Reconciliation Algorithm"
        },
        {
          "type": "description",
          "content": "Reconciliation is the process React uses to determine what changes need to be made to the DOM. It compares the new Virtual DOM with the previous one using a diffing algorithm based on two assumptions: elements of different types produce different trees, and keys help identify stable elements across renders."
        },
        {
          "type": "code",
          "language": "javascript",
          "title": "Reconciliation Rules",
          "code": "// Rule 1: Different element types = rebuild entire subtree\n// Before\n<div>\n  <Counter />\n</div>\n\n// After - Counter is unmounted and remounted!\n<span>\n  <Counter />\n</span>\n\n// Rule 2: Same element type = update attributes only\n// Before\n<div className=\"before\" title=\"stuff\" />\n\n// After - only className is updated\n<div className=\"after\" title=\"stuff\" />\n\n// Rule 3: Keys identify elements in lists\nfunction TodoList({ todos }) {\n  return (\n    <ul>\n      {todos.map(todo => (\n        // Key helps React identify which items changed\n        <li key={todo.id}>{todo.text}</li>\n      ))}\n    </ul>\n  );\n}\n\n// BAD: Using index as key (causes issues with reordering)\n{items.map((item, index) => (\n  <li key={index}>{item}</li> // ❌ Avoid when list can reorder\n))}\n\n// GOOD: Using unique ID\n{items.map(item => (\n  <li key={item.id}>{item}</li> // ✅ Stable identity\n))}"
        },
        {
          "type": "interview-tip",
          "tip": "Why Keys Are Important",
          "explanation": "Without keys or with index keys:\n1. React can't identify moved items\n2. Component state gets mixed up\n3. Unnecessary DOM operations occur\n4. Input fields lose focus during reorder\n\nUse stable, unique IDs (database IDs, UUIDs) as keys. Only use index as key when: list is static, items have no IDs, and list will never be reordered or filtered."
        }
      ]
    },
    {
      "id": "section-2",
      "title": "Components Deep Dive",
      "blocks": [
        {
          "type": "title",
          "level": 1,
          "content": "Functional vs Class Components"
        },
        {
          "type": "description",
          "content": "React supports two types of components. Functional components are JavaScript functions that accept props and return JSX. Class components extend React.Component and use a render method. Since React 16.8 introduced Hooks, functional components are the modern standard."
        },
        {
          "type": "code",
          "language": "javascript",
          "title": "Component Comparison",
          "code": "// FUNCTIONAL COMPONENT (Modern - Recommended)\nimport { useState, useEffect } from 'react';\n\nfunction UserProfile({ userId }) {\n  const [user, setUser] = useState(null);\n  const [loading, setLoading] = useState(true);\n\n  useEffect(() => {\n    fetchUser(userId).then(data => {\n      setUser(data);\n      setLoading(false);\n    });\n  }, [userId]);\n\n  if (loading) return <div>Loading...</div>;\n  return <div>Hello, {user.name}!</div>;\n}\n\n// CLASS COMPONENT (Legacy)\nimport React, { Component } from 'react';\n\nclass UserProfile extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      user: null,\n      loading: true\n    };\n  }\n\n  componentDidMount() {\n    this.fetchUser();\n  }\n\n  componentDidUpdate(prevProps) {\n    if (prevProps.userId !== this.props.userId) {\n      this.fetchUser();\n    }\n  }\n\n  fetchUser = () => {\n    fetchUser(this.props.userId).then(data => {\n      this.setState({ user: data, loading: false });\n    });\n  };\n\n  render() {\n    if (this.state.loading) return <div>Loading...</div>;\n    return <div>Hello, {this.state.user.name}!</div>;\n  }\n}"
        },
        {
          "type": "code",
          "language": "text",
          "title": "Functional vs Class Components Comparison",
          "code": "┌────────────────────┬─────────────────────┬─────────────────────┐\n│ Feature            │ Functional          │ Class               │\n├────────────────────┼─────────────────────┼─────────────────────┤\n│ Syntax             │ Plain function      │ ES6 class           │\n│ State              │ useState hook       │ this.state          │\n│ Lifecycle          │ useEffect           │ Lifecycle methods   │\n│ 'this' keyword     │ Not needed          │ Required            │\n│ Boilerplate        │ Less                │ More                │\n│ Performance        │ Slightly better     │ Slightly heavier    │\n│ Code reuse         │ Custom Hooks        │ HOC/Render Props    │\n│ Bundle size        │ Smaller             │ Larger              │\n│ Learning curve     │ Easier              │ Steeper             │\n│ Testing            │ Easier              │ More complex        │\n│ Error Boundaries   │ ❌ Not supported    │ ✅ Supported        │\n│ getSnapshotBefore  │ ❌ No equivalent    │ ✅ Supported        │\n└────────────────────┴─────────────────────┴─────────────────────┘"
        },
        {
          "type": "interview-tip",
          "tip": "When to Use Class Components",
          "explanation": "Use class components only for:\n1. Error Boundaries (currently no hook equivalent)\n2. getSnapshotBeforeUpdate lifecycle method\n3. Legacy codebases that haven't migrated\n\nFor everything else, use functional components with hooks. They're simpler, more readable, and easier to test."
        },
        {
          "type": "title",
          "level": 2,
          "content": "Pure Components & React.memo"
        },
        {
          "type": "description",
          "content": "Pure Components perform a shallow comparison of props and state to determine if re-rendering is necessary. In functional components, React.memo provides equivalent functionality by memoizing the component and only re-rendering when props change."
        },
        {
          "type": "code",
          "language": "javascript",
          "title": "Pure Components Implementation",
          "code": "// CLASS: PureComponent (shallow comparison automatically)\nimport React, { PureComponent } from 'react';\n\nclass PureButton extends PureComponent {\n  render() {\n    console.log('PureButton rendered');\n    return <button onClick={this.props.onClick}>{this.props.label}</button>;\n  }\n}\n\n// FUNCTIONAL: React.memo (recommended)\nconst MemoizedButton = React.memo(function Button({ onClick, label }) {\n  console.log('MemoizedButton rendered');\n  return <button onClick={onClick}>{label}</button>;\n});\n\n// With custom comparison function\nconst MemoizedUser = React.memo(\n  function User({ user, onSelect }) {\n    console.log('User rendered:', user.name);\n    return (\n      <div onClick={() => onSelect(user.id)}>\n        {user.name} - {user.email}\n      </div>\n    );\n  },\n  // Custom comparison: only re-render if user.id changes\n  (prevProps, nextProps) => {\n    return prevProps.user.id === nextProps.user.id;\n  }\n);\n\n// Usage Example\nfunction App() {\n  const [count, setCount] = useState(0);\n  const [text, setText] = useState('');\n\n  // This function creates new reference on every render\n  // MemoizedButton will still re-render!\n  const handleClick = () => console.log('clicked');\n\n  // Fix: Use useCallback to maintain reference\n  const handleClickMemoized = useCallback(() => {\n    console.log('clicked');\n  }, []);\n\n  return (\n    <div>\n      <input value={text} onChange={(e) => setText(e.target.value)} />\n      <button onClick={() => setCount(count + 1)}>Count: {count}</button>\n      \n      {/* Re-renders on every App render because onClick is new */}\n      <MemoizedButton onClick={handleClick} label=\"Bad\" />\n      \n      {/* Only re-renders when label changes */}\n      <MemoizedButton onClick={handleClickMemoized} label=\"Good\" />\n    </div>\n  );\n}"
        },
        {
          "type": "interview-tip",
          "tip": "React.memo Gotchas",
          "explanation": "1. Only does shallow comparison - nested objects/arrays cause re-renders\n2. Inline functions/objects in props defeat memoization\n3. Use with useCallback and useMemo for best results\n4. Don't overuse - adds comparison overhead\n5. Profile first, optimize second\n6. Children prop always changes unless memoized"
        },
        {
          "type": "title",
          "level": 2,
          "content": "Controlled vs Uncontrolled Components"
        },
        {
          "type": "description",
          "content": "Controlled components have their state controlled by React through props and event handlers. Uncontrolled components store their own state internally and you access values using refs. Controlled components are preferred as they provide single source of truth."
        },
        {
          "type": "code",
          "language": "javascript",
          "title": "Controlled vs Uncontrolled Forms",
          "code": "import { useState, useRef } from 'react';\n\n// CONTROLLED COMPONENT\n// React controls the input value\nfunction ControlledForm() {\n  const [formData, setFormData] = useState({\n    username: '',\n    email: '',\n    password: ''\n  });\n\n  const handleChange = (e) => {\n    const { name, value } = e.target;\n    setFormData(prev => ({\n      ...prev,\n      [name]: value\n    }));\n  };\n\n  const handleSubmit = (e) => {\n    e.preventDefault();\n    console.log('Submitting:', formData);\n  };\n\n  return (\n    <form onSubmit={handleSubmit}>\n      <input\n        name=\"username\"\n        value={formData.username}       // Controlled by state\n        onChange={handleChange}          // Updates state on change\n        placeholder=\"Username\"\n      />\n      <input\n        name=\"email\"\n        type=\"email\"\n        value={formData.email}\n        onChange={handleChange}\n        placeholder=\"Email\"\n      />\n      <input\n        name=\"password\"\n        type=\"password\"\n        value={formData.password}\n        onChange={handleChange}\n        placeholder=\"Password\"\n      />\n      <button type=\"submit\">Submit</button>\n    </form>\n  );\n}\n\n// UNCONTROLLED COMPONENT\n// DOM controls the input value\nfunction UncontrolledForm() {\n  const usernameRef = useRef(null);\n  const emailRef = useRef(null);\n  const passwordRef = useRef(null);\n\n  const handleSubmit = (e) => {\n    e.preventDefault();\n    console.log('Submitting:', {\n      username: usernameRef.current.value,\n      email: emailRef.current.value,\n      password: passwordRef.current.value\n    });\n  };\n\n  return (\n    <form onSubmit={handleSubmit}>\n      <input\n        ref={usernameRef}\n        defaultValue=\"\"               // Initial value, not controlled\n        placeholder=\"Username\"\n      />\n      <input\n        ref={emailRef}\n        type=\"email\"\n        defaultValue=\"\"\n        placeholder=\"Email\"\n      />\n      <input\n        ref={passwordRef}\n        type=\"password\"\n        defaultValue=\"\"\n        placeholder=\"Password\"\n      />\n      <button type=\"submit\">Submit</button>\n    </form>\n  );\n}"
        },
        {
          "type": "code",
          "language": "text",
          "title": "Controlled vs Uncontrolled Comparison",
          "code": "┌────────────────────┬─────────────────────┬─────────────────────┐\n│ Feature            │ Controlled          │ Uncontrolled        │\n├────────────────────┼─────────────────────┼─────────────────────┤\n│ Data management    │ React state         │ DOM (refs)          │\n│ Value access       │ Immediate           │ On demand           │\n│ Validation         │ On every change     │ On submit           │\n│ Conditional disable│ Easy                │ Complex             │\n│ Dynamic inputs     │ Easy                │ Complex             │\n│ Performance        │ More re-renders     │ Fewer re-renders    │\n│ Form libraries     │ Works great         │ Limited support     │\n│ Use case           │ Complex forms       │ Simple forms        │\n│ File input         │ ❌ Cannot control   │ ✅ Must use refs    │\n└────────────────────┴─────────────────────┴─────────────────────┘\n\nWhen to use Uncontrolled:\n• File inputs (cannot be controlled)\n• Integration with non-React code\n• Performance-critical simple forms\n• One-time value submission"
        },
        {
          "type": "title",
          "level": 2,
          "content": "Higher-Order Components (HOC)"
        },
        {
          "type": "description",
          "content": "A Higher-Order Component is a function that takes a component and returns a new enhanced component. It's a pattern for reusing component logic. HOCs don't modify the input component; they compose it by wrapping it."
        },
        {
          "type": "code",
          "language": "javascript",
          "title": "Higher-Order Component Patterns",
          "code": "// Basic HOC Structure\nfunction withEnhancement(WrappedComponent) {\n  return function EnhancedComponent(props) {\n    // Add extra functionality\n    return <WrappedComponent {...props} />;\n  };\n}\n\n// Practical Example: withLoading HOC\nfunction withLoading(WrappedComponent) {\n  return function WithLoadingComponent({ isLoading, ...props }) {\n    if (isLoading) {\n      return <div className=\"loading-spinner\">Loading...</div>;\n    }\n    return <WrappedComponent {...props} />;\n  };\n}\n\n// Usage\nconst UserListWithLoading = withLoading(UserList);\n<UserListWithLoading isLoading={loading} users={users} />\n\n// withAuthentication HOC\nfunction withAuth(WrappedComponent) {\n  return function AuthenticatedComponent(props) {\n    const { isAuthenticated, user } = useAuth();\n    \n    if (!isAuthenticated) {\n      return <Navigate to=\"/login\" />;\n    }\n    \n    return <WrappedComponent {...props} user={user} />;\n  };\n}\n\n// withLogger HOC - logs props changes\nfunction withLogger(WrappedComponent) {\n  return function LoggerComponent(props) {\n    useEffect(() => {\n      console.log('Component rendered with props:', props);\n    });\n    \n    return <WrappedComponent {...props} />;\n  };\n}\n\n// withErrorBoundary HOC\nfunction withErrorBoundary(WrappedComponent, FallbackComponent) {\n  return class extends React.Component {\n    state = { hasError: false };\n    \n    static getDerivedStateFromError(error) {\n      return { hasError: true };\n    }\n    \n    render() {\n      if (this.state.hasError) {\n        return <FallbackComponent />;\n      }\n      return <WrappedComponent {...this.props} />;\n    }\n  };\n}\n\n// Composing multiple HOCs\nconst enhance = compose(\n  withAuth,\n  withLoading,\n  withLogger\n);\nconst EnhancedDashboard = enhance(Dashboard);\n\n// Manual composition\nconst EnhancedDashboard = withAuth(withLoading(withLogger(Dashboard)));"
        },
        {
          "type": "interview-tip",
          "tip": "HOC Best Practices",
          "explanation": "1. Don't mutate the original component\n2. Pass through unrelated props\n3. Use displayName for debugging\n4. Don't use HOCs inside render method\n5. Copy over static methods\n6. Refs aren't passed through (use forwardRef)\n\nNote: Custom Hooks are now preferred over HOCs for sharing logic. HOCs are still useful for cross-cutting concerns like auth, logging, and error handling."
        },
        {
          "type": "title",
          "level": 2,
          "content": "Render Props Pattern"
        },
        {
          "type": "description",
          "content": "Render Props is a pattern where a component receives a function as a prop (or children) that returns a React element. This allows sharing code between components using a prop whose value is a function."
        },
        {
          "type": "code",
          "language": "javascript",
          "title": "Render Props Examples",
          "code": "// Basic Render Props Pattern\nfunction MouseTracker({ render }) {\n  const [position, setPosition] = useState({ x: 0, y: 0 });\n\n  const handleMouseMove = (event) => {\n    setPosition({\n      x: event.clientX,\n      y: event.clientY\n    });\n  };\n\n  return (\n    <div style={{ height: '100vh' }} onMouseMove={handleMouseMove}>\n      {render(position)}\n    </div>\n  );\n}\n\n// Usage\nfunction App() {\n  return (\n    <MouseTracker\n      render={({ x, y }) => (\n        <h1>Mouse position: ({x}, {y})</h1>\n      )}\n    />\n  );\n}\n\n// Using children as a function\nfunction MouseTracker({ children }) {\n  const [position, setPosition] = useState({ x: 0, y: 0 });\n\n  const handleMouseMove = (event) => {\n    setPosition({ x: event.clientX, y: event.clientY });\n  };\n\n  return (\n    <div style={{ height: '100vh' }} onMouseMove={handleMouseMove}>\n      {children(position)}\n    </div>\n  );\n}\n\n// Usage with children\n<MouseTracker>\n  {({ x, y }) => <p>The cursor is at ({x}, {y})</p>}\n</MouseTracker>\n\n// Practical Example: Toggle component\nfunction Toggle({ children }) {\n  const [on, setOn] = useState(false);\n  const toggle = () => setOn(!on);\n  \n  return children({ on, toggle });\n}\n\n// Usage\n<Toggle>\n  {({ on, toggle }) => (\n    <div>\n      <button onClick={toggle}>{on ? 'Hide' : 'Show'}</button>\n      {on && <p>Secret content!</p>}\n    </div>\n  )}\n</Toggle>\n\n// Data Fetcher with Render Props\nfunction DataFetcher({ url, children }) {\n  const [data, setData] = useState(null);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState(null);\n\n  useEffect(() => {\n    fetch(url)\n      .then(res => res.json())\n      .then(data => {\n        setData(data);\n        setLoading(false);\n      })\n      .catch(err => {\n        setError(err);\n        setLoading(false);\n      });\n  }, [url]);\n\n  return children({ data, loading, error });\n}\n\n// Usage\n<DataFetcher url=\"/api/users\">\n  {({ data, loading, error }) => {\n    if (loading) return <Spinner />;\n    if (error) return <Error message={error.message} />;\n    return <UserList users={data} />;\n  }}\n</DataFetcher>"
        },
        {
          "type": "interview-tip",
          "tip": "Render Props vs Custom Hooks",
          "explanation": "Render Props were popular before Hooks. Now Custom Hooks are preferred because:\n1. No wrapper component hell\n2. Cleaner syntax\n3. Easier to compose\n4. Better TypeScript support\n\nRender Props are still useful for:\n1. Libraries that need flexibility\n2. Animation components\n3. When you need to conditionally render different UIs"
        },
        {
          "type": "title",
          "level": 2,
          "content": "Compound Components Pattern"
        },
        {
          "type": "description",
          "content": "Compound Components is a pattern where components work together to form a complete UI. The parent component manages state and shares it implicitly with children through Context. This pattern provides flexibility while maintaining a clean API."
        },
        {
          "type": "code",
          "language": "javascript",
          "title": "Compound Components Implementation",
          "code": "import { createContext, useContext, useState } from 'react';\n\n// Create context for sharing state\nconst TabsContext = createContext();\n\n// Parent Component\nfunction Tabs({ children, defaultTab = 0 }) {\n  const [activeTab, setActiveTab] = useState(defaultTab);\n  \n  return (\n    <TabsContext.Provider value={{ activeTab, setActiveTab }}>\n      <div className=\"tabs\">{children}</div>\n    </TabsContext.Provider>\n  );\n}\n\n// Child Components\nfunction TabList({ children }) {\n  return <div className=\"tab-list\">{children}</div>;\n}\n\nfunction Tab({ index, children }) {\n  const { activeTab, setActiveTab } = useContext(TabsContext);\n  \n  return (\n    <button\n      className={`tab ${activeTab === index ? 'active' : ''}`}\n      onClick={() => setActiveTab(index)}\n    >\n      {children}\n    </button>\n  );\n}\n\nfunction TabPanels({ children }) {\n  return <div className=\"tab-panels\">{children}</div>;\n}\n\nfunction TabPanel({ index, children }) {\n  const { activeTab } = useContext(TabsContext);\n  \n  if (activeTab !== index) return null;\n  return <div className=\"tab-panel\">{children}</div>;\n}\n\n// Attach children to parent for cleaner API\nTabs.TabList = TabList;\nTabs.Tab = Tab;\nTabs.TabPanels = TabPanels;\nTabs.TabPanel = TabPanel;\n\n// Usage\nfunction App() {\n  return (\n    <Tabs defaultTab={0}>\n      <Tabs.TabList>\n        <Tabs.Tab index={0}>Profile</Tabs.Tab>\n        <Tabs.Tab index={1}>Settings</Tabs.Tab>\n        <Tabs.Tab index={2}>Notifications</Tabs.Tab>\n      </Tabs.TabList>\n      \n      <Tabs.TabPanels>\n        <Tabs.TabPanel index={0}>\n          <h2>Profile Content</h2>\n        </Tabs.TabPanel>\n        <Tabs.TabPanel index={1}>\n          <h2>Settings Content</h2>\n        </Tabs.TabPanel>\n        <Tabs.TabPanel index={2}>\n          <h2>Notifications Content</h2>\n        </Tabs.TabPanel>\n      </Tabs.TabPanels>\n    </Tabs>\n  );\n}\n\n// Another Example: Accordion Component\nconst AccordionContext = createContext();\n\nfunction Accordion({ children, allowMultiple = false }) {\n  const [openItems, setOpenItems] = useState([]);\n  \n  const toggleItem = (id) => {\n    if (allowMultiple) {\n      setOpenItems(prev =>\n        prev.includes(id) ? prev.filter(i => i !== id) : [...prev, id]\n      );\n    } else {\n      setOpenItems(prev => prev.includes(id) ? [] : [id]);\n    }\n  };\n  \n  const isOpen = (id) => openItems.includes(id);\n  \n  return (\n    <AccordionContext.Provider value={{ toggleItem, isOpen }}>\n      <div className=\"accordion\">{children}</div>\n    </AccordionContext.Provider>\n  );\n}\n\nfunction AccordionItem({ id, children }) {\n  return <div className=\"accordion-item\">{children}</div>;\n}\n\nfunction AccordionButton({ id, children }) {\n  const { toggleItem, isOpen } = useContext(AccordionContext);\n  \n  return (\n    <button onClick={() => toggleItem(id)}>\n      {children} {isOpen(id) ? '▲' : '▼'}\n    </button>\n  );\n}\n\nfunction AccordionPanel({ id, children }) {\n  const { isOpen } = useContext(AccordionContext);\n  \n  if (!isOpen(id)) return null;\n  return <div className=\"accordion-panel\">{children}</div>;\n}"
        },
        {
          "type": "interview-tip",
          "tip": "When to Use Compound Components",
          "explanation": "Use when:\n1. Components are meant to work together\n2. Want flexible, declarative API\n3. Need implicit state sharing\n4. Building reusable component libraries\n\nExamples: Tabs, Accordion, Menu, Select, Modal\n\nBenefits:\n1. Flexible composition\n2. Clean, readable JSX\n3. Implicit state management\n4. Easy to extend"
        }
      ]
    },
    {
      "id": "section-3",
      "title": "Props In-Depth",
      "blocks": [
        {
          "type": "title",
          "level": 1,
          "content": "Props Fundamentals"
        },
        {
          "type": "description",
          "content": "Props (short for properties) are read-only inputs passed from parent to child components. They enable component communication and configuration. Props can include any JavaScript value: strings, numbers, objects, arrays, functions, and even other components."
        },
        {
          "type": "code",
          "language": "javascript",
          "title": "Props Usage Examples",
          "code": "// Basic Props\nfunction Greeting({ name, age }) {\n  return <p>Hello, {name}! You are {age} years old.</p>;\n}\n\n<Greeting name=\"John\" age={25} />\n\n// Default Props\nfunction Button({ text = 'Click Me', variant = 'primary', size = 'medium' }) {\n  return (\n    <button className={`btn btn-${variant} btn-${size}`}>\n      {text}\n    </button>\n  );\n}\n\n<Button />  // Uses all defaults\n<Button text=\"Submit\" variant=\"secondary\" />\n\n// Destructuring with rest operator\nfunction Card({ title, children, ...otherProps }) {\n  return (\n    <div className=\"card\" {...otherProps}>\n      <h2>{title}</h2>\n      {children}\n    </div>\n  );\n}\n\n<Card title=\"My Card\" onClick={handleClick} data-testid=\"card\">\n  <p>Card content</p>\n</Card>\n\n// Function as props (callbacks)\nfunction SearchInput({ value, onChange, onSubmit }) {\n  return (\n    <form onSubmit={onSubmit}>\n      <input\n        value={value}\n        onChange={(e) => onChange(e.target.value)}\n        placeholder=\"Search...\"\n      />\n      <button type=\"submit\">Search</button>\n    </form>\n  );\n}\n\n// Component as props\nfunction Layout({ header, sidebar, children, footer }) {\n  return (\n    <div className=\"layout\">\n      <header>{header}</header>\n      <aside>{sidebar}</aside>\n      <main>{children}</main>\n      <footer>{footer}</footer>\n    </div>\n  );\n}\n\n<Layout\n  header={<Header />}\n  sidebar={<Sidebar />}\n  footer={<Footer />}\n>\n  <MainContent />\n</Layout>"
        },
        {
          "type": "title",
          "level": 2,
          "content": "PropTypes Validation"
        },
        {
          "type": "description",
          "content": "PropTypes provide runtime type checking for React props. While TypeScript is preferred for static typing, PropTypes still work for JavaScript projects and offer documentation benefits."
        },
        {
          "type": "code",
          "language": "javascript",
          "title": "PropTypes Examples",
          "code": "import PropTypes from 'prop-types';\n\nfunction UserCard({ user, onEdit, isAdmin, tags, config, render }) {\n  return (\n    <div className=\"user-card\">\n      <h2>{user.name}</h2>\n      <p>{user.email}</p>\n      {isAdmin && <span className=\"badge\">Admin</span>}\n      <div>{tags.map(tag => <span key={tag}>{tag}</span>)}</div>\n      <button onClick={() => onEdit(user.id)}>Edit</button>\n      {render && render(user)}\n    </div>\n  );\n}\n\nUserCard.propTypes = {\n  // Required string\n  title: PropTypes.string.isRequired,\n  \n  // Basic types\n  count: PropTypes.number,\n  isActive: PropTypes.bool,\n  items: PropTypes.array,\n  data: PropTypes.object,\n  onClick: PropTypes.func,\n  element: PropTypes.element,\n  node: PropTypes.node, // Anything renderable\n  \n  // Specific values\n  status: PropTypes.oneOf(['pending', 'approved', 'rejected']),\n  \n  // Multiple types\n  id: PropTypes.oneOfType([\n    PropTypes.string,\n    PropTypes.number\n  ]),\n  \n  // Array of specific type\n  tags: PropTypes.arrayOf(PropTypes.string),\n  \n  // Object with specific shape\n  user: PropTypes.shape({\n    id: PropTypes.number.isRequired,\n    name: PropTypes.string.isRequired,\n    email: PropTypes.string,\n    age: PropTypes.number\n  }).isRequired,\n  \n  // Exact shape (no extra props allowed)\n  config: PropTypes.exact({\n    theme: PropTypes.string,\n    language: PropTypes.string\n  }),\n  \n  // Object with values of certain type\n  errors: PropTypes.objectOf(PropTypes.string),\n  \n  // Instance of a class\n  date: PropTypes.instanceOf(Date),\n  \n  // Custom validator\n  customProp: function(props, propName, componentName) {\n    if (!/^#[0-9A-F]{6}$/i.test(props[propName])) {\n      return new Error(\n        `Invalid prop ${propName} supplied to ${componentName}. ` +\n        'Expected a valid hex color.'\n      );\n    }\n  }\n};\n\n// Default props\nUserCard.defaultProps = {\n  isAdmin: false,\n  tags: [],\n  config: { theme: 'light', language: 'en' }\n};"
        },
        {
          "type": "title",
          "level": 2,
          "content": "Props Drilling Problem"
        },
        {
          "type": "description",
          "content": "Props drilling occurs when you pass props through multiple layers of components that don't need them, just to reach a deeply nested component. This makes code harder to maintain and refactor."
        },
        {
          "type": "code",
          "language": "javascript",
          "title": "Props Drilling Problem & Solutions",
          "code": "// ❌ PROBLEM: Props Drilling\nfunction App() {\n  const [user, setUser] = useState({ name: 'John', theme: 'dark' });\n  \n  return <Layout user={user} setUser={setUser} />;\n}\n\nfunction Layout({ user, setUser }) {\n  return <Sidebar user={user} setUser={setUser} />;\n}\n\nfunction Sidebar({ user, setUser }) {\n  return <UserMenu user={user} setUser={setUser} />;\n}\n\nfunction UserMenu({ user, setUser }) {\n  // Finally uses the props!\n  return <span onClick={() => setUser(null)}>{user.name}</span>;\n}\n\n// ✅ SOLUTION 1: Context API\nconst UserContext = createContext();\n\nfunction App() {\n  const [user, setUser] = useState({ name: 'John' });\n  \n  return (\n    <UserContext.Provider value={{ user, setUser }}>\n      <Layout />\n    </UserContext.Provider>\n  );\n}\n\nfunction Layout() {\n  return <Sidebar />;\n}\n\nfunction Sidebar() {\n  return <UserMenu />;\n}\n\nfunction UserMenu() {\n  const { user, setUser } = useContext(UserContext);\n  return <span onClick={() => setUser(null)}>{user.name}</span>;\n}\n\n// ✅ SOLUTION 2: Component Composition\nfunction App() {\n  const [user, setUser] = useState({ name: 'John' });\n  \n  // Build the deeply nested component at the top level\n  const userMenu = <UserMenu user={user} setUser={setUser} />;\n  \n  return <Layout sidebar={<Sidebar userMenu={userMenu} />} />;\n}\n\nfunction Layout({ sidebar }) {\n  return <div className=\"layout\">{sidebar}</div>;\n}\n\nfunction Sidebar({ userMenu }) {\n  return <div className=\"sidebar\">{userMenu}</div>;\n}\n\nfunction UserMenu({ user, setUser }) {\n  return <span onClick={() => setUser(null)}>{user.name}</span>;\n}\n\n// ✅ SOLUTION 3: State Management (Redux/Zustand)\n// User state lives in store, accessible from anywhere\nimport { useSelector, useDispatch } from 'react-redux';\n\nfunction UserMenu() {\n  const user = useSelector(state => state.user);\n  const dispatch = useDispatch();\n  \n  return (\n    <span onClick={() => dispatch(logoutUser())}>\n      {user.name}\n    </span>\n  );\n}"
        },
        {
          "type": "interview-tip",
          "tip": "When to Use Each Solution",
          "explanation": "Props Drilling: OK for 2-3 levels, simple data\n\nContext API: Theme, auth, locale - rarely changing data\n\nComposition: When intermediate components don't need data\n\nState Management: Complex app state, many consumers, frequent updates\n\nRemember: Don't over-engineer. Start simple and refactor when needed."
        },
        {
          "type": "title",
          "level": 2,
          "content": "Children Prop"
        },
        {
          "type": "description",
          "content": "The children prop is a special prop that allows components to receive content between their opening and closing tags. It enables powerful composition patterns and is fundamental to creating reusable wrapper components."
        },
        {
          "type": "code",
          "language": "javascript",
          "title": "Children Prop Patterns",
          "code": "import { Children, cloneElement, isValidElement } from 'react';\n\n// Basic children usage\nfunction Card({ children }) {\n  return <div className=\"card\">{children}</div>;\n}\n\n<Card>\n  <h1>Title</h1>\n  <p>Content here</p>\n</Card>\n\n// Multiple children slots\nfunction Layout({ header, children, footer }) {\n  return (\n    <div>\n      <header>{header}</header>\n      <main>{children}</main>\n      <footer>{footer}</footer>\n    </div>\n  );\n}\n\n// Manipulating children with React.Children\nfunction List({ children }) {\n  return (\n    <ul>\n      {Children.map(children, (child, index) => (\n        <li key={index}>{child}</li>\n      ))}\n    </ul>\n  );\n}\n\n<List>\n  <span>Item 1</span>\n  <span>Item 2</span>\n  <span>Item 3</span>\n</List>\n\n// Counting children\nfunction TabContainer({ children }) {\n  const count = Children.count(children);\n  return <div>Showing {count} tabs</div>;\n}\n\n// Cloning children with additional props\nfunction RadioGroup({ name, children, value, onChange }) {\n  return (\n    <div role=\"radiogroup\">\n      {Children.map(children, child => {\n        if (isValidElement(child)) {\n          return cloneElement(child, {\n            name,\n            checked: child.props.value === value,\n            onChange: () => onChange(child.props.value)\n          });\n        }\n        return child;\n      })}\n    </div>\n  );\n}\n\nfunction Radio({ name, value, checked, onChange, children }) {\n  return (\n    <label>\n      <input\n        type=\"radio\"\n        name={name}\n        value={value}\n        checked={checked}\n        onChange={onChange}\n      />\n      {children}\n    </label>\n  );\n}\n\n// Usage\nfunction App() {\n  const [color, setColor] = useState('red');\n  \n  return (\n    <RadioGroup name=\"color\" value={color} onChange={setColor}>\n      <Radio value=\"red\">Red</Radio>\n      <Radio value=\"green\">Green</Radio>\n      <Radio value=\"blue\">Blue</Radio>\n    </RadioGroup>\n  );\n}\n\n// Conditional children rendering\nfunction Authorized({ children, role, requiredRole }) {\n  if (role !== requiredRole) {\n    return <div>Access Denied</div>;\n  }\n  return children;\n}\n\n<Authorized role={user.role} requiredRole=\"admin\">\n  <AdminPanel />\n</Authorized>"
        },
        {
          "type": "code",
          "language": "text",
          "title": "React.Children API",
          "code": "┌─────────────────────────────────────────────────────────────────┐\n│                    REACT.CHILDREN METHODS                       │\n├─────────────────────────────────────────────────────────────────┤\n│                                                                 │\n│  Children.map(children, fn)                                     │\n│  └─ Iterate and transform children, handles null/undefined      │\n│                                                                 │\n│  Children.forEach(children, fn)                                 │\n│  └─ Iterate children without returning array                    │\n│                                                                 │\n│  Children.count(children)                                       │\n│  └─ Returns number of children (handles fragments)              │\n│                                                                 │\n│  Children.only(children)                                        │\n│  └─ Verifies single child, throws if not                        │\n│                                                                 │\n│  Children.toArray(children)                                     │\n│  └─ Flattens children to array with keys                        │\n│                                                                 │\n│  isValidElement(element)                                        │\n│  └─ Checks if object is valid React element                     │\n│                                                                 │\n│  cloneElement(element, props, ...children)                      │\n│  └─ Clones element with merged props                            │\n│                                                                 │\n└─────────────────────────────────────────────────────────────────┘"
        }
      ]
    },
    {
      "id": "section-4",
      "title": "State Management",
      "blocks": [
        {
          "type": "title",
          "level": 1,
          "content": "Understanding State in React"
        },
        {
          "type": "description",
          "content": "State is data that changes over time in a component. Unlike props, state is owned and managed by the component itself. When state changes, React re-renders the component. State should be immutable - never modify state directly."
        },
        {
          "type": "code",
          "language": "javascript",
          "title": "State vs Props",
          "code": "// STATE: Component's internal data that can change\nfunction Counter() {\n  const [count, setCount] = useState(0); // State\n  \n  return (\n    <div>\n      <p>Count: {count}</p>\n      <button onClick={() => setCount(count + 1)}>Increment</button>\n    </div>\n  );\n}\n\n// PROPS: External data passed from parent (read-only)\nfunction Display({ count, label }) { // Props\n  return <p>{label}: {count}</p>;\n}\n\n// Combining both\nfunction App() {\n  const [count, setCount] = useState(0);\n  \n  return (\n    <div>\n      <Display count={count} label=\"Current Count\" />\n      <Counter />\n    </div>\n  );\n}"
        },
        {
          "type": "code",
          "language": "text",
          "title": "State vs Props Comparison",
          "code": "┌────────────────────┬─────────────────────┬─────────────────────┐\n│ Aspect             │ State               │ Props               │\n├────────────────────┼─────────────────────┼─────────────────────┤\n│ Ownership          │ Component itself    │ Parent component    │\n│ Mutability         │ Mutable (via setter)│ Read-only           │\n│ Updates            │ Component controls  │ Parent controls     │\n│ Initialization     │ In component        │ Passed from parent  │\n│ Purpose            │ Internal state      │ Configuration       │\n│ Re-renders         │ On state change     │ On props change     │\n│ Child access       │ Pass as props       │ Receive and use     │\n└────────────────────┴─────────────────────┴─────────────────────┘"
        },
        {
          "type": "title",
          "level": 2,
          "content": "useState Hook Deep Dive"
        },
        {
          "type": "description",
          "content": "useState is the most fundamental hook for adding state to functional components. It returns an array with the current state value and a function to update it. State updates are asynchronous and batched for performance."
        },
        {
          "type": "code",
          "language": "javascript",
          "title": "useState Patterns",
          "code": "import { useState } from 'react';\n\n// Basic usage\nfunction BasicExample() {\n  const [count, setCount] = useState(0);\n  const [name, setName] = useState('');\n  const [isOpen, setIsOpen] = useState(false);\n  \n  return (\n    <div>\n      <p>Count: {count}</p>\n      <button onClick={() => setCount(count + 1)}>Increment</button>\n    </div>\n  );\n}\n\n// Object state\nfunction FormExample() {\n  const [form, setForm] = useState({\n    username: '',\n    email: '',\n    password: ''\n  });\n  \n  const handleChange = (e) => {\n    const { name, value } = e.target;\n    // ✅ Create new object, don't mutate\n    setForm(prevForm => ({\n      ...prevForm,\n      [name]: value\n    }));\n  };\n  \n  // ❌ WRONG: Direct mutation\n  // form.username = 'John'; // Won't trigger re-render!\n  \n  return (\n    <form>\n      <input name=\"username\" value={form.username} onChange={handleChange} />\n      <input name=\"email\" value={form.email} onChange={handleChange} />\n      <input name=\"password\" value={form.password} onChange={handleChange} />\n    </form>\n  );\n}\n\n// Array state\nfunction TodoList() {\n  const [todos, setTodos] = useState([]);\n  \n  const addTodo = (text) => {\n    setTodos(prev => [...prev, { id: Date.now(), text, done: false }]);\n  };\n  \n  const removeTodo = (id) => {\n    setTodos(prev => prev.filter(todo => todo.id !== id));\n  };\n  \n  const toggleTodo = (id) => {\n    setTodos(prev => prev.map(todo =>\n      todo.id === id ? { ...todo, done: !todo.done } : todo\n    ));\n  };\n  \n  const updateTodo = (id, text) => {\n    setTodos(prev => prev.map(todo =>\n      todo.id === id ? { ...todo, text } : todo\n    ));\n  };\n  \n  return (\n    <ul>\n      {todos.map(todo => (\n        <li key={todo.id}>\n          <input\n            type=\"checkbox\"\n            checked={todo.done}\n            onChange={() => toggleTodo(todo.id)}\n          />\n          {todo.text}\n          <button onClick={() => removeTodo(todo.id)}>Delete</button>\n        </li>\n      ))}\n    </ul>\n  );\n}\n\n// Lazy initialization (for expensive computations)\nfunction ExpensiveInit() {\n  // ❌ Runs on every render\n  const [data, setData] = useState(expensiveComputation());\n  \n  // ✅ Runs only once on mount\n  const [data, setData] = useState(() => expensiveComputation());\n  \n  // ✅ Also good for localStorage\n  const [theme, setTheme] = useState(() => {\n    const saved = localStorage.getItem('theme');\n    return saved ? JSON.parse(saved) : 'light';\n  });\n  \n  return <div>...</div>;\n}\n\n// Functional updates (when new state depends on previous)\nfunction Counter() {\n  const [count, setCount] = useState(0);\n  \n  const incrementThree = () => {\n    // ❌ WRONG: All use same stale 'count' value\n    setCount(count + 1);\n    setCount(count + 1);\n    setCount(count + 1);\n    // Result: count + 1 (not count + 3)\n    \n    // ✅ CORRECT: Use functional update\n    setCount(prev => prev + 1);\n    setCount(prev => prev + 1);\n    setCount(prev => prev + 1);\n    // Result: count + 3\n  };\n  \n  return (\n    <button onClick={incrementThree}>+3: {count}</button>\n  );\n}"
        },
        {
          "type": "interview-tip",
          "tip": "useState Common Mistakes",
          "explanation": "1. Direct state mutation (won't trigger re-render)\n2. Using stale state in closures (use functional update)\n3. Not using lazy initialization for expensive initial values\n4. Creating new object/array references unnecessarily\n5. Expecting synchronous state updates\n6. Not batching related state updates (use useReducer for complex state)"
        },
        {
          "type": "title",
          "level": 2,
          "content": "State Batching"
        },
        {
          "type": "description",
          "content": "React batches multiple state updates together for performance. In React 18+, all updates are automatically batched, including those in promises, timeouts, and event handlers. This reduces unnecessary re-renders."
        },
        {
          "type": "code",
          "language": "javascript",
          "title": "State Batching Examples",
          "code": "import { useState, flushSync } from 'react';\n\nfunction BatchingExample() {\n  const [count, setCount] = useState(0);\n  const [flag, setFlag] = useState(false);\n  \n  console.log('Render'); // Check how many times this logs\n  \n  // React 18: All these are batched (single re-render)\n  const handleClick = () => {\n    setCount(c => c + 1);  // Batched\n    setFlag(f => !f);       // Batched\n    // Only ONE re-render happens\n  };\n  \n  // Even async updates are batched in React 18\n  const handleAsync = async () => {\n    await fetch('/api/data');\n    setCount(c => c + 1);  // Batched\n    setFlag(f => !f);       // Batched\n    // Only ONE re-render\n  };\n  \n  // setTimeout also batched\n  const handleTimeout = () => {\n    setTimeout(() => {\n      setCount(c => c + 1);  // Batched\n      setFlag(f => !f);       // Batched\n      // Only ONE re-render\n    }, 1000);\n  };\n  \n  // Use flushSync to opt out of batching (rarely needed)\n  const handleFlushSync = () => {\n    flushSync(() => {\n      setCount(c => c + 1);  // Renders immediately\n    });\n    // DOM is updated here\n    \n    flushSync(() => {\n      setFlag(f => !f);       // Renders immediately\n    });\n    // DOM is updated again\n    // TWO re-renders total\n  };\n  \n  return (\n    <div>\n      <p>Count: {count}, Flag: {flag.toString()}</p>\n      <button onClick={handleClick}>Update Both</button>\n      <button onClick={handleAsync}>Async Update</button>\n      <button onClick={handleTimeout}>Timeout Update</button>\n      <button onClick={handleFlushSync}>Flush Sync</button>\n    </div>\n  );\n}"
        },
        {
          "type": "title",
          "level": 2,
          "content": "Lifting State Up"
        },
        {
          "type": "description",
          "content": "When multiple components need to share state, lift the state up to their closest common ancestor. The ancestor becomes the source of truth and passes state down via props, along with functions to update it."
        },
        {
          "type": "code",
          "language": "javascript",
          "title": "Lifting State Up Pattern",
          "code": "// Before: Each component has its own state (not synchronized)\nfunction TemperatureInput1() {\n  const [temp, setTemp] = useState('');\n  return <input value={temp} onChange={e => setTemp(e.target.value)} />;\n}\n\nfunction TemperatureInput2() {\n  const [temp, setTemp] = useState('');\n  return <input value={temp} onChange={e => setTemp(e.target.value)} />;\n}\n\n// After: State lifted to common parent\nfunction TemperatureInput({ scale, temperature, onTemperatureChange }) {\n  const scaleNames = { c: 'Celsius', f: 'Fahrenheit' };\n  \n  return (\n    <fieldset>\n      <legend>Enter temperature in {scaleNames[scale]}:</legend>\n      <input\n        value={temperature}\n        onChange={e => onTemperatureChange(e.target.value)}\n      />\n    </fieldset>\n  );\n}\n\nfunction toCelsius(fahrenheit) {\n  return ((fahrenheit - 32) * 5) / 9;\n}\n\nfunction toFahrenheit(celsius) {\n  return (celsius * 9) / 5 + 32;\n}\n\nfunction Calculator() {\n  const [temperature, setTemperature] = useState('');\n  const [scale, setScale] = useState('c');\n  \n  const handleCelsiusChange = (temp) => {\n    setScale('c');\n    setTemperature(temp);\n  };\n  \n  const handleFahrenheitChange = (temp) => {\n    setScale('f');\n    setTemperature(temp);\n  };\n  \n  const celsius = scale === 'f' ? toCelsius(parseFloat(temperature)) : temperature;\n  const fahrenheit = scale === 'c' ? toFahrenheit(parseFloat(temperature)) : temperature;\n  \n  return (\n    <div>\n      <TemperatureInput\n        scale=\"c\"\n        temperature={celsius}\n        onTemperatureChange={handleCelsiusChange}\n      />\n      <TemperatureInput\n        scale=\"f\"\n        temperature={fahrenheit}\n        onTemperatureChange={handleFahrenheitChange}\n      />\n      <BoilingVerdict celsius={parseFloat(celsius)} />\n    </div>\n  );\n}\n\nfunction BoilingVerdict({ celsius }) {\n  if (celsius >= 100) {\n    return <p>The water would boil.</p>;\n  }\n  return <p>The water would not boil.</p>;\n}"
        },
        {
          "type": "code",
          "language": "text",
          "title": "Lifting State Diagram",
          "code": "┌─────────────────────────────────────────────────────────────────┐\n│                    LIFTING STATE UP                             │\n├─────────────────────────────────────────────────────────────────┤\n│                                                                 │\n│  BEFORE: Separate state (not synchronized)                      │\n│                                                                 │\n│         ┌─────────────┐    ┌─────────────┐                     │\n│         │  Input A    │    │  Input B    │                     │\n│         │ state: 25°C │    │ state: 77°F │  ← Not synced!      │\n│         └─────────────┘    └─────────────┘                     │\n│                                                                 │\n│  AFTER: Shared state in parent                                  │\n│                                                                 │\n│              ┌───────────────────────┐                         │\n│              │      Calculator       │                         │\n│              │ state: { temp, scale }│ ← Single source         │\n│              └───────────┬───────────┘                         │\n│                          │                                      │\n│           ┌──────────────┼──────────────┐                      │\n│           ▼              │              ▼                      │\n│    ┌─────────────┐       │       ┌─────────────┐               │\n│    │  Input A    │       │       │  Input B    │               │\n│    │ props: 25°C │       │       │ props: 77°F │  ← Synced!    │\n│    └─────────────┘       │       └─────────────┘               │\n│                          ▼                                      │\n│                   ┌─────────────┐                              │\n│                   │   Verdict   │                              │\n│                   │ props: 25°C │                              │\n│                   └─────────────┘                              │\n│                                                                 │\n└─────────────────────────────────────────────────────────────────┘"
        },
        {
          "type": "interview-tip",
          "tip": "State Location Rules",
          "explanation": "1. Identify components that need the state\n2. Find their closest common ancestor\n3. Put state there or higher\n4. If no common ancestor makes sense, create one\n\nSigns you need to lift state:\n- Two components need to sync\n- Child needs to update parent's display\n- Sibling components need same data"
        }
      ]
    },
    {
      "id": "section-5",
      "title": "React Hooks Complete Guide",
      "blocks": [
        {
          "type": "title",
          "level": 1,
          "content": "Introduction to Hooks"
        },
        {
          "type": "description",
          "content": "Hooks are functions that let you 'hook into' React state and lifecycle features from functional components. Introduced in React 16.8, they eliminate the need for class components in most cases and provide a more direct API to React concepts."
        },
        {
          "type": "code",
          "language": "text",
          "title": "Rules of Hooks",
          "code": "┌─────────────────────────────────────────────────────────────────┐\n│                      RULES OF HOOKS                             │\n├─────────────────────────────────────────────────────────────────┤\n│                                                                 │\n│  1. ONLY CALL HOOKS AT THE TOP LEVEL                           │\n│     ✅ function Component() {                                   │\n│          const [count, setCount] = useState(0);                │\n│        }                                                        │\n│                                                                 │\n│     ❌ function Component() {                                   │\n│          if (condition) {                                       │\n│            const [count, setCount] = useState(0); // Wrong!    │\n│          }                                                      │\n│        }                                                        │\n│                                                                 │\n│     ❌ function Component() {                                   │\n│          for (let i = 0; i < 5; i++) {                         │\n│            useEffect(() => {}); // Wrong!                       │\n│          }                                                      │\n│        }                                                        │\n│                                                                 │\n│  2. ONLY CALL HOOKS FROM REACT FUNCTIONS                       │\n│     ✅ Function components                                      │\n│     ✅ Custom hooks                                             │\n│     ❌ Regular JavaScript functions                             │\n│     ❌ Class components                                         │\n│                                                                 │\n│  WHY? React relies on the ORDER of hook calls to maintain      │\n│  state between renders. Conditional/loop calls break this.     │\n│                                                                 │\n└─────────────────────────────────────────────────────────────────┘"
        },
        {
          "type": "title",
          "level": 2,
          "content": "useEffect Hook"
        },
        {
          "type": "description",
          "content": "useEffect lets you perform side effects in functional components. Side effects include data fetching, subscriptions, timers, logging, and manual DOM manipulation. It runs after the render is committed to the screen."
        },
        {
          "type": "code",
          "language": "javascript",
          "title": "useEffect Complete Guide",
          "code": "import { useEffect, useState } from 'react';\n\nfunction UseEffectExamples({ userId }) {\n  const [user, setUser] = useState(null);\n  const [count, setCount] = useState(0);\n  \n  // 1. Run after EVERY render (rarely needed)\n  useEffect(() => {\n    console.log('Rendered!');\n  }); // No dependency array\n  \n  // 2. Run ONCE on mount (componentDidMount equivalent)\n  useEffect(() => {\n    console.log('Component mounted');\n    initializeAnalytics();\n  }, []); // Empty dependency array\n  \n  // 3. Run when DEPENDENCIES change\n  useEffect(() => {\n    console.log('userId changed:', userId);\n    fetchUser(userId).then(setUser);\n  }, [userId]); // Re-runs when userId changes\n  \n  // 4. CLEANUP function (componentWillUnmount equivalent)\n  useEffect(() => {\n    const subscription = subscribeToUserStatus(userId);\n    \n    // Cleanup function runs:\n    // - Before the effect re-runs\n    // - When component unmounts\n    return () => {\n      subscription.unsubscribe();\n    };\n  }, [userId]);\n  \n  // 5. Timer with cleanup\n  useEffect(() => {\n    const timer = setInterval(() => {\n      setCount(c => c + 1);\n    }, 1000);\n    \n    return () => clearInterval(timer);\n  }, []);\n  \n  // 6. Event listener with cleanup\n  useEffect(() => {\n    const handleResize = () => {\n      console.log('Window resized');\n    };\n    \n    window.addEventListener('resize', handleResize);\n    return () => window.removeEventListener('resize', handleResize);\n  }, []);\n  \n  // 7. Debounced effect\n  useEffect(() => {\n    const debounceTimer = setTimeout(() => {\n      searchUsers(searchTerm);\n    }, 300);\n    \n    return () => clearTimeout(debounceTimer);\n  }, [searchTerm]);\n  \n  // 8. Async effect (proper pattern)\n  useEffect(() => {\n    let isMounted = true; // Prevent state update on unmounted component\n    \n    async function loadData() {\n      try {\n        const result = await fetchData(userId);\n        if (isMounted) {\n          setUser(result);\n        }\n      } catch (error) {\n        if (isMounted) {\n          setError(error);\n        }\n      }\n    }\n    \n    loadData();\n    \n    return () => {\n      isMounted = false;\n    };\n  }, [userId]);\n  \n  return <div>{user?.name}</div>;\n}"
        },
        {
          "type": "code",
          "language": "text",
          "title": "useEffect Lifecycle Mapping",
          "code": "┌─────────────────────────────────────────────────────────────────┐\n│              useEffect vs Class Lifecycle Methods               │\n├─────────────────────────────────────────────────────────────────┤\n│                                                                 │\n│  componentDidMount                                              │\n│  ─────────────────                                              │\n│  useEffect(() => {                                              │\n│    // runs once after first render                              │\n│  }, []);                                                        │\n│                                                                 │\n│  componentDidUpdate                                             │\n│  ──────────────────                                             │\n│  useEffect(() => {                                              │\n│    // runs after every render                                   │\n│  });                                                            │\n│                                                                 │\n│  useEffect(() => {                                              │\n│    // runs when 'prop' changes                                  │\n│  }, [prop]);                                                    │\n│                                                                 │\n│  componentWillUnmount                                           │\n│  ─────────────────────                                          │\n│  useEffect(() => {                                              │\n│    return () => {                                               │\n│      // cleanup on unmount                                      │\n│    };                                                           │\n│  }, []);                                                        │\n│                                                                 │\n│  Combined Pattern                                               │\n│  ────────────────                                               │\n│  useEffect(() => {                                              │\n│    // componentDidMount + componentDidUpdate                    │\n│    return () => {                                               │\n│      // cleanup before re-run + componentWillUnmount            │\n│    };                                                           │\n│  }, [dependencies]);                                            │\n│                                                                 │\n└─────────────────────────────────────────────────────────────────┘"
        },
        {
          "type": "interview-tip",
          "tip": "Common useEffect Mistakes",
          "explanation": "1. Missing dependencies → stale closures\n2. Object/array dependencies → infinite loops (use useMemo)\n3. Function dependencies → infinite loops (use useCallback)\n4. Forgetting cleanup → memory leaks\n5. Updating state in effect that triggers effect → infinite loop\n6. Using async directly as effect function (use inner async function)"
        },
        {
          "type": "title",
          "level": 2,
          "content": "useContext Hook"
        },
        {
          "type": "description",
          "content": "useContext provides a way to pass data through the component tree without manually passing props at every level. It's React's built-in solution for state that needs to be accessible by many components at different nesting levels."
        },
        {
          "type": "code",
          "language": "javascript",
          "title": "useContext Complete Example",
          "code": "import { createContext, useContext, useState, useMemo } from 'react';\n\n// 1. Create Context\nconst ThemeContext = createContext(null);\nconst UserContext = createContext(null);\n\n// 2. Create Provider Component\nfunction ThemeProvider({ children }) {\n  const [theme, setTheme] = useState('light');\n  \n  const toggleTheme = () => {\n    setTheme(prev => prev === 'light' ? 'dark' : 'light');\n  };\n  \n  // Memoize value to prevent unnecessary re-renders\n  const value = useMemo(() => ({\n    theme,\n    toggleTheme,\n    isDark: theme === 'dark'\n  }), [theme]);\n  \n  return (\n    <ThemeContext.Provider value={value}>\n      {children}\n    </ThemeContext.Provider>\n  );\n}\n\n// 3. Create Custom Hook for easier usage\nfunction useTheme() {\n  const context = useContext(ThemeContext);\n  if (context === null) {\n    throw new Error('useTheme must be used within a ThemeProvider');\n  }\n  return context;\n}\n\n// 4. Use in components\nfunction ThemedButton() {\n  const { theme, toggleTheme, isDark } = useTheme();\n  \n  return (\n    <button\n      onClick={toggleTheme}\n      style={{\n        backgroundColor: isDark ? '#333' : '#fff',\n        color: isDark ? '#fff' : '#333'\n      }}\n    >\n      Current theme: {theme}\n    </button>\n  );\n}\n\n// Multiple Contexts\nfunction UserProvider({ children }) {\n  const [user, setUser] = useState(null);\n  \n  const login = async (credentials) => {\n    const userData = await authService.login(credentials);\n    setUser(userData);\n  };\n  \n  const logout = () => {\n    setUser(null);\n  };\n  \n  return (\n    <UserContext.Provider value={{ user, login, logout }}>\n      {children}\n    </UserContext.Provider>\n  );\n}\n\nfunction useUser() {\n  const context = useContext(UserContext);\n  if (!context) {\n    throw new Error('useUser must be used within UserProvider');\n  }\n  return context;\n}\n\n// App with nested providers\nfunction App() {\n  return (\n    <UserProvider>\n      <ThemeProvider>\n        <Layout>\n          <MainContent />\n        </Layout>\n      </ThemeProvider>\n    </UserProvider>\n  );\n}\n\n// Deep nested component - no prop drilling!\nfunction DeepNestedComponent() {\n  const { theme } = useTheme();\n  const { user, logout } = useUser();\n  \n  return (\n    <div className={`container ${theme}`}>\n      <p>Welcome, {user?.name}!</p>\n      <button onClick={logout}>Logout</button>\n    </div>\n  );\n}"
        },
        {
          "type": "interview-tip",
          "tip": "Context Best Practices",
          "explanation": "1. Split contexts by domain (auth, theme, locale)\n2. Create custom hooks for each context\n3. Memoize provider values to prevent re-renders\n4. Keep context values minimal\n5. Don't use for frequently changing data\n6. Consider Redux/Zustand for complex state"
        },
        {
          "type": "title",
          "level": 2,
          "content": "useReducer Hook"
        },
        {
          "type": "description",
          "content": "useReducer is an alternative to useState for managing complex state logic. It's preferable when state has multiple sub-values, when the next state depends on the previous one, or when you want to optimize performance for deep updates."
        },
        {
          "type": "code",
          "language": "javascript",
          "title": "useReducer Complete Guide",
          "code": "import { useReducer, useContext, createContext } from 'react';\n\n// Define initial state\nconst initialState = {\n  todos: [],\n  filter: 'all',\n  loading: false,\n  error: null\n};\n\n// Define action types (optional but recommended)\nconst ACTIONS = {\n  ADD_TODO: 'ADD_TODO',\n  REMOVE_TODO: 'REMOVE_TODO',\n  TOGGLE_TODO: 'TOGGLE_TODO',\n  SET_FILTER: 'SET_FILTER',\n  FETCH_START: 'FETCH_START',\n  FETCH_SUCCESS: 'FETCH_SUCCESS',\n  FETCH_ERROR: 'FETCH_ERROR'\n};\n\n// Reducer function - pure function!\nfunction todoReducer(state, action) {\n  switch (action.type) {\n    case ACTIONS.ADD_TODO:\n      return {\n        ...state,\n        todos: [\n          ...state.todos,\n          {\n            id: Date.now(),\n            text: action.payload.text,\n            completed: false\n          }\n        ]\n      };\n      \n    case ACTIONS.REMOVE_TODO:\n      return {\n        ...state,\n        todos: state.todos.filter(todo => todo.id !== action.payload.id)\n      };\n      \n    case ACTIONS.TOGGLE_TODO:\n      return {\n        ...state,\n        todos: state.todos.map(todo =>\n          todo.id === action.payload.id\n            ? { ...todo, completed: !todo.completed }\n            : todo\n        )\n      };\n      \n    case ACTIONS.SET_FILTER:\n      return {\n        ...state,\n        filter: action.payload.filter\n      };\n      \n    case ACTIONS.FETCH_START:\n      return { ...state, loading: true, error: null };\n      \n    case ACTIONS.FETCH_SUCCESS:\n      return { ...state, loading: false, todos: action.payload.todos };\n      \n    case ACTIONS.FETCH_ERROR:\n      return { ...state, loading: false, error: action.payload.error };\n      \n    default:\n      return state;\n      // Or throw new Error(`Unknown action: ${action.type}`);\n  }\n}\n\n// Component using useReducer\nfunction TodoApp() {\n  const [state, dispatch] = useReducer(todoReducer, initialState);\n  \n  const addTodo = (text) => {\n    dispatch({ type: ACTIONS.ADD_TODO, payload: { text } });\n  };\n  \n  const toggleTodo = (id) => {\n    dispatch({ type: ACTIONS.TOGGLE_TODO, payload: { id } });\n  };\n  \n  const removeTodo = (id) => {\n    dispatch({ type: ACTIONS.REMOVE_TODO, payload: { id } });\n  };\n  \n  const filteredTodos = state.todos.filter(todo => {\n    if (state.filter === 'completed') return todo.completed;\n    if (state.filter === 'active') return !todo.completed;\n    return true;\n  });\n  \n  return (\n    <div>\n      <TodoForm onAdd={addTodo} />\n      <TodoList \n        todos={filteredTodos} \n        onToggle={toggleTodo}\n        onRemove={removeTodo}\n      />\n      <FilterButtons \n        currentFilter={state.filter}\n        onFilterChange={(filter) => \n          dispatch({ type: ACTIONS.SET_FILTER, payload: { filter } })\n        }\n      />\n    </div>\n  );\n}\n\n// Lazy initialization\nfunction init(initialCount) {\n  return { count: initialCount };\n}\n\nfunction Counter({ initialCount }) {\n  const [state, dispatch] = useReducer(\n    counterReducer,\n    initialCount,\n    init  // Lazy init function\n  );\n  // ...\n}\n\n// useReducer with Context for global state\nconst TodoContext = createContext();\n\nfunction TodoProvider({ children }) {\n  const [state, dispatch] = useReducer(todoReducer, initialState);\n  \n  return (\n    <TodoContext.Provider value={{ state, dispatch }}>\n      {children}\n    </TodoContext.Provider>\n  );\n}\n\nfunction useTodos() {\n  const context = useContext(TodoContext);\n  if (!context) {\n    throw new Error('useTodos must be used within TodoProvider');\n  }\n  return context;\n}"
        },
        {
          "type": "code",
          "language": "text",
          "title": "useState vs useReducer",
          "code": "┌────────────────────┬─────────────────────┬─────────────────────┐\n│ Aspect             │ useState            │ useReducer          │\n├────────────────────┼─────────────────────┼─────────────────────┤\n│ State type         │ Simple primitives   │ Complex objects     │\n│ Updates            │ Direct              │ Via actions         │\n│ Logic location     │ In component        │ In reducer          │\n│ Testing            │ Component tests     │ Reducer unit tests  │\n│ Related updates    │ Multiple setState   │ Single dispatch     │\n│ When to use        │ 1-2 state values    │ 3+ related values   │\n│ Learning curve     │ Easy                │ Moderate            │\n│ DevTools support   │ Limited             │ Better with Redux   │\n└────────────────────┴─────────────────────┴─────────────────────┘\n\nUse useReducer when:\n• State logic is complex\n• Next state depends on previous state  \n• Multiple sub-values need to update together\n• You want to optimize with dispatch (stable identity)\n• State updates come from many event handlers"
        },
        {
          "type": "title",
          "level": 2,
          "content": "useRef Hook"
        },
        {
          "type": "description",
          "content": "useRef returns a mutable ref object whose .current property persists across renders without causing re-renders when changed. It's used for accessing DOM elements, storing previous values, and keeping mutable values that don't need to trigger updates."
        },
        {
          "type": "code",
          "language": "javascript",
          "title": "useRef Use Cases",
          "code": "import { useRef, useEffect, useState, forwardRef, useImperativeHandle } from 'react';\n\n// 1. Accessing DOM elements\nfunction TextInputWithFocusButton() {\n  const inputRef = useRef(null);\n  \n  const focusInput = () => {\n    inputRef.current.focus();\n  };\n  \n  return (\n    <div>\n      <input ref={inputRef} type=\"text\" />\n      <button onClick={focusInput}>Focus Input</button>\n    </div>\n  );\n}\n\n// 2. Storing previous value\nfunction Counter() {\n  const [count, setCount] = useState(0);\n  const prevCountRef = useRef();\n  \n  useEffect(() => {\n    prevCountRef.current = count;\n  });\n  \n  const prevCount = prevCountRef.current;\n  \n  return (\n    <div>\n      <p>Current: {count}, Previous: {prevCount}</p>\n      <button onClick={() => setCount(count + 1)}>Increment</button>\n    </div>\n  );\n}\n\n// Custom hook for previous value\nfunction usePrevious(value) {\n  const ref = useRef();\n  useEffect(() => {\n    ref.current = value;\n  });\n  return ref.current;\n}\n\n// 3. Storing mutable value that doesn't trigger re-render\nfunction Timer() {\n  const [seconds, setSeconds] = useState(0);\n  const intervalRef = useRef(null);\n  \n  const start = () => {\n    if (intervalRef.current !== null) return; // Already running\n    intervalRef.current = setInterval(() => {\n      setSeconds(s => s + 1);\n    }, 1000);\n  };\n  \n  const stop = () => {\n    clearInterval(intervalRef.current);\n    intervalRef.current = null;\n  };\n  \n  const reset = () => {\n    stop();\n    setSeconds(0);\n  };\n  \n  // Cleanup on unmount\n  useEffect(() => {\n    return () => clearInterval(intervalRef.current);\n  }, []);\n  \n  return (\n    <div>\n      <p>Seconds: {seconds}</p>\n      <button onClick={start}>Start</button>\n      <button onClick={stop}>Stop</button>\n      <button onClick={reset}>Reset</button>\n    </div>\n  );\n}\n\n// 4. Tracking mounted state\nfunction useIsMounted() {\n  const isMounted = useRef(false);\n  \n  useEffect(() => {\n    isMounted.current = true;\n    return () => {\n      isMounted.current = false;\n    };\n  }, []);\n  \n  return isMounted;\n}\n\n// 5. Avoiding stale closures\nfunction AvoidStaleClosure() {\n  const [count, setCount] = useState(0);\n  const countRef = useRef(count);\n  \n  // Keep ref in sync with state\n  useEffect(() => {\n    countRef.current = count;\n  }, [count]);\n  \n  const handleDelayedLog = () => {\n    setTimeout(() => {\n      // count would be stale here!\n      console.log('State count:', count);       // ❌ Stale\n      console.log('Ref count:', countRef.current); // ✅ Current\n    }, 3000);\n  };\n  \n  return (\n    <div>\n      <p>Count: {count}</p>\n      <button onClick={() => setCount(c => c + 1)}>Increment</button>\n      <button onClick={handleDelayedLog}>Log after 3s</button>\n    </div>\n  );\n}\n\n// 6. Callback refs\nfunction MeasureExample() {\n  const [height, setHeight] = useState(0);\n  \n  // Callback ref - called when element is mounted/unmounted\n  const measureRef = (node) => {\n    if (node !== null) {\n      setHeight(node.getBoundingClientRect().height);\n    }\n  };\n  \n  return (\n    <div>\n      <p>Height: {height}px</p>\n      <div ref={measureRef} style={{ height: '100px', background: 'lightblue' }}>\n        Measure me\n      </div>\n    </div>\n  );\n}"
        },
        {
          "type": "interview-tip",
          "tip": "useRef vs useState",
          "explanation": "useRef: Persists value, NO re-render on change, .current access\nuseState: Persists value, triggers re-render on change\n\nUse useRef for:\n- DOM element references\n- Timer/interval IDs\n- Previous values\n- Mutable values that don't affect rendering\n- Avoiding recreating objects/functions"
        },
        {
          "type": "title",
          "level": 2,
          "content": "useMemo & useCallback"
        },
        {
          "type": "description",
          "content": "useMemo memoizes computed values, recomputing only when dependencies change. useCallback memoizes function references, returning the same function instance unless dependencies change. Both are optimization hooks to prevent unnecessary recalculations or re-renders."
        },
        {
          "type": "code",
          "language": "javascript",
          "title": "useMemo & useCallback Examples",
          "code": "import { useMemo, useCallback, useState, memo } from 'react';\n\n// useMemo - Memoize computed values\nfunction ExpensiveCalculation({ list, filter }) {\n  // Without useMemo: Recalculates on EVERY render\n  // const expensiveResult = calculateExpensive(list);\n  \n  // With useMemo: Only recalculates when 'list' changes\n  const expensiveResult = useMemo(() => {\n    console.log('Calculating...');\n    return list\n      .filter(item => item.active)\n      .map(item => ({ ...item, processed: true }))\n      .sort((a, b) => a.value - b.value);\n  }, [list]);\n  \n  // Filter can change without recalculating\n  const filteredResult = expensiveResult.filter(item => \n    item.name.includes(filter)\n  );\n  \n  return <div>{/* render filtered result */}</div>;\n}\n\n// useMemo for referential equality\nfunction ParentComponent() {\n  const [count, setCount] = useState(0);\n  \n  // Without useMemo: New object on every render\n  // const config = { theme: 'dark', size: 'large' };\n  \n  // With useMemo: Same reference unless dependencies change\n  const config = useMemo(() => ({\n    theme: 'dark',\n    size: 'large'\n  }), []); // Empty deps = never changes\n  \n  return <ChildComponent config={config} />;\n}\n\n// useCallback - Memoize functions\nfunction ParentWithCallback() {\n  const [count, setCount] = useState(0);\n  const [text, setText] = useState('');\n  \n  // Without useCallback: New function on every render\n  // const handleClick = () => setCount(count + 1);\n  \n  // With useCallback: Same function reference\n  const handleClick = useCallback(() => {\n    setCount(c => c + 1); // Use functional update!\n  }, []); // Empty deps because using functional update\n  \n  const handleTextChange = useCallback((newText) => {\n    setText(newText);\n  }, []);\n  \n  return (\n    <div>\n      <ExpensiveChild onClick={handleClick} />\n      <input value={text} onChange={e => handleTextChange(e.target.value)} />\n    </div>\n  );\n}\n\n// useCallback with React.memo\nconst ExpensiveChild = memo(function ExpensiveChild({ onClick, data }) {\n  console.log('ExpensiveChild rendered');\n  return <button onClick={onClick}>Click ({data})</button>;\n});\n\n// Combined example: Search with debounce\nfunction SearchComponent() {\n  const [query, setQuery] = useState('');\n  const [results, setResults] = useState([]);\n  \n  // Memoize the search function\n  const searchApi = useCallback(async (searchQuery) => {\n    const response = await fetch(`/api/search?q=${searchQuery}`);\n    const data = await response.json();\n    setResults(data);\n  }, []);\n  \n  // Memoize debounced search\n  const debouncedSearch = useMemo(\n    () => debounce(searchApi, 300),\n    [searchApi]\n  );\n  \n  // Memoize filtered results\n  const sortedResults = useMemo(\n    () => [...results].sort((a, b) => b.relevance - a.relevance),\n    [results]\n  );\n  \n  return (\n    <div>\n      <input \n        value={query}\n        onChange={(e) => {\n          setQuery(e.target.value);\n          debouncedSearch(e.target.value);\n        }}\n      />\n      <ResultsList results={sortedResults} />\n    </div>\n  );\n}\n\n// When NOT to use useMemo/useCallback\nfunction OverOptimized() {\n  // ❌ Don't memoize simple values\n  const doubled = useMemo(() => count * 2, [count]);\n  \n  // ✅ Just calculate directly\n  const doubled = count * 2;\n  \n  // ❌ Don't memoize if child isn't memoized\n  const handleClick = useCallback(() => {}, []);\n  return <NormalComponent onClick={handleClick} />; // Pointless!\n  \n  // ✅ Useful with memo'd components\n  return <MemoizedComponent onClick={handleClick} />;\n}"
        },
        {
          "type": "code",
          "language": "text",
          "title": "When to Use Memoization",
          "code": "┌─────────────────────────────────────────────────────────────────┐\n│                 WHEN TO USE MEMOIZATION                         │\n├─────────────────────────────────────────────────────────────────┤\n│                                                                 │\n│  USE useMemo WHEN:                                              │\n│  ✅ Expensive calculations (sorting, filtering large arrays)   │\n│  ✅ Creating objects/arrays passed to memoized children        │\n│  ✅ Values used in useEffect dependency arrays                 │\n│  ✅ Derived state that's expensive to compute                  │\n│                                                                 │\n│  DON'T USE useMemo WHEN:                                        │\n│  ❌ Simple calculations (count * 2)                            │\n│  ❌ The value is not passed to children or effects             │\n│  ❌ Adding more overhead than the calculation costs            │\n│                                                                 │\n│  USE useCallback WHEN:                                          │\n│  ✅ Passing callbacks to memoized (React.memo) children        │\n│  ✅ Callbacks used in useEffect dependency arrays              │\n│  ✅ Callbacks passed to custom hooks                           │\n│                                                                 │\n│  DON'T USE useCallback WHEN:                                    │\n│  ❌ Child component is not memoized                            │\n│  ❌ Function is simple and recreating is cheap                 │\n│  ❌ Premature optimization without profiling                   │\n│                                                                 │\n│  GOLDEN RULE: Profile first, optimize second!                  │\n│                                                                 │\n└─────────────────────────────────────────────────────────────────┘"
        },
        {
          "type": "title",
          "level": 2,
          "content": "useLayoutEffect Hook"
        },
        {
          "type": "description",
          "content": "useLayoutEffect is identical to useEffect, but fires synchronously after all DOM mutations and before the browser paints. Use it for DOM measurements and mutations that need to happen before the user sees the update."
        },
        {
          "type": "code",
          "language": "javascript",
          "title": "useLayoutEffect Examples",
          "code": "import { useLayoutEffect, useEffect, useRef, useState } from 'react';\n\n// Timing difference\nfunction TimingExample() {\n  useEffect(() => {\n    console.log('1. useEffect - after paint');\n  });\n  \n  useLayoutEffect(() => {\n    console.log('2. useLayoutEffect - before paint');\n  });\n  \n  // Output order:\n  // 2. useLayoutEffect - before paint\n  // 1. useEffect - after paint\n  return <div>Check console</div>;\n}\n\n// Measuring DOM elements\nfunction Tooltip({ targetRef, children }) {\n  const tooltipRef = useRef();\n  const [position, setPosition] = useState({ top: 0, left: 0 });\n  \n  // useLayoutEffect because we need to measure before paint\n  useLayoutEffect(() => {\n    if (targetRef.current && tooltipRef.current) {\n      const targetRect = targetRef.current.getBoundingClientRect();\n      const tooltipRect = tooltipRef.current.getBoundingClientRect();\n      \n      setPosition({\n        top: targetRect.bottom + 10,\n        left: targetRect.left + (targetRect.width - tooltipRect.width) / 2\n      });\n    }\n  }, [targetRef]);\n  \n  return (\n    <div\n      ref={tooltipRef}\n      style={{\n        position: 'fixed',\n        top: position.top,\n        left: position.left\n      }}\n    >\n      {children}\n    </div>\n  );\n}\n\n// Preventing visual flicker\nfunction ResizablePanel({ defaultWidth }) {\n  const panelRef = useRef();\n  const [width, setWidth] = useState(defaultWidth);\n  \n  // ❌ useEffect: User might see the default width briefly\n  // ✅ useLayoutEffect: Correct width shown immediately\n  useLayoutEffect(() => {\n    const savedWidth = localStorage.getItem('panelWidth');\n    if (savedWidth) {\n      setWidth(Number(savedWidth));\n    }\n  }, []);\n  \n  return (\n    <div ref={panelRef} style={{ width: `${width}px` }}>\n      Content\n    </div>\n  );\n}\n\n// Scroll restoration\nfunction ScrollToTop() {\n  useLayoutEffect(() => {\n    window.scrollTo(0, 0);\n  }, []);\n  \n  return null;\n}\n\n// Animation measurement\nfunction AnimatedList({ items }) {\n  const [heights, setHeights] = useState({});\n  const itemRefs = useRef({});\n  \n  useLayoutEffect(() => {\n    const newHeights = {};\n    Object.keys(itemRefs.current).forEach(key => {\n      if (itemRefs.current[key]) {\n        newHeights[key] = itemRefs.current[key].offsetHeight;\n      }\n    });\n    setHeights(newHeights);\n  }, [items]);\n  \n  return (\n    <ul>\n      {items.map(item => (\n        <li\n          key={item.id}\n          ref={el => itemRefs.current[item.id] = el}\n          style={{ height: heights[item.id] }}\n        >\n          {item.content}\n        </li>\n      ))}\n    </ul>\n  );\n}"
        },
        {
          "type": "interview-tip",
          "tip": "useEffect vs useLayoutEffect",
          "explanation": "useEffect: Runs asynchronously AFTER paint. Use for most side effects.\n\nuseLayoutEffect: Runs synchronously BEFORE paint. Use when:\n1. You need to measure DOM elements\n2. You need to mutate DOM before user sees it\n3. You need to prevent visual flicker\n4. You're animating based on layout\n\nWarning: useLayoutEffect can block painting. Prefer useEffect unless you have visual issues."
        },
        {
          "type": "title",
          "level": 2,
          "content": "useImperativeHandle Hook"
        },
        {
          "type": "description",
          "content": "useImperativeHandle customizes the instance value that is exposed to parent components when using ref. It lets you expose only specific methods to parents instead of the entire DOM element or component instance."
        },
        {
          "type": "code",
          "language": "javascript",
          "title": "useImperativeHandle Examples",
          "code": "import { useRef, useImperativeHandle, forwardRef, useState } from 'react';\n\n// Basic usage - Custom input component\nconst CustomInput = forwardRef(function CustomInput(props, ref) {\n  const inputRef = useRef();\n  \n  // Expose only specific methods to parent\n  useImperativeHandle(ref, () => ({\n    focus: () => {\n      inputRef.current.focus();\n    },\n    clear: () => {\n      inputRef.current.value = '';\n    },\n    getValue: () => {\n      return inputRef.current.value;\n    },\n    scrollIntoView: () => {\n      inputRef.current.scrollIntoView({ behavior: 'smooth' });\n    }\n  }), []); // Dependencies array\n  \n  return <input ref={inputRef} {...props} />;\n});\n\n// Usage in parent\nfunction ParentComponent() {\n  const inputRef = useRef();\n  \n  const handleSubmit = () => {\n    const value = inputRef.current.getValue();\n    console.log('Submitted:', value);\n    inputRef.current.clear();\n    inputRef.current.focus();\n  };\n  \n  return (\n    <div>\n      <CustomInput ref={inputRef} placeholder=\"Enter text\" />\n      <button onClick={handleSubmit}>Submit</button>\n    </div>\n  );\n}\n\n// Complex example - Form component\nconst Form = forwardRef(function Form({ children, onSubmit }, ref) {\n  const formRef = useRef();\n  const [isSubmitting, setIsSubmitting] = useState(false);\n  \n  useImperativeHandle(ref, () => ({\n    submit: async () => {\n      if (isSubmitting) return;\n      setIsSubmitting(true);\n      const formData = new FormData(formRef.current);\n      await onSubmit(formData);\n      setIsSubmitting(false);\n    },\n    reset: () => {\n      formRef.current.reset();\n    },\n    isValid: () => {\n      return formRef.current.checkValidity();\n    },\n    getFieldValue: (fieldName) => {\n      return formRef.current.elements[fieldName]?.value;\n    },\n    setFieldValue: (fieldName, value) => {\n      if (formRef.current.elements[fieldName]) {\n        formRef.current.elements[fieldName].value = value;\n      }\n    }\n  }), [isSubmitting, onSubmit]);\n  \n  return (\n    <form ref={formRef} onSubmit={(e) => e.preventDefault()}>\n      {children}\n    </form>\n  );\n});\n\n// Video player with imperative controls\nconst VideoPlayer = forwardRef(function VideoPlayer({ src }, ref) {\n  const videoRef = useRef();\n  \n  useImperativeHandle(ref, () => ({\n    play: () => videoRef.current.play(),\n    pause: () => videoRef.current.pause(),\n    stop: () => {\n      videoRef.current.pause();\n      videoRef.current.currentTime = 0;\n    },\n    seekTo: (time) => {\n      videoRef.current.currentTime = time;\n    },\n    getDuration: () => videoRef.current.duration,\n    getCurrentTime: () => videoRef.current.currentTime,\n    setVolume: (volume) => {\n      videoRef.current.volume = Math.max(0, Math.min(1, volume));\n    },\n    toggleFullscreen: () => {\n      if (document.fullscreenElement) {\n        document.exitFullscreen();\n      } else {\n        videoRef.current.requestFullscreen();\n      }\n    }\n  }), []);\n  \n  return <video ref={videoRef} src={src} />;\n});\n\n// Usage\nfunction VideoPage() {\n  const playerRef = useRef();\n  \n  return (\n    <div>\n      <VideoPlayer ref={playerRef} src=\"video.mp4\" />\n      <button onClick={() => playerRef.current.play()}>Play</button>\n      <button onClick={() => playerRef.current.pause()}>Pause</button>\n      <button onClick={() => playerRef.current.seekTo(0)}>Restart</button>\n    </div>\n  );\n}"
        }
      ]
    },
    {
      "id": "section-6",
      "title": "Event Handling",
      "blocks": [
        {
          "type": "title",
          "level": 1,
          "content": "Event Handling in React"
        },
        {
          "type": "description",
          "content": "React events are named using camelCase (onClick, onChange) and pass a SyntheticEvent object. SyntheticEvent is a cross-browser wrapper around the native event with the same interface. React uses event delegation - events are attached to the root, not individual elements."
        },
        {
          "type": "code",
          "language": "javascript",
          "title": "Event Handling Patterns",
          "code": "function EventHandlingExamples() {\n  // Basic event handler\n  const handleClick = (event) => {\n    console.log('Button clicked');\n    console.log('Event type:', event.type);\n    console.log('Target:', event.target);\n    console.log('Current Target:', event.currentTarget);\n  };\n\n  // Passing arguments\n  const handleItemClick = (itemId, event) => {\n    console.log('Clicked item:', itemId);\n    event.stopPropagation();\n  };\n\n  // Preventing default behavior\n  const handleSubmit = (event) => {\n    event.preventDefault(); // Prevent form submission\n    console.log('Form submitted');\n  };\n\n  // Input events\n  const [value, setValue] = useState('');\n  const handleChange = (event) => {\n    setValue(event.target.value);\n  };\n\n  // Keyboard events\n  const handleKeyDown = (event) => {\n    if (event.key === 'Enter') {\n      console.log('Enter pressed');\n    }\n    if (event.key === 'Escape') {\n      console.log('Escape pressed');\n    }\n    // Modifier keys\n    if (event.ctrlKey && event.key === 's') {\n      event.preventDefault();\n      console.log('Ctrl+S pressed');\n    }\n  };\n\n  // Mouse events\n  const handleMouseEvents = {\n    onClick: (e) => console.log('Click'),\n    onDoubleClick: (e) => console.log('Double click'),\n    onMouseEnter: (e) => console.log('Mouse enter'),\n    onMouseLeave: (e) => console.log('Mouse leave'),\n    onMouseMove: (e) => console.log(`Position: ${e.clientX}, ${e.clientY}`),\n    onMouseDown: (e) => console.log('Mouse down'),\n    onMouseUp: (e) => console.log('Mouse up'),\n    onContextMenu: (e) => {\n      e.preventDefault();\n      console.log('Right click');\n    }\n  };\n\n  // Focus events\n  const handleFocus = (e) => console.log('Focused');\n  const handleBlur = (e) => console.log('Blurred');\n\n  // Touch events (mobile)\n  const handleTouch = {\n    onTouchStart: (e) => console.log('Touch start'),\n    onTouchMove: (e) => console.log('Touch move'),\n    onTouchEnd: (e) => console.log('Touch end')\n  };\n\n  return (\n    <div>\n      {/* Basic click */}\n      <button onClick={handleClick}>Click me</button>\n      \n      {/* Passing arguments - use arrow function or bind */}\n      <button onClick={(e) => handleItemClick(123, e)}>Item 123</button>\n      <button onClick={handleItemClick.bind(null, 456)}>Item 456</button>\n      \n      {/* Form with submit */}\n      <form onSubmit={handleSubmit}>\n        <input \n          value={value} \n          onChange={handleChange}\n          onKeyDown={handleKeyDown}\n          onFocus={handleFocus}\n          onBlur={handleBlur}\n        />\n        <button type=\"submit\">Submit</button>\n      </form>\n      \n      {/* Mouse events */}\n      <div {...handleMouseEvents}>Hover and click me</div>\n      \n      {/* Event propagation */}\n      <div onClick={() => console.log('Parent clicked')}>\n        <button onClick={(e) => {\n          e.stopPropagation(); // Prevents bubbling to parent\n          console.log('Child clicked');\n        }}>\n          Click won't bubble\n        </button>\n      </div>\n    </div>\n  );\n}"
        },
        {
          "type": "title",
          "level": 2,
          "content": "Synthetic Events"
        },
        {
          "type": "code",
          "language": "javascript",
          "title": "Synthetic Event Details",
          "code": "function SyntheticEventExample() {\n  const handleClick = (event) => {\n    // Common properties\n    console.log(event.type);          // 'click'\n    console.log(event.target);        // DOM element that triggered event\n    console.log(event.currentTarget); // DOM element with handler attached\n    console.log(event.bubbles);       // true\n    console.log(event.defaultPrevented); // false initially\n    \n    // Access native event\n    console.log(event.nativeEvent);   // Native browser event\n    \n    // Mouse event properties\n    console.log(event.clientX, event.clientY); // Mouse position\n    console.log(event.button);        // Which button clicked\n    console.log(event.altKey);        // Alt key pressed\n    console.log(event.ctrlKey);       // Ctrl key pressed\n    console.log(event.shiftKey);      // Shift key pressed\n    console.log(event.metaKey);       // Meta (Cmd/Win) key\n    \n    // Methods\n    event.preventDefault();    // Prevent default action\n    event.stopPropagation();   // Stop event bubbling\n    event.persist();           // Keep event (needed in React 16 for async)\n    \n    // In React 17+, events are no longer pooled\n    // So persist() is not needed for async access\n    setTimeout(() => {\n      console.log(event.type); // Works in React 17+\n    }, 100);\n  };\n\n  return <button onClick={handleClick}>Click me</button>;\n}\n\n// Event Pooling (React 16 and earlier)\n// SyntheticEvents were pooled and reused\n// Properties nullified after callback\n// Had to call event.persist() for async access\n\n// React 17+: No more event pooling\n// Events can be accessed asynchronously without persist()"
        },
        {
          "type": "interview-tip",
          "tip": "Event Handling Best Practices",
          "explanation": "1) Use camelCase for event names. 2) Pass function reference, not function call. 3) Use arrow functions or bind for passing arguments. 4) Know the difference between target and currentTarget. 5) Understand event bubbling and capturing. 6) Know about event pooling changes in React 17."
        }
      ]
    },
    {
      "id": "section-7",
      "title": "Forms in React",
      "blocks": [
        {
          "type": "title",
          "level": 1,
          "content": "Controlled vs Uncontrolled Components"
        },
        {
          "type": "description",
          "content": "Controlled Components: Form data is handled by React state. The component controls what happens on every input change. Single source of truth.\n\nUncontrolled Components: Form data is handled by the DOM itself. You access values using refs. More similar to traditional HTML forms."
        },
        {
          "type": "code",
          "language": "javascript",
          "title": "Controlled vs Uncontrolled",
          "code": "import { useState, useRef } from 'react';\n\n// CONTROLLED COMPONENT\nfunction ControlledForm() {\n  const [formData, setFormData] = useState({\n    username: '',\n    email: '',\n    password: '',\n    age: 0,\n    gender: '',\n    hobbies: [],\n    bio: '',\n    newsletter: false\n  });\n\n  const handleChange = (event) => {\n    const { name, value, type, checked } = event.target;\n    \n    setFormData(prev => ({\n      ...prev,\n      [name]: type === 'checkbox' ? checked : value\n    }));\n  };\n\n  const handleMultiSelect = (event) => {\n    const { name, options } = event.target;\n    const selected = Array.from(options)\n      .filter(option => option.selected)\n      .map(option => option.value);\n    \n    setFormData(prev => ({ ...prev, [name]: selected }));\n  };\n\n  const handleSubmit = (event) => {\n    event.preventDefault();\n    console.log('Form data:', formData);\n  };\n\n  return (\n    <form onSubmit={handleSubmit}>\n      {/* Text input */}\n      <input\n        type=\"text\"\n        name=\"username\"\n        value={formData.username}\n        onChange={handleChange}\n        placeholder=\"Username\"\n      />\n\n      {/* Email input */}\n      <input\n        type=\"email\"\n        name=\"email\"\n        value={formData.email}\n        onChange={handleChange}\n      />\n\n      {/* Password input */}\n      <input\n        type=\"password\"\n        name=\"password\"\n        value={formData.password}\n        onChange={handleChange}\n      />\n\n      {/* Number input */}\n      <input\n        type=\"number\"\n        name=\"age\"\n        value={formData.age}\n        onChange={handleChange}\n      />\n\n      {/* Radio buttons */}\n      <label>\n        <input\n          type=\"radio\"\n          name=\"gender\"\n          value=\"male\"\n          checked={formData.gender === 'male'}\n          onChange={handleChange}\n        />\n        Male\n      </label>\n      <label>\n        <input\n          type=\"radio\"\n          name=\"gender\"\n          value=\"female\"\n          checked={formData.gender === 'female'}\n          onChange={handleChange}\n        />\n        Female\n      </label>\n\n      {/* Checkbox */}\n      <label>\n        <input\n          type=\"checkbox\"\n          name=\"newsletter\"\n          checked={formData.newsletter}\n          onChange={handleChange}\n        />\n        Subscribe to newsletter\n      </label>\n\n      {/* Select dropdown */}\n      <select name=\"country\" value={formData.country} onChange={handleChange}>\n        <option value=\"\">Select country</option>\n        <option value=\"usa\">USA</option>\n        <option value=\"uk\">UK</option>\n        <option value=\"india\">India</option>\n      </select>\n\n      {/* Multi-select */}\n      <select\n        name=\"hobbies\"\n        multiple\n        value={formData.hobbies}\n        onChange={handleMultiSelect}\n      >\n        <option value=\"reading\">Reading</option>\n        <option value=\"gaming\">Gaming</option>\n        <option value=\"sports\">Sports</option>\n      </select>\n\n      {/* Textarea */}\n      <textarea\n        name=\"bio\"\n        value={formData.bio}\n        onChange={handleChange}\n        rows={4}\n      />\n\n      <button type=\"submit\">Submit</button>\n    </form>\n  );\n}\n\n// UNCONTROLLED COMPONENT\nfunction UncontrolledForm() {\n  const usernameRef = useRef();\n  const emailRef = useRef();\n  const fileRef = useRef();\n\n  const handleSubmit = (event) => {\n    event.preventDefault();\n    \n    console.log('Username:', usernameRef.current.value);\n    console.log('Email:', emailRef.current.value);\n    console.log('File:', fileRef.current.files[0]);\n  };\n\n  return (\n    <form onSubmit={handleSubmit}>\n      {/* Default value for uncontrolled */}\n      <input\n        type=\"text\"\n        ref={usernameRef}\n        defaultValue=\"John\"\n      />\n      \n      <input\n        type=\"email\"\n        ref={emailRef}\n        defaultValue=\"john@example.com\"\n      />\n      \n      {/* File inputs are always uncontrolled */}\n      <input\n        type=\"file\"\n        ref={fileRef}\n      />\n      \n      <button type=\"submit\">Submit</button>\n    </form>\n  );\n}"
        },
        {
          "type": "interview-tip",
          "tip": "When to Use Each",
          "explanation": "Controlled: Instant validation, disable submit until valid, enforcing input format, dynamic inputs, form data in state. Uncontrolled: Simple forms, file inputs (always uncontrolled), integrating with non-React code, slightly better performance."
        },
        {
          "type": "title",
          "level": 2,
          "content": "Form Validation"
        },
        {
          "type": "code",
          "language": "javascript",
          "title": "Form Validation Patterns",
          "code": "function FormWithValidation() {\n  const [formData, setFormData] = useState({\n    email: '',\n    password: '',\n    confirmPassword: ''\n  });\n  \n  const [errors, setErrors] = useState({});\n  const [touched, setTouched] = useState({});\n\n  // Validation rules\n  const validate = (values) => {\n    const errors = {};\n    \n    // Email validation\n    if (!values.email) {\n      errors.email = 'Email is required';\n    } else if (!/^[A-Z0-9._%+-]+@[A-Z0-9.-]+\\.[A-Z]{2,}$/i.test(values.email)) {\n      errors.email = 'Invalid email address';\n    }\n    \n    // Password validation\n    if (!values.password) {\n      errors.password = 'Password is required';\n    } else if (values.password.length < 8) {\n      errors.password = 'Password must be at least 8 characters';\n    } else if (!/(?=.*[0-9])(?=.*[a-z])(?=.*[A-Z])/.test(values.password)) {\n      errors.password = 'Password must contain uppercase, lowercase, and number';\n    }\n    \n    // Confirm password\n    if (values.password !== values.confirmPassword) {\n      errors.confirmPassword = 'Passwords do not match';\n    }\n    \n    return errors;\n  };\n\n  // Validate single field\n  const validateField = (name, value) => {\n    const values = { ...formData, [name]: value };\n    const allErrors = validate(values);\n    return allErrors[name] || '';\n  };\n\n  const handleChange = (e) => {\n    const { name, value } = e.target;\n    setFormData(prev => ({ ...prev, [name]: value }));\n    \n    // Validate on change if field was touched\n    if (touched[name]) {\n      setErrors(prev => ({\n        ...prev,\n        [name]: validateField(name, value)\n      }));\n    }\n  };\n\n  const handleBlur = (e) => {\n    const { name, value } = e.target;\n    setTouched(prev => ({ ...prev, [name]: true }));\n    setErrors(prev => ({\n      ...prev,\n      [name]: validateField(name, value)\n    }));\n  };\n\n  const handleSubmit = (e) => {\n    e.preventDefault();\n    \n    // Validate all fields\n    const allErrors = validate(formData);\n    setErrors(allErrors);\n    setTouched({\n      email: true,\n      password: true,\n      confirmPassword: true\n    });\n    \n    // Check if form is valid\n    if (Object.keys(allErrors).length === 0) {\n      console.log('Form is valid, submitting...', formData);\n    }\n  };\n\n  const isValid = Object.keys(validate(formData)).length === 0;\n\n  return (\n    <form onSubmit={handleSubmit} noValidate>\n      <div className=\"form-group\">\n        <label htmlFor=\"email\">Email</label>\n        <input\n          type=\"email\"\n          id=\"email\"\n          name=\"email\"\n          value={formData.email}\n          onChange={handleChange}\n          onBlur={handleBlur}\n          className={touched.email && errors.email ? 'error' : ''}\n        />\n        {touched.email && errors.email && (\n          <span className=\"error-message\">{errors.email}</span>\n        )}\n      </div>\n\n      <div className=\"form-group\">\n        <label htmlFor=\"password\">Password</label>\n        <input\n          type=\"password\"\n          id=\"password\"\n          name=\"password\"\n          value={formData.password}\n          onChange={handleChange}\n          onBlur={handleBlur}\n          className={touched.password && errors.password ? 'error' : ''}\n        />\n        {touched.password && errors.password && (\n          <span className=\"error-message\">{errors.password}</span>\n        )}\n      </div>\n\n      <div className=\"form-group\">\n        <label htmlFor=\"confirmPassword\">Confirm Password</label>\n        <input\n          type=\"password\"\n          id=\"confirmPassword\"\n          name=\"confirmPassword\"\n          value={formData.confirmPassword}\n          onChange={handleChange}\n          onBlur={handleBlur}\n        />\n        {touched.confirmPassword && errors.confirmPassword && (\n          <span className=\"error-message\">{errors.confirmPassword}</span>\n        )}\n      </div>\n\n      <button type=\"submit\" disabled={!isValid}>\n        Submit\n      </button>\n    </form>\n  );\n}"
        }
      ]
    },
     {
      "id": "section-8",
      "title": "Component Lifecycle & Effects Deep Dive",
      "blocks": [
        {
          "type": "title",
          "level": 1,
          "content": "Component Lifecycle Overview"
        },
        {
          "type": "description",
          "content": "Every React component goes through a lifecycle: Mounting (component is created and inserted into DOM), Updating (component re-renders due to state/props changes), and Unmounting (component is removed from DOM). Understanding this lifecycle is crucial for managing side effects and optimizing performance."
        },
        {
          "type": "code",
          "language": "text",
          "title": "Component Lifecycle Phases",
          "code": "┌─────────────────────────────────────────────────────────────────┐\n│                    COMPONENT LIFECYCLE                          │\n├─────────────────────────────────────────────────────────────────┤\n│                                                                 │\n│  ┌─────────────────── MOUNTING ───────────────────┐            │\n│  │                                                 │            │\n│  │  1. constructor() / useState initialization    │            │\n│  │  2. render()                                    │            │\n│  │  3. DOM updated                                 │            │\n│  │  4. componentDidMount() / useEffect(() => {}, [])          │\n│  │                                                 │            │\n│  └─────────────────────────────────────────────────┘            │\n│                          │                                      │\n│                          ▼                                      │\n│  ┌─────────────────── UPDATING ───────────────────┐            │\n│  │                                                 │            │\n│  │  1. New props / setState / forceUpdate         │            │\n│  │  2. shouldComponentUpdate() / React.memo       │            │\n│  │  3. render()                                    │            │\n│  │  4. getSnapshotBeforeUpdate()                  │            │\n│  │  5. DOM updated                                 │            │\n│  │  6. componentDidUpdate() / useEffect with deps │            │\n│  │                                                 │            │\n│  └─────────────────────────────────────────────────┘            │\n│                          │                                      │\n│                          ▼                                      │\n│  ┌─────────────────── UNMOUNTING ─────────────────┐            │\n│  │                                                 │            │\n│  │  1. componentWillUnmount() / useEffect cleanup │            │\n│  │  2. Component removed from DOM                 │            │\n│  │                                                 │            │\n│  └─────────────────────────────────────────────────┘            │\n│                                                                 │\n└─────────────────────────────────────────────────────────────────┘"
        },
        {
          "type": "code",
          "language": "javascript",
          "title": "Lifecycle Methods to Hooks Mapping",
          "code": "import { useState, useEffect, useRef, useLayoutEffect } from 'react';\n\nfunction LifecycleWithHooks({ someProp }) {\n  const [count, setCount] = useState(0);\n  const prevCountRef = useRef();\n  const isFirstRender = useRef(true);\n\n  // componentDidMount - runs once after first render\n  useEffect(() => {\n    console.log('Component mounted');\n    // Setup subscriptions, fetch initial data, etc.\n    \n    // componentWillUnmount - cleanup function\n    return () => {\n      console.log('Component will unmount');\n      // Cleanup subscriptions, timers, etc.\n    };\n  }, []); // Empty dependency array = run once\n\n  // componentDidUpdate - runs on every update\n  useEffect(() => {\n    // Skip first render to mimic componentDidUpdate\n    if (isFirstRender.current) {\n      isFirstRender.current = false;\n      return;\n    }\n    console.log('Component updated');\n  });\n\n  // componentDidUpdate with specific prop\n  useEffect(() => {\n    console.log('someProp changed:', someProp);\n  }, [someProp]);\n\n  // getDerivedStateFromProps alternative\n  // In most cases, you don't need this - just compute during render\n  const derivedValue = someProp * 2;\n\n  // getSnapshotBeforeUpdate alternative\n  useLayoutEffect(() => {\n    // This runs synchronously after DOM mutations\n    // but before browser paint\n    const scrollPosition = window.scrollY;\n    \n    return () => {\n      // Previous scroll position available here\n    };\n  });\n\n  // Store previous value (like componentDidUpdate prev comparison)\n  useEffect(() => {\n    prevCountRef.current = count;\n  }, [count]);\n  \n  const prevCount = prevCountRef.current;\n\n  // shouldComponentUpdate - use React.memo for functional components\n  // Shown in parent component wrapping\n\n  return (\n    <div>\n      <p>Current: {count}, Previous: {prevCount}</p>\n      <p>Derived: {derivedValue}</p>\n      <button onClick={() => setCount(c => c + 1)}>Increment</button>\n    </div>\n  );\n}\n\n// shouldComponentUpdate equivalent with React.memo\nconst MemoizedComponent = React.memo(\n  function MyComponent({ value, onClick }) {\n    console.log('Rendering...');\n    return <button onClick={onClick}>{value}</button>;\n  },\n  // Custom comparison function (optional)\n  (prevProps, nextProps) => {\n    // Return true if props are equal (skip re-render)\n    // Return false if props changed (re-render)\n    return prevProps.value === nextProps.value;\n  }\n);"
        },
        {
          "type": "title",
          "level": 2,
          "content": "Class Component Lifecycle Methods"
        },
        {
          "type": "code",
          "language": "javascript",
          "title": "All Class Lifecycle Methods",
          "code": "import React, { Component } from 'react';\n\nclass FullLifecycleComponent extends Component {\n  // ============= MOUNTING PHASE =============\n  \n  constructor(props) {\n    super(props);\n    // Initialize state\n    this.state = {\n      count: 0,\n      data: null\n    };\n    // Bind methods\n    this.handleClick = this.handleClick.bind(this);\n    console.log('1. Constructor');\n  }\n\n  static getDerivedStateFromProps(props, state) {\n    // Called before every render\n    // Return object to update state, or null\n    console.log('2. getDerivedStateFromProps');\n    if (props.resetCount && state.count !== 0) {\n      return { count: 0 };\n    }\n    return null;\n  }\n\n  componentDidMount() {\n    // Called once after first render\n    // Perfect for: API calls, subscriptions, DOM manipulation\n    console.log('4. componentDidMount');\n    this.fetchData();\n    this.subscription = eventEmitter.subscribe(this.handleEvent);\n  }\n\n  // ============= UPDATING PHASE =============\n\n  shouldComponentUpdate(nextProps, nextState) {\n    // Return false to prevent re-render\n    // Default: true\n    console.log('shouldComponentUpdate');\n    return nextState.count !== this.state.count;\n  }\n\n  getSnapshotBeforeUpdate(prevProps, prevState) {\n    // Called right before DOM updates\n    // Return value passed to componentDidUpdate\n    console.log('getSnapshotBeforeUpdate');\n    // Example: Capture scroll position\n    return { scrollPosition: window.scrollY };\n  }\n\n  componentDidUpdate(prevProps, prevState, snapshot) {\n    // Called after every re-render (not initial)\n    console.log('componentDidUpdate', snapshot);\n    \n    // Compare props/state to decide if side effect needed\n    if (prevProps.userId !== this.props.userId) {\n      this.fetchData();\n    }\n    \n    // Use snapshot from getSnapshotBeforeUpdate\n    if (snapshot) {\n      window.scrollTo(0, snapshot.scrollPosition);\n    }\n  }\n\n  // ============= UNMOUNTING PHASE =============\n\n  componentWillUnmount() {\n    // Called right before component is removed\n    // Perfect for: Cleanup subscriptions, timers, etc.\n    console.log('componentWillUnmount');\n    this.subscription.unsubscribe();\n    clearInterval(this.timer);\n  }\n\n  // ============= ERROR HANDLING =============\n\n  static getDerivedStateFromError(error) {\n    // Update state to show fallback UI\n    return { hasError: true, error };\n  }\n\n  componentDidCatch(error, errorInfo) {\n    // Log error to service\n    console.error('Error:', error);\n    console.error('Error Info:', errorInfo.componentStack);\n    logErrorToService(error, errorInfo);\n  }\n\n  // ============= RENDER =============\n\n  render() {\n    console.log('3. Render');\n    \n    if (this.state.hasError) {\n      return <h1>Something went wrong.</h1>;\n    }\n    \n    return (\n      <div>\n        <p>Count: {this.state.count}</p>\n        <button onClick={this.handleClick}>Increment</button>\n      </div>\n    );\n  }\n\n  // ============= HELPER METHODS =============\n\n  handleClick() {\n    this.setState(prevState => ({ count: prevState.count + 1 }));\n  }\n\n  fetchData() {\n    // Fetch data logic\n  }\n\n  handleEvent = (data) => {\n    this.setState({ data });\n  }\n}"
        },
        {
          "type": "interview-tip",
          "tip": "Deprecated Lifecycle Methods",
          "explanation": "These methods are deprecated (UNSAFE_ prefix):\n\n1. componentWillMount → Use constructor or useEffect\n2. componentWillReceiveProps → Use getDerivedStateFromProps or useEffect\n3. componentWillUpdate → Use getSnapshotBeforeUpdate\n\nReason: These can be called multiple times in React's async rendering mode (Concurrent Mode), leading to bugs."
        },
        {
          "type": "title",
          "level": 2,
          "content": "Custom Hooks for Lifecycle"
        },
        {
          "type": "code",
          "language": "javascript",
          "title": "Lifecycle Custom Hooks",
          "code": "import { useEffect, useRef, useState, useCallback } from 'react';\n\n// useMount - Run effect only on mount\nfunction useMount(callback) {\n  useEffect(() => {\n    callback();\n  }, []); // eslint-disable-line react-hooks/exhaustive-deps\n}\n\n// useUnmount - Run cleanup only on unmount\nfunction useUnmount(callback) {\n  const callbackRef = useRef(callback);\n  callbackRef.current = callback;\n  \n  useEffect(() => {\n    return () => callbackRef.current();\n  }, []);\n}\n\n// useUpdateEffect - Skip first render, run on updates only\nfunction useUpdateEffect(effect, deps) {\n  const isFirstMount = useRef(true);\n  \n  useEffect(() => {\n    if (isFirstMount.current) {\n      isFirstMount.current = false;\n      return;\n    }\n    return effect();\n  }, deps); // eslint-disable-line react-hooks/exhaustive-deps\n}\n\n// usePrevious - Get previous value\nfunction usePrevious(value) {\n  const ref = useRef();\n  \n  useEffect(() => {\n    ref.current = value;\n  }, [value]);\n  \n  return ref.current;\n}\n\n// useIsMounted - Check if component is still mounted\nfunction useIsMounted() {\n  const isMounted = useRef(false);\n  \n  useEffect(() => {\n    isMounted.current = true;\n    return () => {\n      isMounted.current = false;\n    };\n  }, []);\n  \n  return useCallback(() => isMounted.current, []);\n}\n\n// useFirstRender - Check if it's the first render\nfunction useFirstRender() {\n  const isFirst = useRef(true);\n  \n  if (isFirst.current) {\n    isFirst.current = false;\n    return true;\n  }\n  \n  return false;\n}\n\n// useDidUpdate - Run effect when specific value changes\nfunction useDidUpdate(callback, deps, condition) {\n  const hasMount = useRef(false);\n  \n  useEffect(() => {\n    if (hasMount.current) {\n      if (condition === undefined || condition) {\n        callback();\n      }\n    } else {\n      hasMount.current = true;\n    }\n  }, deps); // eslint-disable-line react-hooks/exhaustive-deps\n}\n\n// useLifecycle - Combined mount/unmount\nfunction useLifecycle(mount, unmount) {\n  useEffect(() => {\n    if (mount) mount();\n    return () => {\n      if (unmount) unmount();\n    };\n  }, []); // eslint-disable-line react-hooks/exhaustive-deps\n}\n\n// Usage examples\nfunction MyComponent({ userId }) {\n  const [data, setData] = useState(null);\n  const prevUserId = usePrevious(userId);\n  const isMounted = useIsMounted();\n  const isFirst = useFirstRender();\n  \n  useMount(() => {\n    console.log('Component mounted');\n  });\n  \n  useUnmount(() => {\n    console.log('Component will unmount');\n  });\n  \n  useUpdateEffect(() => {\n    console.log('userId changed from', prevUserId, 'to', userId);\n  }, [userId]);\n  \n  useEffect(() => {\n    async function fetchData() {\n      const result = await api.getUser(userId);\n      if (isMounted()) {\n        setData(result);\n      }\n    }\n    fetchData();\n  }, [userId, isMounted]);\n  \n  return (\n    <div>\n      {isFirst && <p>First render!</p>}\n      <p>Previous userId: {prevUserId}</p>\n      <p>Current userId: {userId}</p>\n    </div>\n  );\n}"
        }
      ]
    },
    {
      "id": "section-9",
      "title": "Context API Deep Dive",
      "blocks": [
        {
          "type": "title",
          "level": 1,
          "content": "Context API Complete Guide"
        },
        {
          "type": "description",
          "content": "Context provides a way to pass data through the component tree without having to pass props manually at every level. It's designed for data that can be considered 'global' for a tree of React components, such as current authenticated user, theme, or preferred language."
        },
        {
          "type": "code",
          "language": "javascript",
          "title": "Context API Fundamentals",
          "code": "import React, { createContext, useContext, useState, useMemo, useCallback } from 'react';\n\n// ============= CREATING CONTEXT =============\n\n// 1. Create context with default value\nconst ThemeContext = createContext('light');\n\n// 2. With undefined default (must be inside Provider)\nconst UserContext = createContext(undefined);\n\n// 3. With object default\nconst AppContext = createContext({\n  theme: 'light',\n  language: 'en',\n  toggleTheme: () => {},\n});\n\n// ============= PROVIDER PATTERN =============\n\n// Simple Provider\nfunction ThemeProvider({ children }) {\n  const [theme, setTheme] = useState('light');\n  \n  const toggleTheme = useCallback(() => {\n    setTheme(prev => prev === 'light' ? 'dark' : 'light');\n  }, []);\n  \n  // Memoize value to prevent unnecessary re-renders\n  const value = useMemo(() => ({\n    theme,\n    toggleTheme,\n    isDark: theme === 'dark'\n  }), [theme, toggleTheme]);\n  \n  return (\n    <ThemeContext.Provider value={value}>\n      {children}\n    </ThemeContext.Provider>\n  );\n}\n\n// ============= CONSUMING CONTEXT =============\n\n// Method 1: useContext hook (recommended)\nfunction ThemedButton() {\n  const { theme, toggleTheme, isDark } = useContext(ThemeContext);\n  \n  return (\n    <button\n      onClick={toggleTheme}\n      style={{\n        background: isDark ? '#333' : '#fff',\n        color: isDark ? '#fff' : '#333'\n      }}\n    >\n      Current: {theme}\n    </button>\n  );\n}\n\n// Method 2: Context.Consumer (older pattern, still works)\nfunction ThemedButtonConsumer() {\n  return (\n    <ThemeContext.Consumer>\n      {({ theme, toggleTheme }) => (\n        <button onClick={toggleTheme}>\n          Theme: {theme}\n        </button>\n      )}\n    </ThemeContext.Consumer>\n  );\n}\n\n// Method 3: contextType (class components only)\nclass ThemedButtonClass extends React.Component {\n  static contextType = ThemeContext;\n  \n  render() {\n    const { theme, toggleTheme } = this.context;\n    return <button onClick={toggleTheme}>{theme}</button>;\n  }\n}"
        },
        {
          "type": "title",
          "level": 2,
          "content": "Custom Hook Pattern for Context"
        },
        {
          "type": "code",
          "language": "javascript",
          "title": "Best Practice: Custom Hook + Context",
          "code": "import { createContext, useContext, useState, useMemo, useCallback, useReducer } from 'react';\n\n// ============= AUTHENTICATION CONTEXT =============\n\nconst AuthContext = createContext(undefined);\n\n// Custom hook with error handling\nfunction useAuth() {\n  const context = useContext(AuthContext);\n  \n  if (context === undefined) {\n    throw new Error('useAuth must be used within an AuthProvider');\n  }\n  \n  return context;\n}\n\n// Provider component\nfunction AuthProvider({ children }) {\n  const [user, setUser] = useState(null);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState(null);\n\n  const login = useCallback(async (email, password) => {\n    try {\n      setLoading(true);\n      setError(null);\n      const response = await authService.login(email, password);\n      setUser(response.user);\n      localStorage.setItem('token', response.token);\n    } catch (err) {\n      setError(err.message);\n      throw err;\n    } finally {\n      setLoading(false);\n    }\n  }, []);\n\n  const logout = useCallback(async () => {\n    try {\n      await authService.logout();\n      setUser(null);\n      localStorage.removeItem('token');\n    } catch (err) {\n      console.error('Logout error:', err);\n    }\n  }, []);\n\n  const register = useCallback(async (userData) => {\n    try {\n      setLoading(true);\n      const response = await authService.register(userData);\n      setUser(response.user);\n      return response;\n    } catch (err) {\n      setError(err.message);\n      throw err;\n    } finally {\n      setLoading(false);\n    }\n  }, []);\n\n  // Check auth status on mount\n  useEffect(() => {\n    const checkAuth = async () => {\n      try {\n        const token = localStorage.getItem('token');\n        if (token) {\n          const user = await authService.getProfile();\n          setUser(user);\n        }\n      } catch (err) {\n        localStorage.removeItem('token');\n      } finally {\n        setLoading(false);\n      }\n    };\n    checkAuth();\n  }, []);\n\n  const value = useMemo(() => ({\n    user,\n    loading,\n    error,\n    isAuthenticated: !!user,\n    login,\n    logout,\n    register,\n  }), [user, loading, error, login, logout, register]);\n\n  return (\n    <AuthContext.Provider value={value}>\n      {children}\n    </AuthContext.Provider>\n  );\n}\n\n// ============= USAGE =============\n\nfunction App() {\n  return (\n    <AuthProvider>\n      <Router>\n        <Routes>\n          <Route path=\"/login\" element={<LoginPage />} />\n          <Route path=\"/dashboard\" element={<ProtectedRoute><Dashboard /></ProtectedRoute>} />\n        </Routes>\n      </Router>\n    </AuthProvider>\n  );\n}\n\nfunction ProtectedRoute({ children }) {\n  const { isAuthenticated, loading } = useAuth();\n  \n  if (loading) {\n    return <LoadingSpinner />;\n  }\n  \n  if (!isAuthenticated) {\n    return <Navigate to=\"/login\" />;\n  }\n  \n  return children;\n}\n\nfunction LoginPage() {\n  const { login, error, loading } = useAuth();\n  const [email, setEmail] = useState('');\n  const [password, setPassword] = useState('');\n\n  const handleSubmit = async (e) => {\n    e.preventDefault();\n    try {\n      await login(email, password);\n      navigate('/dashboard');\n    } catch (err) {\n      // Error is set in context\n    }\n  };\n\n  return (\n    <form onSubmit={handleSubmit}>\n      {error && <div className=\"error\">{error}</div>}\n      <input value={email} onChange={e => setEmail(e.target.value)} />\n      <input type=\"password\" value={password} onChange={e => setPassword(e.target.value)} />\n      <button disabled={loading}>{loading ? 'Loading...' : 'Login'}</button>\n    </form>\n  );\n}\n\nfunction Dashboard() {\n  const { user, logout } = useAuth();\n  \n  return (\n    <div>\n      <h1>Welcome, {user.name}!</h1>\n      <button onClick={logout}>Logout</button>\n    </div>\n  );\n}"
        },
        {
          "type": "title",
          "level": 2,
          "content": "Multiple Contexts Pattern"
        },
        {
          "type": "code",
          "language": "javascript",
          "title": "Combining Multiple Contexts",
          "code": "// ============= SEPARATE CONTEXTS =============\n\nconst ThemeContext = createContext();\nconst LanguageContext = createContext();\nconst UserContext = createContext();\nconst NotificationContext = createContext();\n\n// ============= INDIVIDUAL PROVIDERS =============\n\nfunction ThemeProvider({ children }) {\n  const [theme, setTheme] = useState('light');\n  const value = useMemo(() => ({ theme, setTheme }), [theme]);\n  return <ThemeContext.Provider value={value}>{children}</ThemeContext.Provider>;\n}\n\nfunction LanguageProvider({ children }) {\n  const [language, setLanguage] = useState('en');\n  const value = useMemo(() => ({ language, setLanguage }), [language]);\n  return <LanguageContext.Provider value={value}>{children}</LanguageContext.Provider>;\n}\n\n// ============= COMBINED PROVIDER =============\n\nfunction AppProviders({ children }) {\n  return (\n    <ThemeProvider>\n      <LanguageProvider>\n        <UserProvider>\n          <NotificationProvider>\n            {children}\n          </NotificationProvider>\n        </UserProvider>\n      </LanguageProvider>\n    </ThemeProvider>\n  );\n}\n\n// Or use a compose function\nfunction composeProviders(...providers) {\n  return ({ children }) =>\n    providers.reduceRight(\n      (acc, Provider) => <Provider>{acc}</Provider>,\n      children\n    );\n}\n\nconst AppProviders = composeProviders(\n  ThemeProvider,\n  LanguageProvider,\n  UserProvider,\n  NotificationProvider\n);\n\n// ============= USING MULTIPLE CONTEXTS =============\n\nfunction Header() {\n  const { theme, setTheme } = useContext(ThemeContext);\n  const { language, setLanguage } = useContext(LanguageContext);\n  const { user } = useContext(UserContext);\n  \n  return (\n    <header className={`header-${theme}`}>\n      <h1>{translations[language].welcome}, {user?.name}</h1>\n      <select value={theme} onChange={e => setTheme(e.target.value)}>\n        <option value=\"light\">Light</option>\n        <option value=\"dark\">Dark</option>\n      </select>\n      <select value={language} onChange={e => setLanguage(e.target.value)}>\n        <option value=\"en\">English</option>\n        <option value=\"es\">Spanish</option>\n      </select>\n    </header>\n  );\n}"
        },
        {
          "type": "title",
          "level": 2,
          "content": "Context with useReducer"
        },
        {
          "type": "code",
          "language": "javascript",
          "title": "Context + Reducer Pattern",
          "code": "import { createContext, useContext, useReducer, useMemo } from 'react';\n\n// ============= DEFINE TYPES AND REDUCER =============\n\nconst ACTIONS = {\n  SET_USER: 'SET_USER',\n  LOGOUT: 'LOGOUT',\n  UPDATE_PROFILE: 'UPDATE_PROFILE',\n  SET_LOADING: 'SET_LOADING',\n  SET_ERROR: 'SET_ERROR',\n  CLEAR_ERROR: 'CLEAR_ERROR',\n};\n\nconst initialState = {\n  user: null,\n  loading: false,\n  error: null,\n  isAuthenticated: false,\n};\n\nfunction authReducer(state, action) {\n  switch (action.type) {\n    case ACTIONS.SET_USER:\n      return {\n        ...state,\n        user: action.payload,\n        isAuthenticated: true,\n        loading: false,\n        error: null,\n      };\n    case ACTIONS.LOGOUT:\n      return {\n        ...initialState,\n      };\n    case ACTIONS.UPDATE_PROFILE:\n      return {\n        ...state,\n        user: { ...state.user, ...action.payload },\n      };\n    case ACTIONS.SET_LOADING:\n      return {\n        ...state,\n        loading: action.payload,\n      };\n    case ACTIONS.SET_ERROR:\n      return {\n        ...state,\n        error: action.payload,\n        loading: false,\n      };\n    case ACTIONS.CLEAR_ERROR:\n      return {\n        ...state,\n        error: null,\n      };\n    default:\n      throw new Error(`Unknown action: ${action.type}`);\n  }\n}\n\n// ============= CREATE CONTEXTS =============\n\n// Separate state and dispatch contexts for optimization\nconst AuthStateContext = createContext();\nconst AuthDispatchContext = createContext();\n\n// ============= PROVIDER =============\n\nfunction AuthProvider({ children }) {\n  const [state, dispatch] = useReducer(authReducer, initialState);\n\n  // Create action creators\n  const actions = useMemo(() => ({\n    login: async (email, password) => {\n      dispatch({ type: ACTIONS.SET_LOADING, payload: true });\n      try {\n        const user = await authService.login(email, password);\n        dispatch({ type: ACTIONS.SET_USER, payload: user });\n        return user;\n      } catch (error) {\n        dispatch({ type: ACTIONS.SET_ERROR, payload: error.message });\n        throw error;\n      }\n    },\n    logout: () => {\n      authService.logout();\n      dispatch({ type: ACTIONS.LOGOUT });\n    },\n    updateProfile: (updates) => {\n      dispatch({ type: ACTIONS.UPDATE_PROFILE, payload: updates });\n    },\n    clearError: () => {\n      dispatch({ type: ACTIONS.CLEAR_ERROR });\n    },\n  }), []);\n\n  return (\n    <AuthStateContext.Provider value={state}>\n      <AuthDispatchContext.Provider value={actions}>\n        {children}\n      </AuthDispatchContext.Provider>\n    </AuthStateContext.Provider>\n  );\n}\n\n// ============= CUSTOM HOOKS =============\n\nfunction useAuthState() {\n  const context = useContext(AuthStateContext);\n  if (context === undefined) {\n    throw new Error('useAuthState must be used within AuthProvider');\n  }\n  return context;\n}\n\nfunction useAuthActions() {\n  const context = useContext(AuthDispatchContext);\n  if (context === undefined) {\n    throw new Error('useAuthActions must be used within AuthProvider');\n  }\n  return context;\n}\n\n// Combined hook for convenience\nfunction useAuth() {\n  return {\n    ...useAuthState(),\n    ...useAuthActions(),\n  };\n}\n\n// ============= USAGE =============\n\n// Component that only needs state (won't re-render on action changes)\nfunction UserAvatar() {\n  const { user } = useAuthState();\n  return <img src={user?.avatar} alt={user?.name} />;\n}\n\n// Component that only needs actions (won't re-render on state changes)\nfunction LogoutButton() {\n  const { logout } = useAuthActions();\n  return <button onClick={logout}>Logout</button>;\n}\n\n// Component that needs both\nfunction UserProfile() {\n  const { user, loading, error } = useAuthState();\n  const { updateProfile, clearError } = useAuthActions();\n  \n  if (loading) return <Spinner />;\n  if (error) return <Error message={error} onDismiss={clearError} />;\n  \n  return (\n    <div>\n      <h1>{user.name}</h1>\n      <button onClick={() => updateProfile({ name: 'New Name' })}>\n        Update Name\n      </button>\n    </div>\n  );\n}"
        },
        {
          "type": "interview-tip",
          "tip": "Context Performance Optimization",
          "explanation": "1. Split state and dispatch into separate contexts\n2. Memoize context values with useMemo\n3. Use multiple smaller contexts instead of one large one\n4. Components only re-render when their specific context changes\n5. Consider using selectors (like Zustand/Redux) for fine-grained subscriptions\n6. Don't put frequently changing values in context (use state management instead)"
        },
        {
          "type": "title",
          "level": 2,
          "content": "Context Limitations & When to Use Redux"
        },
        {
          "type": "code",
          "language": "text",
          "title": "Context vs Redux Decision Guide",
          "code": "┌─────────────────────────────────────────────────────────────────┐\n│              CONTEXT API vs REDUX COMPARISON                    │\n├─────────────────────────────────────────────────────────────────┤\n│                                                                 │\n│  USE CONTEXT WHEN:                                              │\n│  ✅ Simple global state (theme, auth, locale)                  │\n│  ✅ State changes infrequently                                  │\n│  ✅ Small to medium sized apps                                  │\n│  ✅ Want to avoid additional dependencies                       │\n│  ✅ State is consumed by few components                         │\n│                                                                 │\n│  USE REDUX WHEN:                                                │\n│  ✅ Complex state logic                                         │\n│  ✅ State changes frequently                                    │\n│  ✅ Many components need same state                             │\n│  ✅ Need time-travel debugging                                  │\n│  ✅ Need middleware for async logic                             │\n│  ✅ Want predictable state updates                              │\n│  ✅ Large team needs consistent patterns                        │\n│                                                                 │\n│  CONTEXT LIMITATIONS:                                           │\n│  ❌ No built-in way to prevent unnecessary re-renders          │\n│  ❌ All consumers re-render on any state change                │\n│  ❌ No middleware support                                       │\n│  ❌ No devtools for debugging                                   │\n│  ❌ Can become messy with complex state                         │\n│                                                                 │\n│  ALTERNATIVES TO CONSIDER:                                      │\n│  • Zustand - Simple, small, no boilerplate                     │\n│  • Jotai - Atomic state management                              │\n│  • Recoil - Facebook's atomic state                             │\n│  • Valtio - Proxy-based, mutable syntax                         │\n│                                                                 │\n└─────────────────────────────────────────────────────────────────┘"
        }
      ]
    },
    {
      "id": "section-10",
      "title": "Error Handling in React",
      "blocks": [
        {
          "type": "title",
          "level": 1,
          "content": "Error Boundaries"
        },
        {
          "type": "description",
          "content": "Error Boundaries are React components that catch JavaScript errors anywhere in their child component tree, log those errors, and display a fallback UI. They catch errors during rendering, in lifecycle methods, and in constructors. Error boundaries do NOT catch errors in event handlers, async code, SSR, or errors thrown in the error boundary itself."
        },
        {
          "type": "code",
          "language": "javascript",
          "title": "Error Boundary Implementation",
          "code": "import React, { Component } from 'react';\n\n// Error Boundary must be a class component\nclass ErrorBoundary extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      hasError: false,\n      error: null,\n      errorInfo: null\n    };\n  }\n\n  // Update state when an error occurs\n  static getDerivedStateFromError(error) {\n    // This is called during the \"render\" phase\n    return { hasError: true, error };\n  }\n\n  // Log error information\n  componentDidCatch(error, errorInfo) {\n    // This is called during the \"commit\" phase\n    console.error('Error caught by boundary:', error);\n    console.error('Component stack:', errorInfo.componentStack);\n    \n    // Log to external service\n    this.logErrorToService(error, errorInfo);\n    \n    this.setState({ errorInfo });\n  }\n\n  logErrorToService = (error, errorInfo) => {\n    // Send to error tracking service (Sentry, LogRocket, etc.)\n    // errorService.log({\n    //   error: error.toString(),\n    //   stack: error.stack,\n    //   componentStack: errorInfo.componentStack,\n    //   timestamp: new Date().toISOString()\n    // });\n  };\n\n  handleReset = () => {\n    this.setState({ hasError: false, error: null, errorInfo: null });\n  };\n\n  render() {\n    if (this.state.hasError) {\n      // Custom fallback UI\n      if (this.props.fallback) {\n        return this.props.fallback({\n          error: this.state.error,\n          errorInfo: this.state.errorInfo,\n          reset: this.handleReset\n        });\n      }\n\n      // Default fallback UI\n      return (\n        <div className=\"error-boundary\">\n          <h1>Something went wrong</h1>\n          <details>\n            <summary>Error Details</summary>\n            <pre>{this.state.error?.toString()}</pre>\n            <pre>{this.state.errorInfo?.componentStack}</pre>\n          </details>\n          <button onClick={this.handleReset}>Try Again</button>\n        </div>\n      );\n    }\n\n    return this.props.children;\n  }\n}\n\n// ============= USAGE PATTERNS =============\n\n// Wrap entire app\nfunction App() {\n  return (\n    <ErrorBoundary>\n      <Router>\n        <Routes />\n      </Router>\n    </ErrorBoundary>\n  );\n}\n\n// Wrap specific sections\nfunction Dashboard() {\n  return (\n    <div>\n      <Header />\n      <ErrorBoundary fallback={({ reset }) => (\n        <div>\n          <p>Widget failed to load</p>\n          <button onClick={reset}>Retry</button>\n        </div>\n      )}>\n        <AnalyticsWidget />\n      </ErrorBoundary>\n      <ErrorBoundary>\n        <RecentActivity />\n      </ErrorBoundary>\n    </div>\n  );\n}\n\n// Multiple granular boundaries\nfunction ProductList({ products }) {\n  return (\n    <div className=\"product-list\">\n      {products.map(product => (\n        <ErrorBoundary key={product.id} fallback={<ProductError />}>\n          <ProductCard product={product} />\n        </ErrorBoundary>\n      ))}\n    </div>\n  );\n}"
        },
        {
          "type": "title",
          "level": 2,
          "content": "Error Boundary with Functional Components"
        },
        {
          "type": "code",
          "language": "javascript",
          "title": "Using react-error-boundary Library",
          "code": "// Install: npm install react-error-boundary\nimport { ErrorBoundary, useErrorBoundary } from 'react-error-boundary';\n\n// Fallback component\nfunction ErrorFallback({ error, resetErrorBoundary }) {\n  return (\n    <div role=\"alert\" className=\"error-fallback\">\n      <h2>Something went wrong:</h2>\n      <pre style={{ color: 'red' }}>{error.message}</pre>\n      <button onClick={resetErrorBoundary}>Try again</button>\n    </div>\n  );\n}\n\n// Log error function\nfunction logError(error, info) {\n  console.error('Logged error:', error);\n  console.error('Component stack:', info.componentStack);\n}\n\n// Usage\nfunction App() {\n  return (\n    <ErrorBoundary\n      FallbackComponent={ErrorFallback}\n      onError={logError}\n      onReset={() => {\n        // Reset app state here\n        window.location.reload();\n      }}\n    >\n      <MyApp />\n    </ErrorBoundary>\n  );\n}\n\n// With reset keys - automatically resets when key changes\nfunction ProductPage({ productId }) {\n  return (\n    <ErrorBoundary\n      FallbackComponent={ErrorFallback}\n      resetKeys={[productId]}  // Resets when productId changes\n    >\n      <ProductDetails productId={productId} />\n    </ErrorBoundary>\n  );\n}\n\n// useErrorBoundary hook - throw errors from event handlers\nfunction UserProfile({ userId }) {\n  const { showBoundary } = useErrorBoundary();\n  const [user, setUser] = useState(null);\n\n  const handleDelete = async () => {\n    try {\n      await deleteUser(userId);\n    } catch (error) {\n      // This error will be caught by the error boundary\n      showBoundary(error);\n    }\n  };\n\n  return (\n    <div>\n      <h1>{user?.name}</h1>\n      <button onClick={handleDelete}>Delete Account</button>\n    </div>\n  );\n}\n\n// Inline fallback\nfunction Widget() {\n  return (\n    <ErrorBoundary\n      fallbackRender={({ error, resetErrorBoundary }) => (\n        <div>\n          <p>Error: {error.message}</p>\n          <button onClick={resetErrorBoundary}>Retry</button>\n        </div>\n      )}\n    >\n      <WidgetContent />\n    </ErrorBoundary>\n  );\n}"
        },
        {
          "type": "title",
          "level": 2,
          "content": "Handling Errors in Event Handlers"
        },
        {
          "type": "code",
          "language": "javascript",
          "title": "Error Handling Patterns",
          "code": "import { useState, useCallback } from 'react';\n\n// Error boundaries DON'T catch event handler errors\n// You need to handle them manually\n\n// Pattern 1: Local state for error handling\nfunction FormWithErrorHandling() {\n  const [error, setError] = useState(null);\n  const [loading, setLoading] = useState(false);\n\n  const handleSubmit = async (e) => {\n    e.preventDefault();\n    setError(null);\n    setLoading(true);\n\n    try {\n      await submitForm(formData);\n    } catch (err) {\n      setError(err.message);\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  return (\n    <form onSubmit={handleSubmit}>\n      {error && <div className=\"error\">{error}</div>}\n      {/* form fields */}\n      <button disabled={loading}>\n        {loading ? 'Submitting...' : 'Submit'}\n      </button>\n    </form>\n  );\n}\n\n// Pattern 2: Custom hook for async operations\nfunction useAsync(asyncFunction) {\n  const [state, setState] = useState({\n    data: null,\n    loading: false,\n    error: null\n  });\n\n  const execute = useCallback(async (...args) => {\n    setState({ data: null, loading: true, error: null });\n    \n    try {\n      const data = await asyncFunction(...args);\n      setState({ data, loading: false, error: null });\n      return data;\n    } catch (error) {\n      setState({ data: null, loading: false, error });\n      throw error;\n    }\n  }, [asyncFunction]);\n\n  return { ...state, execute };\n}\n\n// Usage\nfunction UserList() {\n  const { data: users, loading, error, execute: fetchUsers } = useAsync(api.getUsers);\n\n  useEffect(() => {\n    fetchUsers();\n  }, [fetchUsers]);\n\n  if (loading) return <Spinner />;\n  if (error) return <Error message={error.message} onRetry={fetchUsers} />;\n  return <ul>{users?.map(user => <li key={user.id}>{user.name}</li>)}</ul>;\n}\n\n// Pattern 3: Global error handling\nconst ErrorContext = createContext();\n\nfunction ErrorProvider({ children }) {\n  const [errors, setErrors] = useState([]);\n\n  const addError = useCallback((error) => {\n    const id = Date.now();\n    setErrors(prev => [...prev, { id, message: error.message }]);\n    \n    // Auto-remove after 5 seconds\n    setTimeout(() => {\n      setErrors(prev => prev.filter(e => e.id !== id));\n    }, 5000);\n  }, []);\n\n  const removeError = useCallback((id) => {\n    setErrors(prev => prev.filter(e => e.id !== id));\n  }, []);\n\n  return (\n    <ErrorContext.Provider value={{ errors, addError, removeError }}>\n      {children}\n      <ErrorToastContainer errors={errors} onDismiss={removeError} />\n    </ErrorContext.Provider>\n  );\n}\n\nfunction useError() {\n  return useContext(ErrorContext);\n}\n\n// Usage in components\nfunction DeleteButton({ itemId }) {\n  const { addError } = useError();\n\n  const handleDelete = async () => {\n    try {\n      await api.deleteItem(itemId);\n    } catch (error) {\n      addError(error);\n    }\n  };\n\n  return <button onClick={handleDelete}>Delete</button>;\n}"
        },
        {
          "type": "title",
          "level": 2,
          "content": "Handling Async Errors"
        },
        {
          "type": "code",
          "language": "javascript",
          "title": "Async Error Handling Patterns",
          "code": "import { useState, useEffect, useCallback } from 'react';\n\n// Pattern 1: Try-catch in useEffect\nfunction DataFetcher({ url }) {\n  const [data, setData] = useState(null);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState(null);\n\n  useEffect(() => {\n    let cancelled = false;\n\n    async function fetchData() {\n      try {\n        setLoading(true);\n        setError(null);\n        \n        const response = await fetch(url);\n        \n        if (!response.ok) {\n          throw new Error(`HTTP error! status: ${response.status}`);\n        }\n        \n        const json = await response.json();\n        \n        if (!cancelled) {\n          setData(json);\n        }\n      } catch (err) {\n        if (!cancelled) {\n          setError(err);\n        }\n      } finally {\n        if (!cancelled) {\n          setLoading(false);\n        }\n      }\n    }\n\n    fetchData();\n\n    return () => {\n      cancelled = true;\n    };\n  }, [url]);\n\n  if (loading) return <div>Loading...</div>;\n  if (error) return <div>Error: {error.message}</div>;\n  return <div>{JSON.stringify(data)}</div>;\n}\n\n// Pattern 2: AbortController for fetch cancellation\nfunction SearchResults({ query }) {\n  const [results, setResults] = useState([]);\n  const [error, setError] = useState(null);\n\n  useEffect(() => {\n    const controller = new AbortController();\n\n    async function search() {\n      try {\n        const response = await fetch(\n          `/api/search?q=${query}`,\n          { signal: controller.signal }\n        );\n        const data = await response.json();\n        setResults(data);\n      } catch (err) {\n        if (err.name !== 'AbortError') {\n          setError(err);\n        }\n      }\n    }\n\n    if (query) {\n      search();\n    }\n\n    return () => controller.abort();\n  }, [query]);\n\n  return (\n    <div>\n      {error && <div>Error: {error.message}</div>}\n      {results.map(result => <div key={result.id}>{result.title}</div>)}\n    </div>\n  );\n}\n\n// Pattern 3: Retry logic\nfunction useRetry(asyncFn, { maxRetries = 3, delay = 1000 } = {}) {\n  const [state, setState] = useState({\n    data: null,\n    error: null,\n    loading: false,\n    retryCount: 0\n  });\n\n  const execute = useCallback(async (...args) => {\n    setState(prev => ({ ...prev, loading: true, error: null }));\n\n    for (let attempt = 0; attempt <= maxRetries; attempt++) {\n      try {\n        const data = await asyncFn(...args);\n        setState({ data, error: null, loading: false, retryCount: attempt });\n        return data;\n      } catch (error) {\n        if (attempt === maxRetries) {\n          setState({ data: null, error, loading: false, retryCount: attempt });\n          throw error;\n        }\n        // Wait before retrying\n        await new Promise(resolve => setTimeout(resolve, delay * (attempt + 1)));\n      }\n    }\n  }, [asyncFn, maxRetries, delay]);\n\n  return { ...state, execute };\n}\n\n// Usage\nfunction ReliableDataFetcher() {\n  const { data, error, loading, retryCount, execute } = useRetry(\n    () => fetch('/api/data').then(r => r.json()),\n    { maxRetries: 3, delay: 1000 }\n  );\n\n  useEffect(() => {\n    execute();\n  }, [execute]);\n\n  if (loading) return <div>Loading... (attempt {retryCount + 1})</div>;\n  if (error) return <div>Failed after {retryCount + 1} attempts</div>;\n  return <div>{JSON.stringify(data)}</div>;\n}"
        },
        {
          "type": "interview-tip",
          "tip": "Error Handling Best Practices",
          "explanation": "1. Use Error Boundaries for render errors\n2. Handle event handler errors with try-catch\n3. Use custom hooks for async error handling\n4. Implement retry logic for network errors\n5. Log errors to external services (Sentry, LogRocket)\n6. Show user-friendly error messages\n7. Provide recovery options (retry buttons)\n8. Cancel ongoing requests on unmount\n9. Differentiate between error types (network, validation, etc.)"
        }
      ]
    },
    {
      "id": "section-11",
      "title": "React Router",
      "blocks": [
        {
          "type": "title",
          "level": 1,
          "content": "React Router v6 Complete Guide"
        },
        {
          "type": "description",
          "content": "React Router is the standard routing library for React. It enables navigation between views, allows changing the browser URL, and keeps the UI in sync with the URL. Version 6 introduced significant changes including simplified API, better bundle size, and improved nested routing."
        },
        {
          "type": "code",
          "language": "javascript",
          "title": "Basic Routing Setup",
          "code": "import { BrowserRouter, Routes, Route, Link, NavLink, Navigate } from 'react-router-dom';\n\n// Basic app structure\nfunction App() {\n  return (\n    <BrowserRouter>\n      <nav>\n        {/* Basic Link */}\n        <Link to=\"/\">Home</Link>\n        <Link to=\"/about\">About</Link>\n        \n        {/* NavLink with active styling */}\n        <NavLink \n          to=\"/products\" \n          className={({ isActive }) => isActive ? 'active' : ''}\n        >\n          Products\n        </NavLink>\n        \n        {/* NavLink with style */}\n        <NavLink\n          to=\"/contact\"\n          style={({ isActive }) => ({\n            color: isActive ? 'red' : 'blue'\n          })}\n        >\n          Contact\n        </NavLink>\n      </nav>\n\n      <Routes>\n        {/* Basic routes */}\n        <Route path=\"/\" element={<Home />} />\n        <Route path=\"/about\" element={<About />} />\n        <Route path=\"/products\" element={<Products />} />\n        <Route path=\"/contact\" element={<Contact />} />\n        \n        {/* Route with URL parameter */}\n        <Route path=\"/products/:productId\" element={<ProductDetail />} />\n        \n        {/* Nested routes */}\n        <Route path=\"/dashboard\" element={<Dashboard />}>\n          <Route index element={<DashboardHome />} />\n          <Route path=\"settings\" element={<Settings />} />\n          <Route path=\"profile\" element={<Profile />} />\n        </Route>\n        \n        {/* Redirect */}\n        <Route path=\"/old-path\" element={<Navigate to=\"/new-path\" replace />} />\n        \n        {/* 404 catch-all */}\n        <Route path=\"*\" element={<NotFound />} />\n      </Routes>\n    </BrowserRouter>\n  );\n}\n\n// HashRouter for static file hosting\nimport { HashRouter } from 'react-router-dom';\nfunction AppWithHash() {\n  return (\n    <HashRouter>\n      {/* URLs will be like: example.com/#/about */}\n      <Routes>{/* ... */}</Routes>\n    </HashRouter>\n  );\n}"
        },
        {
          "type": "title",
          "level": 2,
          "content": "Route Parameters & Hooks"
        },
        {
          "type": "code",
          "language": "javascript",
          "title": "React Router Hooks",
          "code": "import {\n  useParams,\n  useNavigate,\n  useLocation,\n  useSearchParams,\n  useMatch,\n  Outlet\n} from 'react-router-dom';\n\n// useParams - Access URL parameters\nfunction ProductDetail() {\n  const { productId } = useParams();\n  // URL: /products/123 => productId = \"123\"\n  \n  return <div>Product ID: {productId}</div>;\n}\n\n// Multiple params\n// Route: /categories/:categoryId/products/:productId\nfunction ProductInCategory() {\n  const { categoryId, productId } = useParams();\n  return <div>Category: {categoryId}, Product: {productId}</div>;\n}\n\n// useNavigate - Programmatic navigation\nfunction LoginForm() {\n  const navigate = useNavigate();\n\n  const handleSubmit = async (e) => {\n    e.preventDefault();\n    await login(credentials);\n    \n    // Navigate to dashboard\n    navigate('/dashboard');\n    \n    // Navigate with state\n    navigate('/dashboard', { state: { from: 'login' } });\n    \n    // Replace current entry (can't go back)\n    navigate('/dashboard', { replace: true });\n    \n    // Go back\n    navigate(-1);\n    \n    // Go forward\n    navigate(1);\n  };\n\n  return <form onSubmit={handleSubmit}>{/* ... */}</form>;\n}\n\n// useLocation - Access current location\nfunction CurrentPage() {\n  const location = useLocation();\n  \n  console.log(location.pathname);  // \"/products\"\n  console.log(location.search);    // \"?sort=price\"\n  console.log(location.hash);      // \"#details\"\n  console.log(location.state);     // { from: 'login' }\n  console.log(location.key);       // unique key\n  \n  return <div>Current path: {location.pathname}</div>;\n}\n\n// useSearchParams - Manage URL query parameters\nfunction ProductList() {\n  const [searchParams, setSearchParams] = useSearchParams();\n  \n  const sort = searchParams.get('sort') || 'name';\n  const page = parseInt(searchParams.get('page') || '1');\n  const categories = searchParams.getAll('category');\n  \n  const updateSort = (newSort) => {\n    setSearchParams({ sort: newSort, page: '1' });\n  };\n  \n  const updatePage = (newPage) => {\n    setSearchParams(prev => {\n      prev.set('page', newPage.toString());\n      return prev;\n    });\n  };\n  \n  const addCategory = (category) => {\n    setSearchParams(prev => {\n      prev.append('category', category);\n      return prev;\n    });\n  };\n\n  return (\n    <div>\n      <select value={sort} onChange={e => updateSort(e.target.value)}>\n        <option value=\"name\">Name</option>\n        <option value=\"price\">Price</option>\n      </select>\n      <button onClick={() => updatePage(page + 1)}>Next Page</button>\n      <p>Page: {page}, Sort: {sort}</p>\n    </div>\n  );\n}\n\n// useMatch - Check if current URL matches\nfunction TabNavigation() {\n  const matchProducts = useMatch('/products/*');\n  const matchAbout = useMatch('/about');\n  \n  return (\n    <nav>\n      <Link \n        to=\"/products\" \n        className={matchProducts ? 'active' : ''}\n      >\n        Products\n      </Link>\n      <Link \n        to=\"/about\"\n        className={matchAbout ? 'active' : ''}\n      >\n        About\n      </Link>\n    </nav>\n  );\n}"
        },
        {
          "type": "title",
          "level": 2,
          "content": "Nested Routes & Layout"
        },
        {
          "type": "code",
          "language": "javascript",
          "title": "Nested Routing Patterns",
          "code": "import { Routes, Route, Outlet, Link, useOutletContext } from 'react-router-dom';\n\n// Layout with Outlet\nfunction DashboardLayout() {\n  const [user] = useState({ name: 'John' });\n  \n  return (\n    <div className=\"dashboard\">\n      <aside className=\"sidebar\">\n        <nav>\n          <Link to=\"/dashboard\">Overview</Link>\n          <Link to=\"/dashboard/analytics\">Analytics</Link>\n          <Link to=\"/dashboard/settings\">Settings</Link>\n          <Link to=\"/dashboard/users\">Users</Link>\n        </nav>\n      </aside>\n      \n      <main className=\"content\">\n        {/* Outlet renders the matched child route */}\n        {/* Pass context to child routes */}\n        <Outlet context={{ user }} />\n      </main>\n    </div>\n  );\n}\n\n// Child component accessing context\nfunction DashboardSettings() {\n  const { user } = useOutletContext();\n  return <div>Settings for {user.name}</div>;\n}\n\n// Route configuration\nfunction App() {\n  return (\n    <Routes>\n      <Route path=\"/\" element={<Home />} />\n      \n      {/* Nested routes with layout */}\n      <Route path=\"/dashboard\" element={<DashboardLayout />}>\n        {/* index route - renders at /dashboard */}\n        <Route index element={<DashboardOverview />} />\n        \n        {/* Child routes */}\n        <Route path=\"analytics\" element={<Analytics />} />\n        <Route path=\"settings\" element={<DashboardSettings />} />\n        \n        {/* Nested within nested */}\n        <Route path=\"users\" element={<UsersLayout />}>\n          <Route index element={<UsersList />} />\n          <Route path=\":userId\" element={<UserDetail />} />\n          <Route path=\"new\" element={<CreateUser />} />\n        </Route>\n      </Route>\n      \n      {/* Multiple layouts */}\n      <Route element={<AuthLayout />}>\n        <Route path=\"/login\" element={<Login />} />\n        <Route path=\"/register\" element={<Register />} />\n      </Route>\n      \n      <Route path=\"*\" element={<NotFound />} />\n    </Routes>\n  );\n}\n\n// Pathless layout route\nfunction App() {\n  return (\n    <Routes>\n      {/* Pathless route for shared layout */}\n      <Route element={<MainLayout />}>\n        <Route path=\"/\" element={<Home />} />\n        <Route path=\"/about\" element={<About />} />\n        <Route path=\"/products\" element={<Products />} />\n      </Route>\n    </Routes>\n  );\n}\n\nfunction MainLayout() {\n  return (\n    <div>\n      <Header />\n      <Outlet />\n      <Footer />\n    </div>\n  );\n}"
        },
        {
          "type": "title",
          "level": 2,
          "content": "Protected Routes"
        },
        {
          "type": "code",
          "language": "javascript",
          "title": "Route Protection Patterns",
          "code": "import { Navigate, useLocation, Outlet } from 'react-router-dom';\n\n// Simple protected route\nfunction ProtectedRoute({ children }) {\n  const { isAuthenticated } = useAuth();\n  const location = useLocation();\n\n  if (!isAuthenticated) {\n    // Redirect to login, save the attempted location\n    return <Navigate to=\"/login\" state={{ from: location }} replace />;\n  }\n\n  return children;\n}\n\n// Usage\n<Route\n  path=\"/dashboard\"\n  element={\n    <ProtectedRoute>\n      <Dashboard />\n    </ProtectedRoute>\n  }\n/>\n\n// Protected route as layout (for multiple routes)\nfunction ProtectedLayout() {\n  const { isAuthenticated, loading } = useAuth();\n  const location = useLocation();\n\n  if (loading) {\n    return <LoadingSpinner />;\n  }\n\n  if (!isAuthenticated) {\n    return <Navigate to=\"/login\" state={{ from: location }} replace />;\n  }\n\n  return <Outlet />;\n}\n\n// Usage with layout\n<Routes>\n  <Route path=\"/login\" element={<Login />} />\n  \n  {/* All these routes are protected */}\n  <Route element={<ProtectedLayout />}>\n    <Route path=\"/dashboard\" element={<Dashboard />} />\n    <Route path=\"/profile\" element={<Profile />} />\n    <Route path=\"/settings\" element={<Settings />} />\n  </Route>\n</Routes>\n\n// Role-based protection\nfunction RoleProtectedRoute({ children, allowedRoles }) {\n  const { user, isAuthenticated } = useAuth();\n  const location = useLocation();\n\n  if (!isAuthenticated) {\n    return <Navigate to=\"/login\" state={{ from: location }} replace />;\n  }\n\n  if (!allowedRoles.includes(user.role)) {\n    return <Navigate to=\"/unauthorized\" replace />;\n  }\n\n  return children;\n}\n\n// Usage\n<Route\n  path=\"/admin\"\n  element={\n    <RoleProtectedRoute allowedRoles={['admin', 'superadmin']}>\n      <AdminPanel />\n    </RoleProtectedRoute>\n  }\n/>\n\n// Redirect after login\nfunction Login() {\n  const navigate = useNavigate();\n  const location = useLocation();\n  const { login } = useAuth();\n\n  const from = location.state?.from?.pathname || '/dashboard';\n\n  const handleSubmit = async (e) => {\n    e.preventDefault();\n    await login(credentials);\n    // Navigate back to the page they tried to visit\n    navigate(from, { replace: true });\n  };\n\n  return <form onSubmit={handleSubmit}>{/* ... */}</form>;\n}"
        },
        {
          "type": "title",
          "level": 2,
          "content": "Lazy Loading Routes"
        },
        {
          "type": "code",
          "language": "javascript",
          "title": "Code Splitting with React Router",
          "code": "import { lazy, Suspense } from 'react';\nimport { Routes, Route } from 'react-router-dom';\n\n// Lazy load components\nconst Home = lazy(() => import('./pages/Home'));\nconst About = lazy(() => import('./pages/About'));\nconst Dashboard = lazy(() => import('./pages/Dashboard'));\nconst Products = lazy(() => import('./pages/Products'));\nconst ProductDetail = lazy(() => import('./pages/ProductDetail'));\n\n// Loading component\nfunction PageLoader() {\n  return (\n    <div className=\"page-loader\">\n      <div className=\"spinner\"></div>\n      <p>Loading...</p>\n    </div>\n  );\n}\n\nfunction App() {\n  return (\n    <Suspense fallback={<PageLoader />}>\n      <Routes>\n        <Route path=\"/\" element={<Home />} />\n        <Route path=\"/about\" element={<About />} />\n        <Route path=\"/dashboard/*\" element={<Dashboard />} />\n        <Route path=\"/products\" element={<Products />} />\n        <Route path=\"/products/:id\" element={<ProductDetail />} />\n      </Routes>\n    </Suspense>\n  );\n}\n\n// Per-route Suspense for better UX\nfunction App() {\n  return (\n    <Routes>\n      <Route \n        path=\"/\" \n        element={\n          <Suspense fallback={<HomeLoader />}>\n            <Home />\n          </Suspense>\n        } \n      />\n      <Route \n        path=\"/dashboard\" \n        element={\n          <Suspense fallback={<DashboardLoader />}>\n            <Dashboard />\n          </Suspense>\n        } \n      />\n    </Routes>\n  );\n}\n\n// Named exports (for better debugging)\nconst Dashboard = lazy(() => \n  import('./pages/Dashboard').then(module => ({\n    default: module.Dashboard\n  }))\n);\n\n// Preload on hover\nconst ProductDetail = lazy(() => import('./pages/ProductDetail'));\n\nfunction ProductLink({ productId }) {\n  const handleMouseEnter = () => {\n    // Preload the component when user hovers\n    import('./pages/ProductDetail');\n  };\n\n  return (\n    <Link \n      to={`/products/${productId}`}\n      onMouseEnter={handleMouseEnter}\n    >\n      View Details\n    </Link>\n  );\n}\n\n// Route-based code splitting with error boundary\nimport { ErrorBoundary } from 'react-error-boundary';\n\nfunction LazyRoute({ component: Component, fallback, ...rest }) {\n  return (\n    <ErrorBoundary FallbackComponent={ErrorFallback}>\n      <Suspense fallback={fallback || <PageLoader />}>\n        <Component {...rest} />\n      </Suspense>\n    </ErrorBoundary>\n  );\n}"
        },
        {
          "type": "interview-tip",
          "tip": "React Router v6 Key Changes",
          "explanation": "From v5 to v6:\n1. Switch → Routes\n2. component prop → element prop (pass JSX)\n3. useHistory → useNavigate\n4. Redirect → Navigate component\n5. Nested routes are defined in parent\n6. Relative links are relative to parent route\n7. useRouteMatch → useMatch\n8. Route children → Outlet for nested routes\n9. No more exact prop (routes exact by default)\n10. Better bundle size and performance"
        }
      ]
    },
    {
      "id": "section-12",
      "title": "Performance Optimization",
      "blocks": [
        {
          "type": "title",
          "level": 1,
          "content": "React Performance Optimization Techniques"
        },
        {
          "type": "description",
          "content": "Performance optimization in React involves reducing unnecessary re-renders, minimizing bundle size, and optimizing rendering performance. The key is to measure first, then optimize - premature optimization is the root of all evil."
        },
        {
          "type": "code",
          "language": "text",
          "title": "Performance Optimization Overview",
          "code": "┌─────────────────────────────────────────────────────────────────┐\n│              REACT PERFORMANCE OPTIMIZATION                     │\n├─────────────────────────────────────────────────────────────────┤\n│                                                                 │\n│  1. PREVENT UNNECESSARY RE-RENDERS                              │\n│     • React.memo for functional components                      │\n│     • useMemo for expensive calculations                        │\n│     • useCallback for stable function references                │\n│     • Proper key usage in lists                                 │\n│     • State colocation (keep state close to where it's used)   │\n│                                                                 │\n│  2. OPTIMIZE BUNDLE SIZE                                        │\n│     • Code splitting with React.lazy                            │\n│     • Tree shaking                                              │\n│     • Dynamic imports                                           │\n│     • Analyze bundle with webpack-bundle-analyzer               │\n│                                                                 │\n│  3. OPTIMIZE RENDERING                                          │\n│     • Virtualization for long lists                             │\n│     • Debounce/throttle expensive operations                    │\n│     • Web Workers for heavy computation                         │\n│     • Suspense for data fetching                                │\n│                                                                 │\n│  4. OPTIMIZE IMAGES & ASSETS                                    │\n│     • Lazy load images                                          │\n│     • Use appropriate formats (WebP)                            │\n│     • Responsive images                                         │\n│     • CDN for static assets                                     │\n│                                                                 │\n│  5. MEASURE PERFORMANCE                                         │\n│     • React DevTools Profiler                                   │\n│     • Chrome Performance tab                                    │\n│     • Lighthouse audits                                         │\n│     • why-did-you-render library                               │\n│                                                                 │\n└─────────────────────────────────────────────────────────────────┘"
        },
        {
          "type": "title",
          "level": 2,
          "content": "React.memo Deep Dive"
        },
        {
          "type": "code",
          "language": "javascript",
          "title": "React.memo Patterns",
          "code": "import { memo, useState, useCallback, useMemo } from 'react';\n\n// Basic React.memo usage\nconst ExpensiveComponent = memo(function ExpensiveComponent({ data, onClick }) {\n  console.log('ExpensiveComponent rendered');\n  \n  return (\n    <div onClick={onClick}>\n      {data.map(item => (\n        <div key={item.id}>{item.name}</div>\n      ))}\n    </div>\n  );\n});\n\n// With custom comparison\nconst UserCard = memo(\n  function UserCard({ user, onEdit }) {\n    console.log('UserCard rendered:', user.id);\n    return (\n      <div>\n        <h3>{user.name}</h3>\n        <p>{user.email}</p>\n        <button onClick={() => onEdit(user.id)}>Edit</button>\n      </div>\n    );\n  },\n  // Custom comparison function\n  (prevProps, nextProps) => {\n    // Return true if props are equal (skip re-render)\n    return (\n      prevProps.user.id === nextProps.user.id &&\n      prevProps.user.name === nextProps.user.name &&\n      prevProps.user.email === nextProps.user.email\n    );\n  }\n);\n\n// Parent component with proper memoization\nfunction UserList() {\n  const [users, setUsers] = useState([]);\n  const [filter, setFilter] = useState('');\n\n  // ❌ BAD: Creates new function every render\n  // const handleEdit = (id) => console.log('Edit', id);\n\n  // ✅ GOOD: Stable function reference\n  const handleEdit = useCallback((id) => {\n    console.log('Edit user:', id);\n  }, []);\n\n  // ❌ BAD: Creates new array every render\n  // const filteredUsers = users.filter(u => u.name.includes(filter));\n\n  // ✅ GOOD: Memoized filtered array\n  const filteredUsers = useMemo(\n    () => users.filter(u => u.name.includes(filter)),\n    [users, filter]\n  );\n\n  return (\n    <div>\n      <input \n        value={filter} \n        onChange={e => setFilter(e.target.value)} \n      />\n      {filteredUsers.map(user => (\n        <UserCard \n          key={user.id} \n          user={user} \n          onEdit={handleEdit} \n        />\n      ))}\n    </div>\n  );\n}\n\n// When NOT to use React.memo\n// 1. Component re-renders rarely anyway\n// 2. Props change on almost every render\n// 3. Component is very simple and cheap to render\n// 4. You're passing children (usually different on each render)\n\n// Example: This memo is useless\nconst SimpleText = memo(({ text }) => <span>{text}</span>);\n// The comparison overhead might exceed the render cost!"
        },
        {
          "type": "title",
          "level": 2,
          "content": "List Virtualization"
        },
        {
          "type": "code",
          "language": "javascript",
          "title": "Virtualized Lists with react-window",
          "code": "// Install: npm install react-window\nimport { FixedSizeList, VariableSizeList, FixedSizeGrid } from 'react-window';\nimport AutoSizer from 'react-virtualized-auto-sizer';\n\n// Fixed size list\nfunction VirtualizedList({ items }) {\n  const Row = ({ index, style }) => (\n    <div style={style} className=\"list-item\">\n      <span>{items[index].name}</span>\n      <span>{items[index].email}</span>\n    </div>\n  );\n\n  return (\n    <FixedSizeList\n      height={400}       // Container height\n      width={300}        // Container width\n      itemCount={items.length}\n      itemSize={50}      // Height of each row\n    >\n      {Row}\n    </FixedSizeList>\n  );\n}\n\n// With AutoSizer for responsive sizing\nfunction ResponsiveList({ items }) {\n  return (\n    <div style={{ height: '100vh', width: '100%' }}>\n      <AutoSizer>\n        {({ height, width }) => (\n          <FixedSizeList\n            height={height}\n            width={width}\n            itemCount={items.length}\n            itemSize={60}\n          >\n            {({ index, style }) => (\n              <div style={style}>{items[index].name}</div>\n            )}\n          </FixedSizeList>\n        )}\n      </AutoSizer>\n    </div>\n  );\n}\n\n// Variable size list\nfunction VariableSizeListExample({ items }) {\n  const getItemSize = (index) => {\n    // Return different heights based on content\n    return items[index].content.length > 100 ? 100 : 50;\n  };\n\n  return (\n    <VariableSizeList\n      height={400}\n      width={300}\n      itemCount={items.length}\n      itemSize={getItemSize}\n    >\n      {({ index, style }) => (\n        <div style={style}>{items[index].content}</div>\n      )}\n    </VariableSizeList>\n  );\n}\n\n// Grid layout\nfunction VirtualizedGrid({ items, columnCount = 4 }) {\n  const rowCount = Math.ceil(items.length / columnCount);\n\n  const Cell = ({ columnIndex, rowIndex, style }) => {\n    const index = rowIndex * columnCount + columnIndex;\n    if (index >= items.length) return null;\n    \n    return (\n      <div style={style} className=\"grid-cell\">\n        <img src={items[index].image} alt={items[index].name} />\n        <p>{items[index].name}</p>\n      </div>\n    );\n  };\n\n  return (\n    <FixedSizeGrid\n      columnCount={columnCount}\n      columnWidth={200}\n      rowCount={rowCount}\n      rowHeight={250}\n      height={600}\n      width={800}\n    >\n      {Cell}\n    </FixedSizeGrid>\n  );\n}\n\n// Infinite scroll with virtualization\nimport InfiniteLoader from 'react-window-infinite-loader';\n\nfunction InfiniteList({ hasNextPage, isLoading, items, loadMore }) {\n  const itemCount = hasNextPage ? items.length + 1 : items.length;\n  const isItemLoaded = (index) => !hasNextPage || index < items.length;\n\n  return (\n    <InfiniteLoader\n      isItemLoaded={isItemLoaded}\n      itemCount={itemCount}\n      loadMoreItems={loadMore}\n    >\n      {({ onItemsRendered, ref }) => (\n        <FixedSizeList\n          ref={ref}\n          height={400}\n          width={300}\n          itemCount={itemCount}\n          itemSize={50}\n          onItemsRendered={onItemsRendered}\n        >\n          {({ index, style }) => (\n            <div style={style}>\n              {isItemLoaded(index) ? (\n                items[index].name\n              ) : (\n                'Loading...'\n              )}\n            </div>\n          )}\n        </FixedSizeList>\n      )}\n    </InfiniteLoader>\n  );\n}"
        },
        {
          "type": "title",
          "level": 2,
          "content": "Debounce & Throttle"
        },
        {
          "type": "code",
          "language": "javascript",
          "title": "Debounce and Throttle Patterns",
          "code": "import { useState, useCallback, useRef, useEffect } from 'react';\n\n// Custom useDebounce hook\nfunction useDebounce(value, delay) {\n  const [debouncedValue, setDebouncedValue] = useState(value);\n\n  useEffect(() => {\n    const timer = setTimeout(() => {\n      setDebouncedValue(value);\n    }, delay);\n\n    return () => clearTimeout(timer);\n  }, [value, delay]);\n\n  return debouncedValue;\n}\n\n// Usage: Debounced search\nfunction SearchInput() {\n  const [query, setQuery] = useState('');\n  const debouncedQuery = useDebounce(query, 300);\n  const [results, setResults] = useState([]);\n\n  useEffect(() => {\n    if (debouncedQuery) {\n      searchAPI(debouncedQuery).then(setResults);\n    }\n  }, [debouncedQuery]);\n\n  return (\n    <div>\n      <input\n        value={query}\n        onChange={e => setQuery(e.target.value)}\n        placeholder=\"Search...\"\n      />\n      <ul>\n        {results.map(item => (\n          <li key={item.id}>{item.name}</li>\n        ))}\n      </ul>\n    </div>\n  );\n}\n\n// Debounced callback hook\nfunction useDebouncedCallback(callback, delay) {\n  const timeoutRef = useRef(null);\n\n  const debouncedCallback = useCallback((...args) => {\n    if (timeoutRef.current) {\n      clearTimeout(timeoutRef.current);\n    }\n    \n    timeoutRef.current = setTimeout(() => {\n      callback(...args);\n    }, delay);\n  }, [callback, delay]);\n\n  // Cleanup on unmount\n  useEffect(() => {\n    return () => {\n      if (timeoutRef.current) {\n        clearTimeout(timeoutRef.current);\n      }\n    };\n  }, []);\n\n  return debouncedCallback;\n}\n\n// Throttle hook\nfunction useThrottle(value, interval) {\n  const [throttledValue, setThrottledValue] = useState(value);\n  const lastExecuted = useRef(Date.now());\n\n  useEffect(() => {\n    const now = Date.now();\n    const timeSinceLastExecution = now - lastExecuted.current;\n\n    if (timeSinceLastExecution >= interval) {\n      lastExecuted.current = now;\n      setThrottledValue(value);\n    } else {\n      const timer = setTimeout(() => {\n        lastExecuted.current = Date.now();\n        setThrottledValue(value);\n      }, interval - timeSinceLastExecution);\n\n      return () => clearTimeout(timer);\n    }\n  }, [value, interval]);\n\n  return throttledValue;\n}\n\n// Usage: Throttled scroll handler\nfunction ScrollTracker() {\n  const [scrollY, setScrollY] = useState(0);\n  const throttledScrollY = useThrottle(scrollY, 100);\n\n  useEffect(() => {\n    const handleScroll = () => {\n      setScrollY(window.scrollY);\n    };\n\n    window.addEventListener('scroll', handleScroll);\n    return () => window.removeEventListener('scroll', handleScroll);\n  }, []);\n\n  return <div>Scroll position: {throttledScrollY}</div>;\n}\n\n// Throttled callback hook\nfunction useThrottledCallback(callback, delay) {\n  const lastRan = useRef(Date.now());\n  const timeoutRef = useRef(null);\n\n  return useCallback((...args) => {\n    const now = Date.now();\n    const timeSinceLastRun = now - lastRan.current;\n\n    if (timeSinceLastRun >= delay) {\n      lastRan.current = now;\n      callback(...args);\n    } else {\n      clearTimeout(timeoutRef.current);\n      timeoutRef.current = setTimeout(() => {\n        lastRan.current = Date.now();\n        callback(...args);\n      }, delay - timeSinceLastRun);\n    }\n  }, [callback, delay]);\n}"
        },
        {
          "type": "title",
          "level": 2,
          "content": "Code Splitting & Lazy Loading"
        },
        {
          "type": "code",
          "language": "javascript",
          "title": "Code Splitting Patterns",
          "code": "import { lazy, Suspense, useState, useTransition } from 'react';\n\n// Route-based code splitting\nconst Dashboard = lazy(() => import('./pages/Dashboard'));\nconst Settings = lazy(() => import('./pages/Settings'));\nconst Profile = lazy(() => import('./pages/Profile'));\n\nfunction App() {\n  return (\n    <Suspense fallback={<PageLoader />}>\n      <Routes>\n        <Route path=\"/dashboard\" element={<Dashboard />} />\n        <Route path=\"/settings\" element={<Settings />} />\n        <Route path=\"/profile\" element={<Profile />} />\n      </Routes>\n    </Suspense>\n  );\n}\n\n// Component-level code splitting\nconst HeavyChart = lazy(() => import('./components/HeavyChart'));\nconst DataGrid = lazy(() => import('./components/DataGrid'));\n\nfunction Analytics() {\n  const [showChart, setShowChart] = useState(false);\n\n  return (\n    <div>\n      <button onClick={() => setShowChart(true)}>Show Chart</button>\n      \n      {showChart && (\n        <Suspense fallback={<ChartSkeleton />}>\n          <HeavyChart data={data} />\n        </Suspense>\n      )}\n    </div>\n  );\n}\n\n// Preloading components\nconst HeavyModal = lazy(() => import('./components/HeavyModal'));\n\nfunction PreloadExample() {\n  const [showModal, setShowModal] = useState(false);\n\n  // Preload on hover\n  const handleMouseEnter = () => {\n    import('./components/HeavyModal');\n  };\n\n  return (\n    <>\n      <button\n        onMouseEnter={handleMouseEnter}\n        onClick={() => setShowModal(true)}\n      >\n        Open Modal\n      </button>\n      \n      {showModal && (\n        <Suspense fallback={<ModalSkeleton />}>\n          <HeavyModal onClose={() => setShowModal(false)} />\n        </Suspense>\n      )}\n    </>\n  );\n}\n\n// With error boundary\nimport { ErrorBoundary } from 'react-error-boundary';\n\nfunction LazyWithErrorBoundary() {\n  return (\n    <ErrorBoundary\n      FallbackComponent={ErrorFallback}\n      onReset={() => window.location.reload()}\n    >\n      <Suspense fallback={<Loading />}>\n        <LazyComponent />\n      </Suspense>\n    </ErrorBoundary>\n  );\n}\n\n// Using useTransition for smoother loading\nfunction TabPanel() {\n  const [tab, setTab] = useState('home');\n  const [isPending, startTransition] = useTransition();\n\n  const TabContent = lazy(() => import(`./tabs/${tab}`));\n\n  const changeTab = (newTab) => {\n    startTransition(() => {\n      setTab(newTab);\n    });\n  };\n\n  return (\n    <div>\n      <nav>\n        <button onClick={() => changeTab('home')}>Home</button>\n        <button onClick={() => changeTab('profile')}>Profile</button>\n        <button onClick={() => changeTab('settings')}>Settings</button>\n      </nav>\n      \n      <div style={{ opacity: isPending ? 0.7 : 1 }}>\n        <Suspense fallback={<TabSkeleton />}>\n          <TabContent />\n        </Suspense>\n      </div>\n    </div>\n  );\n}\n\n// Named exports with lazy\nconst FeatureComponent = lazy(() =>\n  import('./FeatureModule').then(module => ({\n    default: module.FeatureComponent\n  }))\n);\n\n// Prefetch on route change\nfunction usePrefetch(path) {\n  useEffect(() => {\n    const link = document.createElement('link');\n    link.rel = 'prefetch';\n    link.href = path;\n    document.head.appendChild(link);\n    \n    return () => {\n      document.head.removeChild(link);\n    };\n  }, [path]);\n}"
        },
        {
          "type": "interview-tip",
          "tip": "Performance Profiling Steps",
          "explanation": "1. Open React DevTools Profiler\n2. Click Record, perform action, stop recording\n3. Look for:\n   - Components with many re-renders\n   - Long render times (orange/red bars)\n   - Unnecessary re-renders\n4. Use 'Highlight updates' to see re-renders in real-time\n5. Check 'Why did this render?' in Profiler\n6. Use Chrome Performance tab for overall metrics\n7. Test on production build (dev mode is slower)"
        }
      ]
    },
    {
      "id": "section-13",
      "title": "Testing React Applications",
      "blocks": [
        {
          "type": "title",
          "level": 1,
          "content": "Testing with React Testing Library"
        },
        {
          "type": "description",
          "content": "React Testing Library focuses on testing components from the user's perspective. It encourages testing behavior rather than implementation details. The philosophy is: 'The more your tests resemble the way your software is used, the more confidence they can give you.'"
        },
        {
          "type": "code",
          "language": "javascript",
          "title": "Basic Testing Patterns",
          "code": "import { render, screen, fireEvent, waitFor } from '@testing-library/react';\nimport userEvent from '@testing-library/user-event';\nimport '@testing-library/jest-dom';\n\n// Component to test\nfunction Counter({ initialCount = 0 }) {\n  const [count, setCount] = useState(initialCount);\n  \n  return (\n    <div>\n      <h1>Count: {count}</h1>\n      <button onClick={() => setCount(c => c + 1)}>Increment</button>\n      <button onClick={() => setCount(c => c - 1)}>Decrement</button>\n      <button onClick={() => setCount(0)}>Reset</button>\n    </div>\n  );\n}\n\n// Test file: Counter.test.js\ndescribe('Counter', () => {\n  test('renders initial count', () => {\n    render(<Counter initialCount={5} />);\n    \n    expect(screen.getByText('Count: 5')).toBeInTheDocument();\n  });\n\n  test('increments count when increment button clicked', async () => {\n    const user = userEvent.setup();\n    render(<Counter />);\n    \n    await user.click(screen.getByRole('button', { name: /increment/i }));\n    \n    expect(screen.getByText('Count: 1')).toBeInTheDocument();\n  });\n\n  test('decrements count when decrement button clicked', async () => {\n    const user = userEvent.setup();\n    render(<Counter initialCount={5} />);\n    \n    await user.click(screen.getByRole('button', { name: /decrement/i }));\n    \n    expect(screen.getByText('Count: 4')).toBeInTheDocument();\n  });\n\n  test('resets count when reset button clicked', async () => {\n    const user = userEvent.setup();\n    render(<Counter initialCount={10} />);\n    \n    await user.click(screen.getByRole('button', { name: /reset/i }));\n    \n    expect(screen.getByText('Count: 0')).toBeInTheDocument();\n  });\n});\n\n// Testing form input\nfunction LoginForm({ onSubmit }) {\n  const [email, setEmail] = useState('');\n  const [password, setPassword] = useState('');\n  const [error, setError] = useState('');\n\n  const handleSubmit = (e) => {\n    e.preventDefault();\n    if (!email || !password) {\n      setError('Please fill in all fields');\n      return;\n    }\n    onSubmit({ email, password });\n  };\n\n  return (\n    <form onSubmit={handleSubmit}>\n      {error && <div role=\"alert\">{error}</div>}\n      <label>\n        Email\n        <input\n          type=\"email\"\n          value={email}\n          onChange={e => setEmail(e.target.value)}\n        />\n      </label>\n      <label>\n        Password\n        <input\n          type=\"password\"\n          value={password}\n          onChange={e => setPassword(e.target.value)}\n        />\n      </label>\n      <button type=\"submit\">Login</button>\n    </form>\n  );\n}\n\ndescribe('LoginForm', () => {\n  test('calls onSubmit with email and password', async () => {\n    const user = userEvent.setup();\n    const handleSubmit = jest.fn();\n    \n    render(<LoginForm onSubmit={handleSubmit} />);\n    \n    await user.type(screen.getByLabelText(/email/i), 'test@example.com');\n    await user.type(screen.getByLabelText(/password/i), 'password123');\n    await user.click(screen.getByRole('button', { name: /login/i }));\n    \n    expect(handleSubmit).toHaveBeenCalledWith({\n      email: 'test@example.com',\n      password: 'password123'\n    });\n  });\n\n  test('shows error when fields are empty', async () => {\n    const user = userEvent.setup();\n    const handleSubmit = jest.fn();\n    \n    render(<LoginForm onSubmit={handleSubmit} />);\n    \n    await user.click(screen.getByRole('button', { name: /login/i }));\n    \n    expect(screen.getByRole('alert')).toHaveTextContent('Please fill in all fields');\n    expect(handleSubmit).not.toHaveBeenCalled();\n  });\n});"
        },
        {
          "type": "title",
          "level": 2,
          "content": "Testing Async Operations"
        },
        {
          "type": "code",
          "language": "javascript",
          "title": "Async Testing Patterns",
          "code": "import { render, screen, waitFor, waitForElementToBeRemoved } from '@testing-library/react';\nimport userEvent from '@testing-library/user-event';\n\n// Component with async data fetching\nfunction UserProfile({ userId }) {\n  const [user, setUser] = useState(null);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState(null);\n\n  useEffect(() => {\n    async function fetchUser() {\n      try {\n        setLoading(true);\n        const response = await fetch(`/api/users/${userId}`);\n        const data = await response.json();\n        setUser(data);\n      } catch (err) {\n        setError(err.message);\n      } finally {\n        setLoading(false);\n      }\n    }\n    fetchUser();\n  }, [userId]);\n\n  if (loading) return <div>Loading...</div>;\n  if (error) return <div role=\"alert\">Error: {error}</div>;\n  return <div>Welcome, {user.name}!</div>;\n}\n\n// Mock fetch\nbeforeEach(() => {\n  global.fetch = jest.fn();\n});\n\nafterEach(() => {\n  jest.restoreAllMocks();\n});\n\ndescribe('UserProfile', () => {\n  test('displays loading state initially', () => {\n    global.fetch.mockImplementation(() => new Promise(() => {}));\n    \n    render(<UserProfile userId=\"1\" />);\n    \n    expect(screen.getByText(/loading/i)).toBeInTheDocument();\n  });\n\n  test('displays user data after loading', async () => {\n    global.fetch.mockResolvedValue({\n      json: () => Promise.resolve({ id: '1', name: 'John Doe' })\n    });\n    \n    render(<UserProfile userId=\"1\" />);\n    \n    // Wait for loading to disappear\n    await waitForElementToBeRemoved(() => screen.queryByText(/loading/i));\n    \n    expect(screen.getByText(/welcome, john doe/i)).toBeInTheDocument();\n  });\n\n  test('displays error on fetch failure', async () => {\n    global.fetch.mockRejectedValue(new Error('Failed to fetch'));\n    \n    render(<UserProfile userId=\"1\" />);\n    \n    await waitFor(() => {\n      expect(screen.getByRole('alert')).toHaveTextContent(/failed to fetch/i);\n    });\n  });\n});\n\n// Testing with MSW (Mock Service Worker)\nimport { rest } from 'msw';\nimport { setupServer } from 'msw/node';\n\nconst server = setupServer(\n  rest.get('/api/users/:id', (req, res, ctx) => {\n    return res(ctx.json({ id: req.params.id, name: 'John Doe' }));\n  })\n);\n\nbeforeAll(() => server.listen());\nafterEach(() => server.resetHandlers());\nafterAll(() => server.close());\n\ntest('loads and displays user with MSW', async () => {\n  render(<UserProfile userId=\"1\" />);\n  \n  await screen.findByText(/welcome, john doe/i);\n});\n\ntest('handles server error with MSW', async () => {\n  server.use(\n    rest.get('/api/users/:id', (req, res, ctx) => {\n      return res(ctx.status(500), ctx.json({ message: 'Server error' }));\n    })\n  );\n  \n  render(<UserProfile userId=\"1\" />);\n  \n  await waitFor(() => {\n    expect(screen.getByRole('alert')).toBeInTheDocument();\n  });\n});"
        },
        {
          "type": "title",
          "level": 2,
          "content": "Testing with Context & Redux"
        },
        {
          "type": "code",
          "language": "javascript",
          "title": "Testing Components with Providers",
          "code": "import { render, screen } from '@testing-library/react';\nimport { Provider } from 'react-redux';\nimport { configureStore } from '@reduxjs/toolkit';\nimport { BrowserRouter } from 'react-router-dom';\nimport { ThemeProvider } from './contexts/ThemeContext';\nimport userReducer from './store/userSlice';\n\n// Custom render function with providers\nfunction renderWithProviders(\n  ui,\n  {\n    preloadedState = {},\n    store = configureStore({\n      reducer: { user: userReducer },\n      preloadedState\n    }),\n    ...renderOptions\n  } = {}\n) {\n  function Wrapper({ children }) {\n    return (\n      <Provider store={store}>\n        <BrowserRouter>\n          <ThemeProvider>\n            {children}\n          </ThemeProvider>\n        </BrowserRouter>\n      </Provider>\n    );\n  }\n  \n  return {\n    store,\n    ...render(ui, { wrapper: Wrapper, ...renderOptions })\n  };\n}\n\n// Component using Redux\nfunction UserDashboard() {\n  const user = useSelector(state => state.user.data);\n  const dispatch = useDispatch();\n  \n  return (\n    <div>\n      <h1>Welcome, {user?.name}</h1>\n      <button onClick={() => dispatch(logout())}>Logout</button>\n    </div>\n  );\n}\n\n// Tests\ndescribe('UserDashboard', () => {\n  test('displays user name from redux store', () => {\n    const preloadedState = {\n      user: {\n        data: { id: '1', name: 'John Doe' },\n        loading: false\n      }\n    };\n    \n    renderWithProviders(<UserDashboard />, { preloadedState });\n    \n    expect(screen.getByText(/welcome, john doe/i)).toBeInTheDocument();\n  });\n\n  test('dispatches logout action when button clicked', async () => {\n    const user = userEvent.setup();\n    const preloadedState = {\n      user: { data: { id: '1', name: 'John' }, loading: false }\n    };\n    \n    const { store } = renderWithProviders(<UserDashboard />, { preloadedState });\n    \n    await user.click(screen.getByRole('button', { name: /logout/i }));\n    \n    expect(store.getState().user.data).toBeNull();\n  });\n});\n\n// Testing Context directly\nfunction TestContextProvider({ children, theme = 'light' }) {\n  return (\n    <ThemeContext.Provider value={{ theme, toggleTheme: jest.fn() }}>\n      {children}\n    </ThemeContext.Provider>\n  );\n}\n\ntest('component uses theme from context', () => {\n  render(\n    <TestContextProvider theme=\"dark\">\n      <ThemedComponent />\n    </TestContextProvider>\n  );\n  \n  expect(screen.getByTestId('themed-div')).toHaveClass('dark');\n});"
        },
        {
          "type": "title",
          "level": 2,
          "content": "Testing Custom Hooks"
        },
        {
          "type": "code",
          "language": "javascript",
          "title": "Custom Hook Testing",
          "code": "import { renderHook, act } from '@testing-library/react';\n\n// Custom hook to test\nfunction useCounter(initialValue = 0) {\n  const [count, setCount] = useState(initialValue);\n  \n  const increment = useCallback(() => setCount(c => c + 1), []);\n  const decrement = useCallback(() => setCount(c => c - 1), []);\n  const reset = useCallback(() => setCount(initialValue), [initialValue]);\n  \n  return { count, increment, decrement, reset };\n}\n\n// Tests\ndescribe('useCounter', () => {\n  test('initializes with default value', () => {\n    const { result } = renderHook(() => useCounter());\n    \n    expect(result.current.count).toBe(0);\n  });\n\n  test('initializes with provided value', () => {\n    const { result } = renderHook(() => useCounter(10));\n    \n    expect(result.current.count).toBe(10);\n  });\n\n  test('increments counter', () => {\n    const { result } = renderHook(() => useCounter());\n    \n    act(() => {\n      result.current.increment();\n    });\n    \n    expect(result.current.count).toBe(1);\n  });\n\n  test('decrements counter', () => {\n    const { result } = renderHook(() => useCounter(5));\n    \n    act(() => {\n      result.current.decrement();\n    });\n    \n    expect(result.current.count).toBe(4);\n  });\n\n  test('resets counter', () => {\n    const { result } = renderHook(() => useCounter(5));\n    \n    act(() => {\n      result.current.increment();\n      result.current.increment();\n      result.current.reset();\n    });\n    \n    expect(result.current.count).toBe(5);\n  });\n});\n\n// Testing async hook\nfunction useAsync(asyncFn) {\n  const [state, setState] = useState({\n    data: null,\n    loading: false,\n    error: null\n  });\n\n  const execute = useCallback(async (...args) => {\n    setState({ data: null, loading: true, error: null });\n    try {\n      const data = await asyncFn(...args);\n      setState({ data, loading: false, error: null });\n      return data;\n    } catch (error) {\n      setState({ data: null, loading: false, error });\n      throw error;\n    }\n  }, [asyncFn]);\n\n  return { ...state, execute };\n}\n\ndescribe('useAsync', () => {\n  test('handles successful async operation', async () => {\n    const mockFn = jest.fn().mockResolvedValue('success');\n    const { result } = renderHook(() => useAsync(mockFn));\n    \n    expect(result.current.loading).toBe(false);\n    expect(result.current.data).toBeNull();\n    \n    await act(async () => {\n      await result.current.execute();\n    });\n    \n    expect(result.current.loading).toBe(false);\n    expect(result.current.data).toBe('success');\n    expect(result.current.error).toBeNull();\n  });\n\n  test('handles failed async operation', async () => {\n    const error = new Error('Failed');\n    const mockFn = jest.fn().mockRejectedValue(error);\n    const { result } = renderHook(() => useAsync(mockFn));\n    \n    await act(async () => {\n      try {\n        await result.current.execute();\n      } catch (e) {\n        // Expected\n      }\n    });\n    \n    expect(result.current.loading).toBe(false);\n    expect(result.current.data).toBeNull();\n    expect(result.current.error).toBe(error);\n  });\n});\n\n// Testing hook with context dependency\nfunction useAuth() {\n  const context = useContext(AuthContext);\n  if (!context) {\n    throw new Error('useAuth must be used within AuthProvider');\n  }\n  return context;\n}\n\ntest('throws error when used outside provider', () => {\n  const { result } = renderHook(() => useAuth());\n  \n  expect(result.error).toEqual(\n    new Error('useAuth must be used within AuthProvider')\n  );\n});\n\ntest('returns context value when inside provider', () => {\n  const wrapper = ({ children }) => (\n    <AuthProvider>\n      {children}\n    </AuthProvider>\n  );\n  \n  const { result } = renderHook(() => useAuth(), { wrapper });\n  \n  expect(result.current).toHaveProperty('user');\n  expect(result.current).toHaveProperty('login');\n  expect(result.current).toHaveProperty('logout');\n});"
        },
        {
          "type": "interview-tip",
          "tip": "Testing Best Practices",
          "explanation": "1. Test behavior, not implementation\n2. Use queries that reflect how users find elements\n3. Priority: getByRole > getByLabelText > getByText > getByTestId\n4. Use userEvent over fireEvent for realistic interactions\n5. Use waitFor for async assertions\n6. Keep tests independent and isolated\n7. Use data-testid sparingly as last resort\n8. Mock at the boundary (API calls, not internal functions)\n9. Test error states and edge cases\n10. Write integration tests for user flows"
        }
      ]
    },
    {
      "id": "section-14",
      "title": "Redux Fundamentals",
      "blocks": [
        {
          "type": "title",
          "level": 1,
          "content": "What is Redux?"
        },
        {
          "type": "description",
          "content": "Redux is a predictable state container for JavaScript applications. It helps manage application state in a single centralized store, making state changes predictable through strict rules. Redux follows three core principles: Single Source of Truth, State is Read-Only, and Changes are Made with Pure Functions."
        },
        {
          "type": "code",
          "language": "text",
          "title": "Redux Core Concepts",
          "code": "┌─────────────────────────────────────────────────────────────────┐\n│                    REDUX ARCHITECTURE                           │\n├─────────────────────────────────────────────────────────────────┤\n│                                                                 │\n│                         ┌─────────┐                            │\n│                         │  VIEW   │                            │\n│                         │ (React) │                            │\n│                         └────┬────┘                            │\n│                              │                                  │\n│                    User Interaction                             │\n│                              │                                  │\n│                              ▼                                  │\n│                         ┌─────────┐                            │\n│                         │ ACTION  │                            │\n│                         │ Creator │                            │\n│                         └────┬────┘                            │\n│                              │                                  │\n│                    dispatch(action)                             │\n│                              │                                  │\n│                              ▼                                  │\n│    ┌─────────────────────────────────────────────────────┐     │\n│    │                     STORE                            │     │\n│    │  ┌─────────────────────────────────────────────────┐│     │\n│    │  │              MIDDLEWARE                          ││     │\n│    │  │  (Redux Thunk, Redux Saga, Logger, etc.)        ││     │\n│    │  └─────────────────────────┬───────────────────────┘│     │\n│    │                            │                         │     │\n│    │                            ▼                         │     │\n│    │  ┌─────────────────────────────────────────────────┐│     │\n│    │  │              REDUCERS                            ││     │\n│    │  │  (previousState, action) => newState            ││     │\n│    │  └─────────────────────────────────────────────────┘│     │\n│    │                            │                         │     │\n│    │                            ▼                         │     │\n│    │  ┌─────────────────────────────────────────────────┐│     │\n│    │  │                 STATE                            ││     │\n│    │  │         { users: [], posts: [], ... }           ││     │\n│    │  └─────────────────────────────────────────────────┘│     │\n│    └─────────────────────────────────────────────────────┘     │\n│                              │                                  │\n│                    State updated via                            │\n│                    store.subscribe()                            │\n│                              │                                  │\n│                              ▼                                  │\n│                         ┌─────────┐                            │\n│                         │  VIEW   │                            │\n│                         │Re-render│                            │\n│                         └─────────┘                            │\n│                                                                 │\n└─────────────────────────────────────────────────────────────────┘\n\nTHREE PRINCIPLES OF REDUX:\n\n1. SINGLE SOURCE OF TRUTH\n   - Entire app state in one store\n   - Easy to debug and inspect\n   - Easy to persist and rehydrate\n\n2. STATE IS READ-ONLY\n   - Only way to change state is dispatch action\n   - No direct mutations\n   - All changes are centralized and predictable\n\n3. CHANGES MADE WITH PURE FUNCTIONS\n   - Reducers are pure functions\n   - (state, action) => newState\n   - Same input always gives same output"
        },
        {
          "type": "title",
          "level": 2,
          "content": "Core Redux Concepts"
        },
        {
          "type": "code",
          "language": "javascript",
          "title": "Actions, Reducers, and Store",
          "code": "// ============= ACTIONS =============\n// Actions are plain objects that describe what happened\n// They must have a 'type' property\n\n// Action Types (constants to avoid typos)\nconst ADD_TODO = 'ADD_TODO';\nconst TOGGLE_TODO = 'TOGGLE_TODO';\nconst DELETE_TODO = 'DELETE_TODO';\nconst SET_FILTER = 'SET_FILTER';\n\n// Action Objects\nconst addTodoAction = {\n  type: ADD_TODO,\n  payload: {\n    id: 1,\n    text: 'Learn Redux',\n    completed: false\n  }\n};\n\n// Action Creators - functions that return action objects\nfunction addTodo(text) {\n  return {\n    type: ADD_TODO,\n    payload: {\n      id: Date.now(),\n      text,\n      completed: false\n    }\n  };\n}\n\nfunction toggleTodo(id) {\n  return {\n    type: TOGGLE_TODO,\n    payload: { id }\n  };\n}\n\nfunction deleteTodo(id) {\n  return {\n    type: DELETE_TODO,\n    payload: { id }\n  };\n}\n\nfunction setFilter(filter) {\n  return {\n    type: SET_FILTER,\n    payload: { filter }\n  };\n}\n\n// ============= REDUCERS =============\n// Reducers are pure functions that take current state and action\n// and return a new state\n\nconst initialTodosState = [];\n\nfunction todosReducer(state = initialTodosState, action) {\n  switch (action.type) {\n    case ADD_TODO:\n      // Return new array with new todo added\n      return [...state, action.payload];\n      \n    case TOGGLE_TODO:\n      // Return new array with toggled todo\n      return state.map(todo =>\n        todo.id === action.payload.id\n          ? { ...todo, completed: !todo.completed }\n          : todo\n      );\n      \n    case DELETE_TODO:\n      // Return new array without the deleted todo\n      return state.filter(todo => todo.id !== action.payload.id);\n      \n    default:\n      // Always return current state for unknown actions\n      return state;\n  }\n}\n\nconst initialFilterState = 'all';\n\nfunction filterReducer(state = initialFilterState, action) {\n  switch (action.type) {\n    case SET_FILTER:\n      return action.payload.filter;\n    default:\n      return state;\n  }\n}\n\n// Combining reducers\nimport { combineReducers } from 'redux';\n\nconst rootReducer = combineReducers({\n  todos: todosReducer,\n  filter: filterReducer\n});\n\n// State shape: { todos: [], filter: 'all' }\n\n// ============= STORE =============\nimport { createStore } from 'redux';\n\n// Create store with root reducer\nconst store = createStore(rootReducer);\n\n// Get current state\nconsole.log(store.getState());\n// { todos: [], filter: 'all' }\n\n// Subscribe to state changes\nconst unsubscribe = store.subscribe(() => {\n  console.log('State changed:', store.getState());\n});\n\n// Dispatch actions\nstore.dispatch(addTodo('Learn Redux'));\nstore.dispatch(addTodo('Build an app'));\nstore.dispatch(toggleTodo(1));\n\n// Unsubscribe when done\nunsubscribe();"
        },
        {
          "type": "title",
          "level": 2,
          "content": "Redux with React (Legacy Connect API)"
        },
        {
          "type": "code",
          "language": "javascript",
          "title": "React-Redux Connect Pattern",
          "code": "import { connect } from 'react-redux';\nimport { bindActionCreators } from 'redux';\n\n// Component\nfunction TodoList({ todos, filter, addTodo, toggleTodo, deleteTodo, setFilter }) {\n  const filteredTodos = todos.filter(todo => {\n    if (filter === 'completed') return todo.completed;\n    if (filter === 'active') return !todo.completed;\n    return true;\n  });\n\n  return (\n    <div>\n      <input type=\"text\" onKeyPress={e => {\n        if (e.key === 'Enter') {\n          addTodo(e.target.value);\n          e.target.value = '';\n        }\n      }} />\n      \n      <select value={filter} onChange={e => setFilter(e.target.value)}>\n        <option value=\"all\">All</option>\n        <option value=\"active\">Active</option>\n        <option value=\"completed\">Completed</option>\n      </select>\n      \n      <ul>\n        {filteredTodos.map(todo => (\n          <li key={todo.id}>\n            <input\n              type=\"checkbox\"\n              checked={todo.completed}\n              onChange={() => toggleTodo(todo.id)}\n            />\n            <span style={{ textDecoration: todo.completed ? 'line-through' : 'none' }}>\n              {todo.text}\n            </span>\n            <button onClick={() => deleteTodo(todo.id)}>Delete</button>\n          </li>\n        ))}\n      </ul>\n    </div>\n  );\n}\n\n// mapStateToProps - Extract data from store state\nconst mapStateToProps = (state) => ({\n  todos: state.todos,\n  filter: state.filter\n});\n\n// mapDispatchToProps - Different ways\n\n// Option 1: Function that returns object of action dispatchers\nconst mapDispatchToProps = (dispatch) => ({\n  addTodo: (text) => dispatch(addTodo(text)),\n  toggleTodo: (id) => dispatch(toggleTodo(id)),\n  deleteTodo: (id) => dispatch(deleteTodo(id)),\n  setFilter: (filter) => dispatch(setFilter(filter))\n});\n\n// Option 2: Using bindActionCreators\nconst mapDispatchToProps = (dispatch) => \n  bindActionCreators(\n    { addTodo, toggleTodo, deleteTodo, setFilter },\n    dispatch\n  );\n\n// Option 3: Object shorthand (recommended)\n// Actions are automatically wrapped with dispatch\nconst mapDispatchToProps = {\n  addTodo,\n  toggleTodo,\n  deleteTodo,\n  setFilter\n};\n\n// Connect component to Redux\nconst ConnectedTodoList = connect(\n  mapStateToProps,\n  mapDispatchToProps\n)(TodoList);\n\nexport default ConnectedTodoList;\n\n// App setup\nimport { Provider } from 'react-redux';\n\nfunction App() {\n  return (\n    <Provider store={store}>\n      <ConnectedTodoList />\n    </Provider>\n  );\n}"
        },
        {
          "type": "title",
          "level": 2,
          "content": "Redux Hooks (Modern Approach)"
        },
        {
          "type": "code",
          "language": "javascript",
          "title": "useSelector and useDispatch",
          "code": "import { useSelector, useDispatch, shallowEqual } from 'react-redux';\nimport { useCallback, useMemo } from 'react';\n\n// ============= useSelector =============\n// Extracts data from the Redux store state\n\nfunction TodoList() {\n  // Basic usage\n  const todos = useSelector(state => state.todos);\n  const filter = useSelector(state => state.filter);\n  \n  // With shallowEqual for object comparisons\n  const todoStats = useSelector(\n    state => ({\n      total: state.todos.length,\n      completed: state.todos.filter(t => t.completed).length\n    }),\n    shallowEqual  // Prevents re-render if object values are same\n  );\n  \n  // Derived data (computed in selector)\n  const filteredTodos = useSelector(state => {\n    const { todos, filter } = state;\n    if (filter === 'completed') return todos.filter(t => t.completed);\n    if (filter === 'active') return todos.filter(t => !t.completed);\n    return todos;\n  });\n  \n  return (\n    <div>\n      <p>Total: {todoStats.total}, Completed: {todoStats.completed}</p>\n      <ul>\n        {filteredTodos.map(todo => (\n          <TodoItem key={todo.id} todo={todo} />\n        ))}\n      </ul>\n    </div>\n  );\n}\n\n// ============= useDispatch =============\n// Returns the store's dispatch function\n\nfunction AddTodoForm() {\n  const dispatch = useDispatch();\n  const [text, setText] = useState('');\n  \n  const handleSubmit = (e) => {\n    e.preventDefault();\n    if (text.trim()) {\n      dispatch(addTodo(text));\n      setText('');\n    }\n  };\n  \n  return (\n    <form onSubmit={handleSubmit}>\n      <input\n        value={text}\n        onChange={e => setText(e.target.value)}\n        placeholder=\"Add todo...\"\n      />\n      <button type=\"submit\">Add</button>\n    </form>\n  );\n}\n\n// ============= Optimizing with useCallback =============\n\nfunction TodoItem({ todo }) {\n  const dispatch = useDispatch();\n  \n  // Memoize callbacks to prevent child re-renders\n  const handleToggle = useCallback(() => {\n    dispatch(toggleTodo(todo.id));\n  }, [dispatch, todo.id]);\n  \n  const handleDelete = useCallback(() => {\n    dispatch(deleteTodo(todo.id));\n  }, [dispatch, todo.id]);\n  \n  return (\n    <li>\n      <input\n        type=\"checkbox\"\n        checked={todo.completed}\n        onChange={handleToggle}\n      />\n      <span>{todo.text}</span>\n      <button onClick={handleDelete}>Delete</button>\n    </li>\n  );\n}\n\n// ============= Custom Hooks for Redux =============\n\n// Encapsulate selector logic\nfunction useTodos() {\n  return useSelector(state => state.todos);\n}\n\nfunction useFilteredTodos() {\n  return useSelector(state => {\n    const { todos, filter } = state;\n    switch (filter) {\n      case 'completed':\n        return todos.filter(t => t.completed);\n      case 'active':\n        return todos.filter(t => !t.completed);\n      default:\n        return todos;\n    }\n  }, shallowEqual);\n}\n\nfunction useTodoActions() {\n  const dispatch = useDispatch();\n  \n  return useMemo(() => ({\n    add: (text) => dispatch(addTodo(text)),\n    toggle: (id) => dispatch(toggleTodo(id)),\n    delete: (id) => dispatch(deleteTodo(id))\n  }), [dispatch]);\n}\n\n// Usage\nfunction TodoApp() {\n  const todos = useFilteredTodos();\n  const { add, toggle, delete: remove } = useTodoActions();\n  \n  return (\n    <div>\n      <AddTodoForm onAdd={add} />\n      {todos.map(todo => (\n        <TodoItem\n          key={todo.id}\n          todo={todo}\n          onToggle={() => toggle(todo.id)}\n          onDelete={() => remove(todo.id)}\n        />\n      ))}\n    </div>\n  );\n}"
        },
        {
          "type": "interview-tip",
          "tip": "useSelector vs connect",
          "explanation": "useSelector advantages:\n1. Simpler syntax, less boilerplate\n2. Can use closures from component scope\n3. Easier to understand data flow\n4. Better TypeScript support\n\nconnect advantages:\n1. Prevents re-renders by shallow comparing mapped props\n2. Better for class components\n3. Easier to test (mapStateToProps is a pure function)\n\nBest Practice: Use hooks for new code, connect for existing class components."
        }
      ]
    },
    {
  "id": "section-15",
  "title": "Redux Toolkit (RTK)",
  "blocks": [
    {
      "type": "title",
      "level": 1,
      "content": "Introduction to Redux Toolkit"
    },
    {
      "type": "description",
      "content": "Redux Toolkit (RTK) is the official, opinionated, batteries-included toolset for efficient Redux development. It simplifies store setup, reduces boilerplate, includes useful utilities, and enables good Redux practices by default. RTK is now the recommended way to write Redux logic."
    },
    {
      "type": "code",
      "language": "text",
      "title": "Why Redux Toolkit?",
      "code": "┌─────────────────────────────────────────────────────────────────┐\n│                    WHY REDUX TOOLKIT?                           │\n├─────────────────────────────────────────────────────────────────┤\n│                                                                 │\n│  PROBLEMS WITH VANILLA REDUX:                                   │\n│  ❌ Too much boilerplate code                                   │\n│  ❌ Need to install multiple packages                           │\n│  ❌ Complex store configuration                                 │\n│  ❌ Immutable update patterns are verbose                       │\n│  ❌ Easy to make mistakes with immutability                     │\n│  ❌ No standard way to handle async logic                       │\n│                                                                 │\n│  REDUX TOOLKIT SOLUTIONS:                                       │\n│  ✅ configureStore() - simplified store setup                   │\n│  ✅ createSlice() - auto-generates action creators & types      │\n│  ✅ createAsyncThunk() - standard async handling                │\n│  ✅ Immer built-in - write \"mutating\" logic safely              │\n│  ✅ Redux DevTools configured automatically                     │\n│  ✅ RTK Query - powerful data fetching & caching                │\n│  ✅ Good defaults prevent common mistakes                       │\n│                                                                 │\n│  INCLUDED PACKAGES:                                             │\n│  • redux (core Redux library)                                   │\n│  • immer (immutable updates)                                    │\n│  • redux-thunk (async middleware)                               │\n│  • reselect (memoized selectors)                                │\n│  • redux-devtools-extension                                     │\n│                                                                 │\n└─────────────────────────────────────────────────────────────────┘"
    },
    {
      "type": "code",
      "language": "bash",
      "title": "Installation",
      "code": "# Install Redux Toolkit and React-Redux\nnpm install @reduxjs/toolkit react-redux\n\n# Or with yarn\nyarn add @reduxjs/toolkit react-redux\n\n# Create new React app with Redux template\nnpx create-react-app my-app --template redux\n\n# Or with TypeScript\nnpx create-react-app my-app --template redux-typescript"
    },
    {
      "type": "title",
      "level": 2,
      "content": "configureStore"
    },
    {
      "type": "description",
      "content": "configureStore wraps the Redux createStore function and provides simplified configuration options. It automatically sets up the Redux DevTools Extension, adds thunk middleware, and includes development-mode checks that warn about common mistakes."
    },
    {
      "type": "code",
      "language": "javascript",
      "title": "configureStore Setup",
      "code": "// store/store.js\nimport { configureStore } from '@reduxjs/toolkit';\nimport userReducer from './slices/userSlice';\nimport postsReducer from './slices/postsSlice';\nimport commentsReducer from './slices/commentsSlice';\nimport { apiSlice } from './api/apiSlice';\n\n// Basic configuration\nconst store = configureStore({\n  reducer: {\n    user: userReducer,\n    posts: postsReducer,\n    comments: commentsReducer,\n    // RTK Query reducer\n    [apiSlice.reducerPath]: apiSlice.reducer\n  }\n});\n\nexport default store;\n\n// Advanced configuration\nconst storeAdvanced = configureStore({\n  reducer: {\n    user: userReducer,\n    posts: postsReducer\n  },\n  \n  // Custom middleware\n  middleware: (getDefaultMiddleware) =>\n    getDefaultMiddleware({\n      // Customize default middleware options\n      serializableCheck: {\n        // Ignore these action types\n        ignoredActions: ['persist/PERSIST', 'persist/REHYDRATE'],\n        // Ignore these paths in state\n        ignoredPaths: ['some.nested.path']\n      },\n      thunk: {\n        // Extra argument available in thunks\n        extraArgument: { api: apiService }\n      },\n      immutableCheck: true // Enable immutability checks (dev only)\n    })\n    // Add custom middleware\n    .concat(apiSlice.middleware)\n    .concat(loggerMiddleware),\n  \n  // Enable Redux DevTools (true by default in development)\n  devTools: process.env.NODE_ENV !== 'production',\n  \n  // Preloaded state (optional)\n  preloadedState: {\n    user: { name: 'Guest', isLoggedIn: false }\n  },\n  \n  // Store enhancers (optional)\n  enhancers: (getDefaultEnhancers) =>\n    getDefaultEnhancers().concat(customEnhancer)\n});\n\n// Get state type for TypeScript\nexport type RootState = ReturnType<typeof store.getState>;\nexport type AppDispatch = typeof store.dispatch;\n\n// Custom logger middleware example\nconst loggerMiddleware = (store) => (next) => (action) => {\n  console.log('Dispatching:', action);\n  const result = next(action);\n  console.log('Next State:', store.getState());\n  return result;\n};"
    },
    {
      "type": "code",
      "language": "javascript",
      "title": "Provider Setup",
      "code": "// index.js or main.jsx\nimport React from 'react';\nimport ReactDOM from 'react-dom/client';\nimport { Provider } from 'react-redux';\nimport store from './store/store';\nimport App from './App';\n\nconst root = ReactDOM.createRoot(document.getElementById('root'));\n\nroot.render(\n  <React.StrictMode>\n    <Provider store={store}>\n      <App />\n    </Provider>\n  </React.StrictMode>\n);"
    },
    {
      "type": "interview-tip",
      "tip": "configureStore vs createStore",
      "explanation": "configureStore:\n1. Automatically adds thunk middleware\n2. Enables Redux DevTools by default\n3. Adds development-mode checks\n4. Accepts reducer object (combines automatically)\n5. Easier middleware configuration\n\nAlways use configureStore in new Redux projects. createStore is deprecated."
    },
    {
      "type": "title",
      "level": 2,
      "content": "createSlice"
    },
    {
      "type": "description",
      "content": "createSlice is the core function in Redux Toolkit that simplifies creating Redux logic. It automatically generates action creators and action types based on the reducer functions you provide. It uses Immer internally, allowing you to write 'mutating' logic that safely creates immutable updates."
    },
    {
      "type": "code",
      "language": "javascript",
      "title": "createSlice Complete Example",
      "code": "// slices/todosSlice.js\nimport { createSlice, nanoid } from '@reduxjs/toolkit';\n\nconst initialState = {\n  items: [],\n  filter: 'all', // 'all' | 'active' | 'completed'\n  loading: false,\n  error: null\n};\n\nconst todosSlice = createSlice({\n  name: 'todos', // Used as prefix for action types\n  initialState,\n  reducers: {\n    // Simple reducer - Immer allows \"mutating\" syntax\n    addTodo: {\n      reducer: (state, action) => {\n        state.items.push(action.payload);\n      },\n      // Prepare callback - customize action payload\n      prepare: (text) => {\n        return {\n          payload: {\n            id: nanoid(),\n            text,\n            completed: false,\n            createdAt: new Date().toISOString()\n          }\n        };\n      }\n    },\n    \n    // Toggle todo completion\n    toggleTodo: (state, action) => {\n      const todo = state.items.find(item => item.id === action.payload);\n      if (todo) {\n        todo.completed = !todo.completed;\n      }\n    },\n    \n    // Remove todo\n    removeTodo: (state, action) => {\n      const index = state.items.findIndex(item => item.id === action.payload);\n      if (index !== -1) {\n        state.items.splice(index, 1);\n      }\n    },\n    \n    // Edit todo text\n    editTodo: (state, action) => {\n      const { id, text } = action.payload;\n      const todo = state.items.find(item => item.id === id);\n      if (todo) {\n        todo.text = text;\n      }\n    },\n    \n    // Set filter\n    setFilter: (state, action) => {\n      state.filter = action.payload;\n    },\n    \n    // Clear completed todos\n    clearCompleted: (state) => {\n      state.items = state.items.filter(item => !item.completed);\n    },\n    \n    // Toggle all todos\n    toggleAll: (state) => {\n      const allCompleted = state.items.every(item => item.completed);\n      state.items.forEach(item => {\n        item.completed = !allCompleted;\n      });\n    },\n    \n    // Reorder todos (drag and drop)\n    reorderTodos: (state, action) => {\n      const { fromIndex, toIndex } = action.payload;\n      const [removed] = state.items.splice(fromIndex, 1);\n      state.items.splice(toIndex, 0, removed);\n    },\n    \n    // Set loading state\n    setLoading: (state, action) => {\n      state.loading = action.payload;\n    },\n    \n    // Set error\n    setError: (state, action) => {\n      state.error = action.payload;\n      state.loading = false;\n    },\n    \n    // Reset to initial state\n    resetTodos: () => initialState\n  },\n  \n  // Handle actions from other slices or async thunks\n  extraReducers: (builder) => {\n    builder\n      // Handle fetchTodos async thunk\n      .addCase(fetchTodos.pending, (state) => {\n        state.loading = true;\n        state.error = null;\n      })\n      .addCase(fetchTodos.fulfilled, (state, action) => {\n        state.loading = false;\n        state.items = action.payload;\n      })\n      .addCase(fetchTodos.rejected, (state, action) => {\n        state.loading = false;\n        state.error = action.error.message;\n      })\n      // Handle action from another slice\n      .addCase('user/logout', (state) => {\n        return initialState;\n      })\n      // Match multiple actions\n      .addMatcher(\n        (action) => action.type.endsWith('/rejected'),\n        (state, action) => {\n          state.error = action.error.message;\n        }\n      )\n      // Default case\n      .addDefaultCase((state, action) => {\n        // Handle any other action\n      });\n  }\n});\n\n// Export actions (auto-generated)\nexport const {\n  addTodo,\n  toggleTodo,\n  removeTodo,\n  editTodo,\n  setFilter,\n  clearCompleted,\n  toggleAll,\n  reorderTodos,\n  setLoading,\n  setError,\n  resetTodos\n} = todosSlice.actions;\n\n// Export reducer\nexport default todosSlice.reducer;\n\n// Selectors\nexport const selectAllTodos = (state) => state.todos.items;\nexport const selectFilter = (state) => state.todos.filter;\nexport const selectTodosLoading = (state) => state.todos.loading;\nexport const selectTodosError = (state) => state.todos.error;\n\nexport const selectFilteredTodos = (state) => {\n  const { items, filter } = state.todos;\n  switch (filter) {\n    case 'active':\n      return items.filter(item => !item.completed);\n    case 'completed':\n      return items.filter(item => item.completed);\n    default:\n      return items;\n  }\n};\n\nexport const selectTodosCount = (state) => ({\n  total: state.todos.items.length,\n  active: state.todos.items.filter(item => !item.completed).length,\n  completed: state.todos.items.filter(item => item.completed).length\n});"
    },
    {
      "type": "code",
      "language": "javascript",
      "title": "Using Slice in Components",
      "code": "// components/TodoList.jsx\nimport { useSelector, useDispatch } from 'react-redux';\nimport {\n  selectFilteredTodos,\n  selectTodosLoading,\n  selectTodosCount,\n  addTodo,\n  toggleTodo,\n  removeTodo,\n  setFilter,\n  clearCompleted\n} from '../slices/todosSlice';\n\nfunction TodoList() {\n  const dispatch = useDispatch();\n  const todos = useSelector(selectFilteredTodos);\n  const loading = useSelector(selectTodosLoading);\n  const { total, active, completed } = useSelector(selectTodosCount);\n  const [inputValue, setInputValue] = useState('');\n\n  const handleAddTodo = (e) => {\n    e.preventDefault();\n    if (inputValue.trim()) {\n      dispatch(addTodo(inputValue.trim()));\n      setInputValue('');\n    }\n  };\n\n  const handleToggle = (id) => {\n    dispatch(toggleTodo(id));\n  };\n\n  const handleRemove = (id) => {\n    dispatch(removeTodo(id));\n  };\n\n  const handleFilterChange = (filter) => {\n    dispatch(setFilter(filter));\n  };\n\n  const handleClearCompleted = () => {\n    dispatch(clearCompleted());\n  };\n\n  if (loading) {\n    return <div>Loading todos...</div>;\n  }\n\n  return (\n    <div className=\"todo-list\">\n      <form onSubmit={handleAddTodo}>\n        <input\n          value={inputValue}\n          onChange={(e) => setInputValue(e.target.value)}\n          placeholder=\"Add new todo\"\n        />\n        <button type=\"submit\">Add</button>\n      </form>\n\n      <ul>\n        {todos.map(todo => (\n          <li key={todo.id}>\n            <input\n              type=\"checkbox\"\n              checked={todo.completed}\n              onChange={() => handleToggle(todo.id)}\n            />\n            <span className={todo.completed ? 'completed' : ''}>\n              {todo.text}\n            </span>\n            <button onClick={() => handleRemove(todo.id)}>Delete</button>\n          </li>\n        ))}\n      </ul>\n\n      <div className=\"filters\">\n        <button onClick={() => handleFilterChange('all')}>All ({total})</button>\n        <button onClick={() => handleFilterChange('active')}>Active ({active})</button>\n        <button onClick={() => handleFilterChange('completed')}>Completed ({completed})</button>\n      </div>\n\n      {completed > 0 && (\n        <button onClick={handleClearCompleted}>\n          Clear Completed\n        </button>\n      )}\n    </div>\n  );\n}"
    },
    {
      "type": "code",
      "language": "text",
      "title": "createSlice Structure",
      "code": "┌─────────────────────────────────────────────────────────────────┐\n│                    createSlice STRUCTURE                        │\n├─────────────────────────────────────────────────────────────────┤\n│                                                                 │\n│  createSlice({                                                  │\n│    name: 'sliceName',  ──────► Action type prefix               │\n│    initialState: {},   ──────► Initial state value              │\n│    reducers: {         ──────► Reducer functions                │\n│      action1: (state, action) => {...},                        │\n│      action2: {                                                 │\n│        reducer: (state, action) => {...},                      │\n│        prepare: (arg) => ({ payload: {...} })                  │\n│      }                                                          │\n│    },                                                           │\n│    extraReducers: (builder) => {...}  ──► Handle other actions │\n│  })                                                             │\n│                                                                 │\n│  RETURNS:                                                       │\n│  {                                                              │\n│    name: 'sliceName',                                          │\n│    reducer: reducerFunction,   ──► Export as default           │\n│    actions: {                                                   │\n│      action1: actionCreator,   ──► Export named                │\n│      action2: actionCreator                                     │\n│    },                                                           │\n│    caseReducers: {...},                                        │\n│    getInitialState: () => {...}                                │\n│  }                                                              │\n│                                                                 │\n│  AUTO-GENERATED ACTION TYPES:                                   │\n│  'sliceName/action1'                                           │\n│  'sliceName/action2'                                           │\n│                                                                 │\n└─────────────────────────────────────────────────────────────────┘"
    },
    {
      "type": "interview-tip",
      "tip": "Immer in createSlice",
      "explanation": "createSlice uses Immer internally, which allows you to write 'mutating' code that actually produces immutable updates:\n\n// This looks like mutation but is safe:\nstate.items.push(newItem);\nstate.user.name = 'John';\ndelete state.items[0];\n\n// Immer converts it to:\n{ ...state, items: [...state.items, newItem] }\n\nNote: You can either mutate state OR return a new state, but not both!"
    },
    {
      "type": "title",
      "level": 2,
      "content": "createAsyncThunk"
    },
    {
      "type": "description",
      "content": "createAsyncThunk generates a thunk action creator that automatically dispatches 'pending', 'fulfilled', and 'rejected' actions based on the Promise lifecycle. It simplifies async logic and provides consistent patterns for loading states and error handling."
    },
    {
      "type": "code",
      "language": "javascript",
      "title": "createAsyncThunk Complete Guide",
      "code": "// slices/usersSlice.js\nimport { createSlice, createAsyncThunk } from '@reduxjs/toolkit';\nimport axios from 'axios';\n\n// Basic async thunk\nexport const fetchUsers = createAsyncThunk(\n  'users/fetchUsers', // Action type prefix\n  async () => {\n    const response = await axios.get('/api/users');\n    return response.data; // This becomes action.payload\n  }\n);\n\n// Async thunk with parameters\nexport const fetchUserById = createAsyncThunk(\n  'users/fetchUserById',\n  async (userId) => {\n    const response = await axios.get(`/api/users/${userId}`);\n    return response.data;\n  }\n);\n\n// Async thunk with thunkAPI\nexport const updateUser = createAsyncThunk(\n  'users/updateUser',\n  async (userData, thunkAPI) => {\n    const { dispatch, getState, extra, rejectWithValue, fulfillWithValue } = thunkAPI;\n    \n    try {\n      // Access current state\n      const currentUser = getState().users.currentUser;\n      \n      // Access extra argument from store config\n      const { api } = extra;\n      \n      const response = await axios.put(`/api/users/${userData.id}`, userData);\n      \n      // Dispatch another action\n      dispatch(showNotification('User updated successfully'));\n      \n      // Return with custom meta\n      return fulfillWithValue(response.data, { requestId: userData.id });\n      \n    } catch (error) {\n      // Return rejected action with custom payload\n      return rejectWithValue({\n        message: error.response?.data?.message || error.message,\n        status: error.response?.status\n      });\n    }\n  }\n);\n\n// Async thunk with conditions\nexport const fetchUsersIfNeeded = createAsyncThunk(\n  'users/fetchUsersIfNeeded',\n  async (_, thunkAPI) => {\n    const response = await axios.get('/api/users');\n    return response.data;\n  },\n  {\n    // Condition to run the thunk\n    condition: (_, { getState }) => {\n      const { users } = getState();\n      // Don't fetch if already loading or already have data\n      if (users.loading || users.items.length > 0) {\n        return false; // Cancel the thunk\n      }\n      return true;\n    },\n    // Dispatch pending action even if condition is false\n    dispatchConditionRejection: false\n  }\n);\n\n// Async thunk with cancellation\nexport const fetchUserWithCancel = createAsyncThunk(\n  'users/fetchWithCancel',\n  async (userId, { signal }) => {\n    const response = await axios.get(`/api/users/${userId}`, {\n      signal // AbortController signal\n    });\n    return response.data;\n  }\n);\n\n// Usage: const promise = dispatch(fetchUserWithCancel(1));\n//        promise.abort(); // Cancel the request\n\n// Async thunk for form submission\nexport const submitForm = createAsyncThunk(\n  'users/submitForm',\n  async (formData, { rejectWithValue }) => {\n    try {\n      const response = await axios.post('/api/submit', formData);\n      return response.data;\n    } catch (error) {\n      // Handle validation errors\n      if (error.response?.status === 422) {\n        return rejectWithValue({\n          type: 'validation',\n          errors: error.response.data.errors\n        });\n      }\n      // Handle other errors\n      return rejectWithValue({\n        type: 'error',\n        message: error.message\n      });\n    }\n  }\n);\n\n// Slice with async thunks\nconst usersSlice = createSlice({\n  name: 'users',\n  initialState: {\n    items: [],\n    currentUser: null,\n    loading: false,\n    error: null,\n    validationErrors: {}\n  },\n  reducers: {\n    clearError: (state) => {\n      state.error = null;\n    },\n    clearValidationErrors: (state) => {\n      state.validationErrors = {};\n    }\n  },\n  extraReducers: (builder) => {\n    builder\n      // fetchUsers\n      .addCase(fetchUsers.pending, (state) => {\n        state.loading = true;\n        state.error = null;\n      })\n      .addCase(fetchUsers.fulfilled, (state, action) => {\n        state.loading = false;\n        state.items = action.payload;\n      })\n      .addCase(fetchUsers.rejected, (state, action) => {\n        state.loading = false;\n        state.error = action.error.message;\n      })\n      \n      // fetchUserById\n      .addCase(fetchUserById.fulfilled, (state, action) => {\n        state.currentUser = action.payload;\n      })\n      \n      // updateUser\n      .addCase(updateUser.fulfilled, (state, action) => {\n        const index = state.items.findIndex(u => u.id === action.payload.id);\n        if (index !== -1) {\n          state.items[index] = action.payload;\n        }\n        if (state.currentUser?.id === action.payload.id) {\n          state.currentUser = action.payload;\n        }\n      })\n      .addCase(updateUser.rejected, (state, action) => {\n        // Handle rejectWithValue payload\n        state.error = action.payload?.message || action.error.message;\n      })\n      \n      // submitForm\n      .addCase(submitForm.rejected, (state, action) => {\n        if (action.payload?.type === 'validation') {\n          state.validationErrors = action.payload.errors;\n        } else {\n          state.error = action.payload?.message || 'Submission failed';\n        }\n      })\n      \n      // Handle multiple action types with matcher\n      .addMatcher(\n        (action) => action.type.startsWith('users/') && action.type.endsWith('/pending'),\n        (state) => {\n          state.loading = true;\n        }\n      )\n      .addMatcher(\n        (action) => action.type.startsWith('users/') && action.type.endsWith('/fulfilled'),\n        (state) => {\n          state.loading = false;\n        }\n      );\n  }\n});\n\nexport const { clearError, clearValidationErrors } = usersSlice.actions;\nexport default usersSlice.reducer;"
    },
    {
      "type": "code",
      "language": "javascript",
      "title": "Using Async Thunks in Components",
      "code": "// components/UsersList.jsx\nimport { useEffect } from 'react';\nimport { useSelector, useDispatch } from 'react-redux';\nimport { fetchUsers, updateUser, fetchUserById } from '../slices/usersSlice';\n\nfunction UsersList() {\n  const dispatch = useDispatch();\n  const { items: users, loading, error } = useSelector(state => state.users);\n\n  useEffect(() => {\n    // Dispatch async thunk\n    const promise = dispatch(fetchUsers());\n    \n    // Cleanup: abort if component unmounts\n    return () => {\n      promise.abort();\n    };\n  }, [dispatch]);\n\n  // Handle async thunk with .unwrap()\n  const handleUpdate = async (userData) => {\n    try {\n      // unwrap() returns the fulfilled value or throws the rejected value\n      const result = await dispatch(updateUser(userData)).unwrap();\n      console.log('Update successful:', result);\n    } catch (error) {\n      // Handle rejected case\n      console.error('Update failed:', error);\n    }\n  };\n\n  // Check thunk status\n  const handleFetch = async (userId) => {\n    const resultAction = await dispatch(fetchUserById(userId));\n    \n    if (fetchUserById.fulfilled.match(resultAction)) {\n      console.log('Fetched:', resultAction.payload);\n    } else {\n      console.error('Failed:', resultAction.error);\n    }\n  };\n\n  if (loading) return <div>Loading...</div>;\n  if (error) return <div>Error: {error}</div>;\n\n  return (\n    <ul>\n      {users.map(user => (\n        <li key={user.id}>\n          {user.name}\n          <button onClick={() => handleUpdate({ ...user, name: 'Updated' })}>\n            Update\n          </button>\n        </li>\n      ))}\n    </ul>\n  );\n}\n\n// Custom hook for async thunk with loading state\nfunction useAsyncThunk(thunk) {\n  const dispatch = useDispatch();\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState(null);\n\n  const execute = useCallback(async (...args) => {\n    setLoading(true);\n    setError(null);\n    try {\n      const result = await dispatch(thunk(...args)).unwrap();\n      return result;\n    } catch (err) {\n      setError(err);\n      throw err;\n    } finally {\n      setLoading(false);\n    }\n  }, [dispatch, thunk]);\n\n  return { execute, loading, error };\n}\n\n// Usage\nfunction UserForm() {\n  const { execute: updateUser, loading, error } = useAsyncThunk(updateUser);\n\n  const handleSubmit = async (data) => {\n    try {\n      await updateUser(data);\n      // Success handling\n    } catch (err) {\n      // Error handling\n    }\n  };\n\n  return (\n    <form onSubmit={handleSubmit}>\n      {/* form fields */}\n      <button disabled={loading}>Submit</button>\n      {error && <div>{error.message}</div>}\n    </form>\n  );\n}"
    },
    {
      "type": "code",
      "language": "text",
      "title": "createAsyncThunk Action Types",
      "code": "┌─────────────────────────────────────────────────────────────────┐\n│              createAsyncThunk ACTION LIFECYCLE                  │\n├─────────────────────────────────────────────────────────────────┤\n│                                                                 │\n│  const fetchUsers = createAsyncThunk('users/fetch', async...)  │\n│                                                                 │\n│  GENERATES THREE ACTION TYPES:                                  │\n│                                                                 │\n│  1. PENDING: 'users/fetch/pending'                             │\n│     Dispatched when async function starts                       │\n│     action = {                                                  │\n│       type: 'users/fetch/pending',                             │\n│       payload: undefined,                                       │\n│       meta: {                                                   │\n│         arg: originalArg,                                       │\n│         requestId: 'unique-id',                                │\n│         requestStatus: 'pending'                                │\n│       }                                                         │\n│     }                                                           │\n│                                                                 │\n│  2. FULFILLED: 'users/fetch/fulfilled'                         │\n│     Dispatched when Promise resolves                            │\n│     action = {                                                  │\n│       type: 'users/fetch/fulfilled',                           │\n│       payload: returnedData,                                    │\n│       meta: {                                                   │\n│         arg: originalArg,                                       │\n│         requestId: 'unique-id',                                │\n│         requestStatus: 'fulfilled'                              │\n│       }                                                         │\n│     }                                                           │\n│                                                                 │\n│  3. REJECTED: 'users/fetch/rejected'                           │\n│     Dispatched when Promise rejects                             │\n│     action = {                                                  │\n│       type: 'users/fetch/rejected',                            │\n│       payload: rejectWithValue payload (if used),              │\n│       error: { name, message, stack } OR serialized error,     │\n│       meta: {                                                   │\n│         arg: originalArg,                                       │\n│         requestId: 'unique-id',                                │\n│         requestStatus: 'rejected',                              │\n│         aborted: boolean,                                       │\n│         rejectedWithValue: boolean                              │\n│       }                                                         │\n│     }                                                           │\n│                                                                 │\n└─────────────────────────────────────────────────────────────────┘"
    },
    {
      "type": "interview-tip",
      "tip": "createAsyncThunk Best Practices",
      "explanation": "1. Always use try/catch with rejectWithValue for custom error handling\n2. Use .unwrap() when you need to handle success/failure in components\n3. Implement cancellation for requests that might be abandoned\n4. Use condition option to prevent unnecessary API calls\n5. Access getState() for conditional logic based on current state\n6. Use extra argument for dependency injection (API services)\n7. Handle all three states (pending/fulfilled/rejected) in extraReducers"
    },
    {
      "type": "title",
      "level": 2,
      "content": "createEntityAdapter"
    },
    {
      "type": "description",
      "content": "createEntityAdapter provides a standardized way to store and manage normalized data in a slice. It generates a set of reducer functions and selectors for performing CRUD operations on a normalized state structure with ids array and entities object."
    },
    {
      "type": "code",
      "language": "javascript",
      "title": "createEntityAdapter Complete Example",
      "code": "// slices/postsSlice.js\nimport {\n  createSlice,\n  createAsyncThunk,\n  createEntityAdapter,\n  createSelector\n} from '@reduxjs/toolkit';\n\n// Create entity adapter\nconst postsAdapter = createEntityAdapter({\n  // Assume IDs are stored in 'id' field by default\n  // Custom ID selector if needed\n  selectId: (post) => post.id,\n  \n  // Keep the \"all IDs\" array sorted by date\n  sortComparer: (a, b) => b.createdAt.localeCompare(a.createdAt)\n});\n\n// Get initial state from adapter\n// { ids: [], entities: {} }\nconst initialState = postsAdapter.getInitialState({\n  // Add additional state fields\n  loading: false,\n  error: null,\n  selectedPostId: null,\n  filters: {\n    status: 'all',\n    author: null\n  }\n});\n\n// Async thunks\nexport const fetchPosts = createAsyncThunk('posts/fetchAll', async () => {\n  const response = await fetch('/api/posts');\n  return response.json();\n});\n\nexport const addNewPost = createAsyncThunk('posts/addNew', async (post) => {\n  const response = await fetch('/api/posts', {\n    method: 'POST',\n    body: JSON.stringify(post)\n  });\n  return response.json();\n});\n\nexport const updatePost = createAsyncThunk('posts/update', async (post) => {\n  const response = await fetch(`/api/posts/${post.id}`, {\n    method: 'PUT',\n    body: JSON.stringify(post)\n  });\n  return response.json();\n});\n\nexport const deletePost = createAsyncThunk('posts/delete', async (postId) => {\n  await fetch(`/api/posts/${postId}`, { method: 'DELETE' });\n  return postId;\n});\n\nconst postsSlice = createSlice({\n  name: 'posts',\n  initialState,\n  reducers: {\n    // Use adapter CRUD methods\n    postAdded: postsAdapter.addOne,\n    postsReceived: postsAdapter.setAll,\n    postUpdated: postsAdapter.updateOne,\n    postRemoved: postsAdapter.removeOne,\n    \n    // Custom reducers\n    selectPost: (state, action) => {\n      state.selectedPostId = action.payload;\n    },\n    \n    setFilter: (state, action) => {\n      state.filters = { ...state.filters, ...action.payload };\n    },\n    \n    // Custom update with adapter\n    togglePostLike: (state, action) => {\n      const postId = action.payload;\n      const post = state.entities[postId];\n      if (post) {\n        post.liked = !post.liked;\n        post.likes += post.liked ? 1 : -1;\n      }\n    },\n    \n    // Upsert: update if exists, add if not\n    upsertPost: postsAdapter.upsertOne,\n    upsertManyPosts: postsAdapter.upsertMany,\n    \n    // Remove all\n    clearAllPosts: postsAdapter.removeAll\n  },\n  extraReducers: (builder) => {\n    builder\n      .addCase(fetchPosts.pending, (state) => {\n        state.loading = true;\n      })\n      .addCase(fetchPosts.fulfilled, (state, action) => {\n        state.loading = false;\n        // Use setAll to replace all entities\n        postsAdapter.setAll(state, action.payload);\n      })\n      .addCase(fetchPosts.rejected, (state, action) => {\n        state.loading = false;\n        state.error = action.error.message;\n      })\n      .addCase(addNewPost.fulfilled, (state, action) => {\n        // Use addOne to add a single entity\n        postsAdapter.addOne(state, action.payload);\n      })\n      .addCase(updatePost.fulfilled, (state, action) => {\n        // Use upsertOne to update or add\n        postsAdapter.upsertOne(state, action.payload);\n      })\n      .addCase(deletePost.fulfilled, (state, action) => {\n        // Use removeOne to delete\n        postsAdapter.removeOne(state, action.payload);\n      });\n  }\n});\n\n// Export actions\nexport const {\n  postAdded,\n  postsReceived,\n  postUpdated,\n  postRemoved,\n  selectPost,\n  setFilter,\n  togglePostLike,\n  upsertPost,\n  clearAllPosts\n} = postsSlice.actions;\n\n// Export reducer\nexport default postsSlice.reducer;\n\n// SELECTORS\n// Get entity adapter selectors\n// These work with the normalized state structure\nexport const {\n  selectAll: selectAllPosts,      // Returns array of all entities\n  selectById: selectPostById,      // Returns entity by ID\n  selectIds: selectPostIds,        // Returns array of IDs\n  selectEntities: selectPostEntities, // Returns entities object\n  selectTotal: selectTotalPosts    // Returns total count\n} = postsAdapter.getSelectors((state) => state.posts);\n\n// Custom selectors using createSelector for memoization\nexport const selectPostsLoading = (state) => state.posts.loading;\nexport const selectPostsError = (state) => state.posts.error;\nexport const selectSelectedPostId = (state) => state.posts.selectedPostId;\n\nexport const selectSelectedPost = createSelector(\n  [selectPostEntities, selectSelectedPostId],\n  (entities, selectedId) => selectedId ? entities[selectedId] : null\n);\n\nexport const selectPostsByAuthor = createSelector(\n  [selectAllPosts, (state, authorId) => authorId],\n  (posts, authorId) => posts.filter(post => post.authorId === authorId)\n);\n\nexport const selectFilteredPosts = createSelector(\n  [selectAllPosts, (state) => state.posts.filters],\n  (posts, filters) => {\n    let result = posts;\n    \n    if (filters.status !== 'all') {\n      result = result.filter(post => post.status === filters.status);\n    }\n    \n    if (filters.author) {\n      result = result.filter(post => post.authorId === filters.author);\n    }\n    \n    return result;\n  }\n);\n\nexport const selectPostStats = createSelector(\n  [selectAllPosts],\n  (posts) => ({\n    total: posts.length,\n    published: posts.filter(p => p.status === 'published').length,\n    draft: posts.filter(p => p.status === 'draft').length,\n    totalLikes: posts.reduce((sum, p) => sum + p.likes, 0)\n  })\n);"
    },
    {
      "type": "code",
      "language": "text",
      "title": "Entity Adapter Methods",
      "code": "┌─────────────────────────────────────────────────────────────────┐\n│              createEntityAdapter CRUD METHODS                   │\n├─────────────────────────────────────────────────────────────────┤\n│                                                                 │\n│  NORMALIZED STATE STRUCTURE:                                    │\n│  {                                                              │\n│    ids: [1, 2, 3],              // Array of entity IDs         │\n│    entities: {                   // Object with entities        │\n│      1: { id: 1, name: '...' },                                │\n│      2: { id: 2, name: '...' },                                │\n│      3: { id: 3, name: '...' }                                 │\n│    }                                                            │\n│  }                                                              │\n│                                                                 │\n│  ADD METHODS:                                                   │\n│  ├─ addOne(state, entity)       Add single entity              │\n│  ├─ addMany(state, [entities])  Add multiple entities          │\n│  └─ setAll(state, [entities])   Replace all entities           │\n│                                                                 │\n│  UPDATE METHODS:                                                │\n│  ├─ updateOne(state, {id, changes})    Partial update          │\n│  ├─ updateMany(state, [{id, changes}]) Multiple updates        │\n│  ├─ upsertOne(state, entity)    Add or update single           │\n│  ├─ upsertMany(state, [entities]) Add or update multiple       │\n│  └─ setOne(state, entity)       Replace single entity          │\n│                                                                 │\n│  REMOVE METHODS:                                                │\n│  ├─ removeOne(state, id)        Remove by ID                   │\n│  ├─ removeMany(state, [ids])    Remove multiple by IDs         │\n│  └─ removeAll(state)            Remove all entities            │\n│                                                                 │\n│  SELECTORS (from getSelectors):                                 │\n│  ├─ selectAll    → [entity1, entity2, ...]                     │\n│  ├─ selectById   → entity or undefined                         │\n│  ├─ selectIds    → [id1, id2, ...]                             │\n│  ├─ selectEntities → { id: entity, ... }                       │\n│  └─ selectTotal  → number                                      │\n│                                                                 │\n└─────────────────────────────────────────────────────────────────┘"
    },
    {
      "type": "interview-tip",
      "tip": "Why Normalize State?",
      "explanation": "Benefits of normalized state:\n1. No data duplication\n2. Easy updates - change one place\n3. Fast lookups by ID - O(1)\n4. Works well with relational data\n5. Easier to keep in sync\n6. Simpler reducer logic\n\nUse createEntityAdapter when:\n- Managing collections of items\n- Need CRUD operations\n- Items have unique IDs\n- Performance matters for large lists"
    },
    {
      "type": "title",
      "level": 2,
      "content": "createSelector (Reselect)"
    },
    {
      "type": "description",
      "content": "createSelector from Reselect creates memoized selectors that only recalculate when their inputs change. RTK exports createSelector from the Reselect library. Memoized selectors improve performance by avoiding unnecessary recalculations and preventing unnecessary re-renders."
    },
    {
      "type": "code",
      "language": "javascript",
      "title": "createSelector Patterns",
      "code": "import { createSelector } from '@reduxjs/toolkit';\n\n// Basic selector (not memoized)\nconst selectTodos = (state) => state.todos.items;\nconst selectFilter = (state) => state.todos.filter;\n\n// Memoized selector\nconst selectFilteredTodos = createSelector(\n  // Input selectors (dependencies)\n  [selectTodos, selectFilter],\n  // Result function - only runs when inputs change\n  (todos, filter) => {\n    console.log('Computing filtered todos...'); // Only logs when inputs change\n    \n    switch (filter) {\n      case 'active':\n        return todos.filter(todo => !todo.completed);\n      case 'completed':\n        return todos.filter(todo => todo.completed);\n      default:\n        return todos;\n    }\n  }\n);\n\n// Selector with multiple dependencies\nconst selectTodoStats = createSelector(\n  [selectTodos],\n  (todos) => ({\n    total: todos.length,\n    completed: todos.filter(t => t.completed).length,\n    active: todos.filter(t => !t.completed).length,\n    percentComplete: todos.length\n      ? Math.round((todos.filter(t => t.completed).length / todos.length) * 100)\n      : 0\n  })\n);\n\n// Chained selectors\nconst selectCompletedTodos = createSelector(\n  [selectTodos],\n  (todos) => todos.filter(todo => todo.completed)\n);\n\nconst selectCompletedTodoIds = createSelector(\n  [selectCompletedTodos],\n  (completedTodos) => completedTodos.map(todo => todo.id)\n);\n\n// Parameterized selector using factory pattern\nconst makeSelectTodoById = () => {\n  return createSelector(\n    [selectTodos, (state, todoId) => todoId],\n    (todos, todoId) => todos.find(todo => todo.id === todoId)\n  );\n};\n\n// Usage in component\nfunction TodoItem({ todoId }) {\n  // Create selector instance per component\n  const selectTodoById = useMemo(makeSelectTodoById, []);\n  const todo = useSelector(state => selectTodoById(state, todoId));\n  // ...\n}\n\n// Alternative: Using createSelector with parameters\nconst selectTodoById = createSelector(\n  [selectTodos, (state, todoId) => todoId],\n  (todos, todoId) => todos.find(todo => todo.id === todoId)\n);\n\n// Complex selector with multiple slices\nconst selectUsers = (state) => state.users.entities;\nconst selectPosts = (state) => state.posts.items;\n\nconst selectPostsWithAuthors = createSelector(\n  [selectPosts, selectUsers],\n  (posts, users) => posts.map(post => ({\n    ...post,\n    author: users[post.authorId]\n  }))\n);\n\n// Selector for search/filter\nconst selectSearchTerm = (state) => state.search.term;\n\nconst selectSearchResults = createSelector(\n  [selectPosts, selectSearchTerm],\n  (posts, searchTerm) => {\n    if (!searchTerm) return posts;\n    \n    const term = searchTerm.toLowerCase();\n    return posts.filter(post =>\n      post.title.toLowerCase().includes(term) ||\n      post.content.toLowerCase().includes(term)\n    );\n  }\n);\n\n// Selector composition\nconst selectActiveUserPosts = createSelector(\n  [selectSearchResults, (state) => state.auth.userId],\n  (posts, currentUserId) => posts.filter(post => post.authorId === currentUserId)\n);\n\n// Using in components\nfunction PostsList() {\n  // Memoized selector - component won't re-render unless filtered posts change\n  const filteredPosts = useSelector(selectFilteredPosts);\n  const stats = useSelector(selectTodoStats);\n  \n  return (\n    <div>\n      <p>Total: {stats.total} | Completed: {stats.percentComplete}%</p>\n      <ul>\n        {filteredPosts.map(post => (\n          <li key={post.id}>{post.title}</li>\n        ))}\n      </ul>\n    </div>\n  );\n}"
    },
    {
      "type": "code",
      "language": "text",
      "title": "createSelector Flow",
      "code": "┌─────────────────────────────────────────────────────────────────┐\n│                 createSelector MEMOIZATION                      │\n├─────────────────────────────────────────────────────────────────┤\n│                                                                 │\n│  const selectFilteredTodos = createSelector(                    │\n│    [selectTodos, selectFilter],   ◄── Input Selectors          │\n│    (todos, filter) => {...}       ◄── Result Function          │\n│  );                                                             │\n│                                                                 │\n│  HOW IT WORKS:                                                  │\n│                                                                 │\n│  First Call:                                                    │\n│  ┌─────────────┐     ┌─────────────┐     ┌─────────────┐       │\n│  │ selectTodos │────►│  Compare    │────►│   Result    │       │\n│  │ [1,2,3]     │     │  Inputs     │     │  Function   │       │\n│  ├─────────────┤     │             │     │  Runs!      │       │\n│  │selectFilter │────►│  (No cache) │────►│  Returns    │       │\n│  │ 'active'    │     │             │     │  [1,3]      │       │\n│  └─────────────┘     └─────────────┘     └─────────────┘       │\n│                                           │                     │\n│                                           ▼ CACHE               │\n│  Second Call (same inputs):        ┌─────────────┐             │\n│  ┌─────────────┐     ┌─────────────┐│   Cached    │             │\n│  │ selectTodos │────►│  Compare    ││   Result    │             │\n│  │ [1,2,3]     │     │  Inputs     ││   [1,3]     │             │\n│  ├─────────────┤     │             │└─────────────┘             │\n│  │selectFilter │────►│  SAME!      │────► Return cached!       │\n│  │ 'active'    │     │  Skip calc  │     (no recalculation)    │\n│  └─────────────┘     └─────────────┘                           │\n│                                                                 │\n│  Third Call (inputs changed):                                   │\n│  ┌─────────────┐     ┌─────────────┐     ┌─────────────┐       │\n│  │ selectTodos │────►│  Compare    │────►│   Result    │       │\n│  │ [1,2,3]     │     │  Inputs     │     │  Function   │       │\n│  ├─────────────┤     │             │     │  Runs!      │       │\n│  │selectFilter │────►│  DIFFERENT! │────►│  Returns    │       │\n│  │ 'completed' │     │  Recalculate│     │  [2]        │       │\n│  └─────────────┘     └─────────────┘     └─────────────┘       │\n│                                                                 │\n└─────────────────────────────────────────────────────────────────┘"
    },
    {
      "type": "interview-tip",
      "tip": "Selector Best Practices",
      "explanation": "1. Keep input selectors simple - just extract data\n2. Put transformation logic in result function\n3. Create selector factories for parameterized selectors\n4. Co-locate selectors with slices\n5. Name selectors starting with 'select'\n6. Chain selectors for complex derivations\n7. Use TypeScript for better type inference\n8. Test selectors in isolation"
    }
  ]
},
{
  "id": "section-16",
  "title": "RTK Query",
  "blocks": [
    {
      "type": "title",
      "level": 1,
      "content": "Introduction to RTK Query"
    },
    {
      "type": "description",
      "content": "RTK Query is a powerful data fetching and caching tool built into Redux Toolkit. It simplifies common data fetching use cases, eliminating the need to write thunks, loading state logic, or normalization. It provides automatic caching, refetching, polling, and optimistic updates out of the box."
    },
    {
      "type": "code",
      "language": "text",
      "title": "RTK Query Features",
      "code": "┌─────────────────────────────────────────────────────────────────┐\n│                    RTK QUERY FEATURES                           │\n├─────────────────────────────────────────────────────────────────┤\n│                                                                 │\n│  AUTOMATIC FEATURES:                                            │\n│  ✅ Caching - responses are cached and reused                  │\n│  ✅ Deduplication - identical requests are deduplicated        │\n│  ✅ Loading states - isLoading, isFetching, isSuccess, isError │\n│  ✅ Refetching - manual and automatic refetch triggers         │\n│  ✅ Polling - periodic data refreshing                         │\n│  ✅ Invalidation - cache invalidation with tags                │\n│  ✅ Optimistic updates - update UI before server response      │\n│  ✅ Prefetching - load data before it's needed                 │\n│  ✅ Code generation - from OpenAPI/GraphQL schemas             │\n│                                                                 │\n│  COMPARISON WITH OTHER SOLUTIONS:                               │\n│  ┌────────────────┬──────────┬──────────┬───────────┐          │\n│  │ Feature        │ RTK Query│ React Q. │ SWR       │          │\n│  ├────────────────┼──────────┼──────────┼───────────┤          │\n│  │ Redux integr.  │ ✅ Built │ ❌ Extra │ ❌ Extra  │          │\n│  │ Auto caching   │ ✅       │ ✅       │ ✅        │          │\n│  │ Devtools       │ ✅ Redux │ ✅ Own   │ ❌        │          │\n│  │ Mutations      │ ✅       │ ✅       │ ✅        │          │\n│  │ Code gen       │ ✅       │ ❌       │ ❌        │          │\n│  │ Cache tags     │ ✅       │ ❌       │ ❌        │          │\n│  │ Streaming      │ ✅       │ ❌       │ ❌        │          │\n│  └────────────────┴──────────┴──────────┴───────────┘          │\n│                                                                 │\n└─────────────────────────────────────────────────────────────────┘"
    },
    {
      "type": "title",
      "level": 2,
      "content": "Creating an API Slice"
    },
    {
      "type": "code",
      "language": "javascript",
      "title": "Basic API Setup",
      "code": "// api/apiSlice.js\nimport { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react';\n\n// Create the API slice\nexport const apiSlice = createApi({\n  // Unique key for this API in Redux store\n  reducerPath: 'api',\n  \n  // Base query function (like axios instance)\n  baseQuery: fetchBaseQuery({\n    baseUrl: 'https://api.example.com',\n    // Add default headers\n    prepareHeaders: (headers, { getState }) => {\n      // Get token from auth state\n      const token = getState().auth.token;\n      if (token) {\n        headers.set('Authorization', `Bearer ${token}`);\n      }\n      headers.set('Content-Type', 'application/json');\n      return headers;\n    },\n    // Credentials for cookies\n    credentials: 'include'\n  }),\n  \n  // Cache tag types for invalidation\n  tagTypes: ['Post', 'User', 'Comment'],\n  \n  // Define endpoints\n  endpoints: (builder) => ({\n    // Query endpoint (GET request)\n    getPosts: builder.query({\n      query: () => '/posts',\n      // Transform response\n      transformResponse: (response) => response.data,\n      // Provide cache tags\n      providesTags: (result) =>\n        result\n          ? [\n              ...result.map(({ id }) => ({ type: 'Post', id })),\n              { type: 'Post', id: 'LIST' }\n            ]\n          : [{ type: 'Post', id: 'LIST' }]\n    }),\n    \n    // Query with parameter\n    getPostById: builder.query({\n      query: (postId) => `/posts/${postId}`,\n      providesTags: (result, error, id) => [{ type: 'Post', id }]\n    }),\n    \n    // Query with multiple parameters\n    getPostsByUser: builder.query({\n      query: ({ userId, page = 1, limit = 10 }) => ({\n        url: `/users/${userId}/posts`,\n        params: { page, limit }\n      }),\n      providesTags: (result, error, { userId }) => [\n        { type: 'Post', id: `USER-${userId}` }\n      ]\n    }),\n    \n    // Mutation endpoint (POST/PUT/DELETE)\n    addPost: builder.mutation({\n      query: (newPost) => ({\n        url: '/posts',\n        method: 'POST',\n        body: newPost\n      }),\n      // Invalidate cache to refetch\n      invalidatesTags: [{ type: 'Post', id: 'LIST' }]\n    }),\n    \n    // Update mutation\n    updatePost: builder.mutation({\n      query: ({ id, ...patch }) => ({\n        url: `/posts/${id}`,\n        method: 'PATCH',\n        body: patch\n      }),\n      invalidatesTags: (result, error, { id }) => [\n        { type: 'Post', id },\n        { type: 'Post', id: 'LIST' }\n      ]\n    }),\n    \n    // Delete mutation\n    deletePost: builder.mutation({\n      query: (id) => ({\n        url: `/posts/${id}`,\n        method: 'DELETE'\n      }),\n      invalidatesTags: (result, error, id) => [\n        { type: 'Post', id },\n        { type: 'Post', id: 'LIST' }\n      ]\n    })\n  })\n});\n\n// Export auto-generated hooks\nexport const {\n  useGetPostsQuery,\n  useGetPostByIdQuery,\n  useGetPostsByUserQuery,\n  useAddPostMutation,\n  useUpdatePostMutation,\n  useDeletePostMutation,\n  // Lazy query hooks (triggered manually)\n  useLazyGetPostsQuery,\n  useLazyGetPostByIdQuery,\n  // Prefetch\n  usePrefetch\n} = apiSlice;"
    },
    {
      "type": "code",
      "language": "javascript",
      "title": "Store Configuration with RTK Query",
      "code": "// store/store.js\nimport { configureStore } from '@reduxjs/toolkit';\nimport { setupListeners } from '@reduxjs/toolkit/query';\nimport { apiSlice } from '../api/apiSlice';\nimport authReducer from './slices/authSlice';\nimport uiReducer from './slices/uiSlice';\n\nexport const store = configureStore({\n  reducer: {\n    // Add the API reducer\n    [apiSlice.reducerPath]: apiSlice.reducer,\n    auth: authReducer,\n    ui: uiReducer\n  },\n  // Add the API middleware\n  middleware: (getDefaultMiddleware) =>\n    getDefaultMiddleware().concat(apiSlice.middleware)\n});\n\n// Enable refetchOnFocus and refetchOnReconnect\nsetupListeners(store.dispatch);"
    },
    {
      "type": "title",
      "level": 2,
      "content": "Using Query Hooks"
    },
    {
      "type": "code",
      "language": "javascript",
      "title": "Query Hooks in Components",
      "code": "import {\n  useGetPostsQuery,\n  useGetPostByIdQuery,\n  useLazyGetPostsQuery,\n  usePrefetch\n} from '../api/apiSlice';\n\n// Basic query\nfunction PostsList() {\n  const {\n    data: posts,           // Response data\n    isLoading,             // First load, no data yet\n    isFetching,            // Any request in progress\n    isSuccess,             // Request succeeded\n    isError,               // Request failed\n    error,                 // Error object\n    refetch,               // Manual refetch function\n    isUninitialized,       // Query hasn't started\n    currentData,           // Data from current request\n    fulfilledTimeStamp,    // When request completed\n    startedTimeStamp       // When request started\n  } = useGetPostsQuery();\n\n  if (isLoading) return <div>Loading...</div>;\n  if (isError) return <div>Error: {error.message}</div>;\n\n  return (\n    <div>\n      <button onClick={refetch} disabled={isFetching}>\n        {isFetching ? 'Refreshing...' : 'Refresh'}\n      </button>\n      <ul>\n        {posts?.map(post => (\n          <li key={post.id}>{post.title}</li>\n        ))}\n      </ul>\n    </div>\n  );\n}\n\n// Query with parameters\nfunction PostDetail({ postId }) {\n  const { data: post, isLoading, error } = useGetPostByIdQuery(postId, {\n    // Skip query if no postId\n    skip: !postId,\n    // Refetch when window focuses\n    refetchOnFocus: true,\n    // Refetch when reconnected\n    refetchOnReconnect: true,\n    // Poll every 30 seconds\n    pollingInterval: 30000,\n    // Don't poll when window is hidden\n    skipPollingIfUnfocused: true\n  });\n\n  if (!postId) return <div>Select a post</div>;\n  if (isLoading) return <div>Loading...</div>;\n  if (error) return <div>Error loading post</div>;\n\n  return (\n    <article>\n      <h1>{post.title}</h1>\n      <p>{post.content}</p>\n    </article>\n  );\n}\n\n// Lazy query (triggered manually)\nfunction SearchPosts() {\n  const [trigger, { data, isLoading, isUninitialized }] = useLazyGetPostsQuery();\n\n  const handleSearch = (searchTerm) => {\n    // Trigger the query\n    trigger({ search: searchTerm });\n  };\n\n  return (\n    <div>\n      <input onChange={(e) => handleSearch(e.target.value)} />\n      {isLoading && <div>Searching...</div>}\n      {data && <ResultsList results={data} />}\n    </div>\n  );\n}\n\n// Prefetching\nfunction PostCard({ post }) {\n  const prefetchPost = usePrefetch('getPostById');\n\n  const handleMouseEnter = () => {\n    // Prefetch when hovering\n    prefetchPost(post.id);\n  };\n\n  return (\n    <div onMouseEnter={handleMouseEnter}>\n      <Link to={`/posts/${post.id}`}>{post.title}</Link>\n    </div>\n  );\n}\n\n// Multiple queries\nfunction Dashboard({ userId }) {\n  const { data: user } = useGetUserQuery(userId);\n  const { data: posts } = useGetPostsByUserQuery(userId);\n  const { data: notifications } = useGetNotificationsQuery();\n\n  // All queries run in parallel\n  return (\n    <div>\n      <UserInfo user={user} />\n      <PostsList posts={posts} />\n      <NotificationsList notifications={notifications} />\n    </div>\n  );\n}\n\n// Conditional query with select\nfunction ActivePosts() {\n  const { activePosts } = useGetPostsQuery(undefined, {\n    selectFromResult: ({ data, ...rest }) => ({\n      ...rest,\n      activePosts: data?.filter(post => post.status === 'active') ?? []\n    })\n  });\n\n  return (\n    <ul>\n      {activePosts.map(post => (\n        <li key={post.id}>{post.title}</li>\n      ))}\n    </ul>\n  );\n}"
    },
    {
      "type": "title",
      "level": 2,
      "content": "Using Mutation Hooks"
    },
    {
      "type": "code",
      "language": "javascript",
      "title": "Mutation Hooks in Components",
      "code": "import {\n  useAddPostMutation,\n  useUpdatePostMutation,\n  useDeletePostMutation\n} from '../api/apiSlice';\n\n// Basic mutation\nfunction AddPostForm() {\n  const [\n    addPost,\n    {\n      isLoading,      // Mutation in progress\n      isSuccess,      // Mutation succeeded\n      isError,        // Mutation failed\n      error,          // Error object\n      data,           // Response data\n      reset           // Reset mutation state\n    }\n  ] = useAddPostMutation();\n\n  const [title, setTitle] = useState('');\n  const [content, setContent] = useState('');\n\n  const handleSubmit = async (e) => {\n    e.preventDefault();\n    try {\n      // Use unwrap() for easier error handling\n      const result = await addPost({ title, content }).unwrap();\n      console.log('Post created:', result);\n      setTitle('');\n      setContent('');\n    } catch (err) {\n      console.error('Failed to create post:', err);\n    }\n  };\n\n  return (\n    <form onSubmit={handleSubmit}>\n      <input\n        value={title}\n        onChange={(e) => setTitle(e.target.value)}\n        placeholder=\"Title\"\n      />\n      <textarea\n        value={content}\n        onChange={(e) => setContent(e.target.value)}\n        placeholder=\"Content\"\n      />\n      <button type=\"submit\" disabled={isLoading}>\n        {isLoading ? 'Creating...' : 'Create Post'}\n      </button>\n      {isError && <div className=\"error\">{error.message}</div>}\n      {isSuccess && <div className=\"success\">Post created!</div>}\n    </form>\n  );\n}\n\n// Update mutation\nfunction EditPostForm({ post }) {\n  const [updatePost, { isLoading }] = useUpdatePostMutation();\n  const [title, setTitle] = useState(post.title);\n\n  const handleSave = async () => {\n    try {\n      await updatePost({\n        id: post.id,\n        title\n      }).unwrap();\n      alert('Post updated!');\n    } catch (err) {\n      alert('Failed to update: ' + err.message);\n    }\n  };\n\n  return (\n    <div>\n      <input\n        value={title}\n        onChange={(e) => setTitle(e.target.value)}\n      />\n      <button onClick={handleSave} disabled={isLoading}>\n        {isLoading ? 'Saving...' : 'Save'}\n      </button>\n    </div>\n  );\n}\n\n// Delete with confirmation\nfunction DeletePostButton({ postId }) {\n  const [deletePost, { isLoading }] = useDeletePostMutation();\n\n  const handleDelete = async () => {\n    if (window.confirm('Are you sure?')) {\n      try {\n        await deletePost(postId).unwrap();\n      } catch (err) {\n        console.error('Delete failed:', err);\n      }\n    }\n  };\n\n  return (\n    <button onClick={handleDelete} disabled={isLoading}>\n      {isLoading ? 'Deleting...' : 'Delete'}\n    </button>\n  );\n}\n\n// Fixed mutation state per call\nfunction PostsList() {\n  const [deletePost] = useDeletePostMutation({\n    fixedCacheKey: 'shared-delete-post'\n  });\n\n  // Multiple components share the same mutation state\n  return posts.map(post => (\n    <PostItem key={post.id} post={post} onDelete={deletePost} />\n  ));\n}"
    },
    {
      "type": "title",
      "level": 2,
      "content": "Cache Tags & Invalidation"
    },
    {
      "type": "code",
      "language": "javascript",
      "title": "Advanced Cache Management",
      "code": "// api/apiSlice.js\nexport const apiSlice = createApi({\n  reducerPath: 'api',\n  baseQuery: fetchBaseQuery({ baseUrl: '/api' }),\n  tagTypes: ['Post', 'User', 'Comment'],\n  endpoints: (builder) => ({\n    // Provides tags for this query's cache\n    getPosts: builder.query({\n      query: () => '/posts',\n      providesTags: (result, error, arg) =>\n        result\n          ? [\n              // Tag each post individually\n              ...result.map(({ id }) => ({ type: 'Post', id })),\n              // Tag the list\n              { type: 'Post', id: 'LIST' }\n            ]\n          : [{ type: 'Post', id: 'LIST' }]\n    }),\n\n    getPost: builder.query({\n      query: (id) => `/posts/${id}`,\n      providesTags: (result, error, id) => [{ type: 'Post', id }]\n    }),\n\n    getPostComments: builder.query({\n      query: (postId) => `/posts/${postId}/comments`,\n      providesTags: (result, error, postId) =>\n        result\n          ? [\n              ...result.map(({ id }) => ({ type: 'Comment', id })),\n              { type: 'Comment', id: `POST-${postId}` }\n            ]\n          : [{ type: 'Comment', id: `POST-${postId}` }]\n    }),\n\n    // Invalidates tags after mutation\n    addPost: builder.mutation({\n      query: (post) => ({\n        url: '/posts',\n        method: 'POST',\n        body: post\n      }),\n      // Invalidate list to trigger refetch\n      invalidatesTags: [{ type: 'Post', id: 'LIST' }]\n    }),\n\n    updatePost: builder.mutation({\n      query: ({ id, ...body }) => ({\n        url: `/posts/${id}`,\n        method: 'PATCH',\n        body\n      }),\n      // Invalidate specific post and list\n      invalidatesTags: (result, error, { id }) => [\n        { type: 'Post', id },\n        { type: 'Post', id: 'LIST' }\n      ]\n    }),\n\n    deletePost: builder.mutation({\n      query: (id) => ({\n        url: `/posts/${id}`,\n        method: 'DELETE'\n      }),\n      invalidatesTags: (result, error, id) => [\n        { type: 'Post', id },\n        { type: 'Post', id: 'LIST' },\n        // Also invalidate comments for this post\n        { type: 'Comment', id: `POST-${id}` }\n      ]\n    }),\n\n    addComment: builder.mutation({\n      query: ({ postId, ...body }) => ({\n        url: `/posts/${postId}/comments`,\n        method: 'POST',\n        body\n      }),\n      invalidatesTags: (result, error, { postId }) => [\n        { type: 'Comment', id: `POST-${postId}` },\n        // Optionally invalidate post if comment count displayed\n        { type: 'Post', id: postId }\n      ]\n    })\n  })\n});\n\n// Manual cache updates\nimport { apiSlice } from './apiSlice';\n\n// In a component or thunk\nfunction SomeComponent() {\n  const dispatch = useDispatch();\n\n  const handleInvalidate = () => {\n    // Invalidate specific tags manually\n    dispatch(apiSlice.util.invalidateTags(['Post']));\n    \n    // Invalidate specific item\n    dispatch(apiSlice.util.invalidateTags([{ type: 'Post', id: 5 }]));\n  };\n\n  const handleResetApi = () => {\n    // Reset entire API state\n    dispatch(apiSlice.util.resetApiState());\n  };\n\n  return (\n    <button onClick={handleInvalidate}>Refresh Posts</button>\n  );\n}"
    },
    {
      "type": "title",
      "level": 2,
      "content": "Optimistic Updates"
    },
    {
      "type": "code",
      "language": "javascript",
      "title": "Optimistic Updates Implementation",
      "code": "// api/apiSlice.js\nimport { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react';\n\nexport const apiSlice = createApi({\n  reducerPath: 'api',\n  baseQuery: fetchBaseQuery({ baseUrl: '/api' }),\n  tagTypes: ['Post', 'Todo'],\n  endpoints: (builder) => ({\n    getTodos: builder.query({\n      query: () => '/todos',\n      providesTags: ['Todo']\n    }),\n\n    // Optimistic update for toggle\n    toggleTodo: builder.mutation({\n      query: ({ id, completed }) => ({\n        url: `/todos/${id}`,\n        method: 'PATCH',\n        body: { completed }\n      }),\n      // Optimistic update\n      async onQueryStarted({ id, completed }, { dispatch, queryFulfilled }) {\n        // Update cache optimistically\n        const patchResult = dispatch(\n          apiSlice.util.updateQueryData('getTodos', undefined, (draft) => {\n            const todo = draft.find(t => t.id === id);\n            if (todo) {\n              todo.completed = completed;\n            }\n          })\n        );\n\n        try {\n          // Wait for the mutation to complete\n          await queryFulfilled;\n        } catch {\n          // Revert on failure\n          patchResult.undo();\n        }\n      }\n    }),\n\n    // Optimistic add\n    addTodo: builder.mutation({\n      query: (todo) => ({\n        url: '/todos',\n        method: 'POST',\n        body: todo\n      }),\n      async onQueryStarted(todo, { dispatch, queryFulfilled }) {\n        // Create temporary ID\n        const tempId = `temp-${Date.now()}`;\n        \n        // Add optimistically\n        const patchResult = dispatch(\n          apiSlice.util.updateQueryData('getTodos', undefined, (draft) => {\n            draft.push({ ...todo, id: tempId });\n          })\n        );\n\n        try {\n          const { data: newTodo } = await queryFulfilled;\n          // Replace temp with real data\n          dispatch(\n            apiSlice.util.updateQueryData('getTodos', undefined, (draft) => {\n              const index = draft.findIndex(t => t.id === tempId);\n              if (index !== -1) {\n                draft[index] = newTodo;\n              }\n            })\n          );\n        } catch {\n          patchResult.undo();\n        }\n      }\n    }),\n\n    // Optimistic delete\n    deleteTodo: builder.mutation({\n      query: (id) => ({\n        url: `/todos/${id}`,\n        method: 'DELETE'\n      }),\n      async onQueryStarted(id, { dispatch, queryFulfilled }) {\n        // Store the deleted item\n        let deletedTodo;\n        \n        const patchResult = dispatch(\n          apiSlice.util.updateQueryData('getTodos', undefined, (draft) => {\n            const index = draft.findIndex(t => t.id === id);\n            if (index !== -1) {\n              deletedTodo = draft[index];\n              draft.splice(index, 1);\n            }\n          })\n        );\n\n        try {\n          await queryFulfilled;\n        } catch {\n          // Revert deletion\n          patchResult.undo();\n        }\n      }\n    }),\n\n    // Optimistic reorder (drag and drop)\n    reorderTodos: builder.mutation({\n      query: ({ fromIndex, toIndex }) => ({\n        url: '/todos/reorder',\n        method: 'POST',\n        body: { fromIndex, toIndex }\n      }),\n      async onQueryStarted({ fromIndex, toIndex }, { dispatch, queryFulfilled }) {\n        const patchResult = dispatch(\n          apiSlice.util.updateQueryData('getTodos', undefined, (draft) => {\n            const [removed] = draft.splice(fromIndex, 1);\n            draft.splice(toIndex, 0, removed);\n          })\n        );\n\n        try {\n          await queryFulfilled;\n        } catch {\n          patchResult.undo();\n        }\n      }\n    }),\n\n    // Pessimistic update (wait for server, then update cache)\n    updateTodo: builder.mutation({\n      query: ({ id, ...body }) => ({\n        url: `/todos/${id}`,\n        method: 'PUT',\n        body\n      }),\n      async onQueryStarted({ id }, { dispatch, queryFulfilled }) {\n        try {\n          const { data: updatedTodo } = await queryFulfilled;\n          // Update cache after success\n          dispatch(\n            apiSlice.util.updateQueryData('getTodos', undefined, (draft) => {\n              const index = draft.findIndex(t => t.id === id);\n              if (index !== -1) {\n                draft[index] = updatedTodo;\n              }\n            })\n          );\n        } catch {\n          // Handle error\n        }\n      }\n    })\n  })\n});"
    },
    {
      "type": "interview-tip",
      "tip": "RTK Query Best Practices",
      "explanation": "1. Use one API slice per base URL\n2. Split large API slices using code splitting\n3. Use tags effectively for cache invalidation\n4. Implement optimistic updates for better UX\n5. Use selectFromResult to minimize re-renders\n6. Enable setupListeners for refetch features\n7. Use skip option for conditional fetching\n8. Prefetch data for anticipated navigation\n9. Handle errors consistently across endpoints\n10. Use transformResponse for data normalization"
    },
    {
      "type": "title",
      "level": 2,
      "content": "Advanced RTK Query Patterns"
    },
    {
      "type": "code",
      "language": "javascript",
      "title": "Advanced Patterns",
      "code": "// Custom base query with error handling\nimport { fetchBaseQuery, retry } from '@reduxjs/toolkit/query/react';\n\n// Retry logic\nconst baseQueryWithRetry = retry(\n  fetchBaseQuery({ baseUrl: '/api' }),\n  { maxRetries: 3 }\n);\n\n// Custom base query with auth refresh\nconst baseQueryWithReauth = async (args, api, extraOptions) => {\n  let result = await fetchBaseQuery({ baseUrl: '/api' })(args, api, extraOptions);\n\n  if (result.error && result.error.status === 401) {\n    // Try to refresh token\n    const refreshResult = await fetchBaseQuery({ baseUrl: '/api' })(\n      '/auth/refresh',\n      api,\n      extraOptions\n    );\n\n    if (refreshResult.data) {\n      // Store the new token\n      api.dispatch(setCredentials(refreshResult.data));\n      // Retry the original request\n      result = await fetchBaseQuery({ baseUrl: '/api' })(args, api, extraOptions);\n    } else {\n      // Logout user\n      api.dispatch(logout());\n    }\n  }\n\n  return result;\n};\n\n// Streaming updates with WebSocket\nexport const apiSlice = createApi({\n  baseQuery: fetchBaseQuery({ baseUrl: '/api' }),\n  endpoints: (builder) => ({\n    getMessages: builder.query({\n      query: (channelId) => `/channels/${channelId}/messages`,\n      // Streaming updates\n      async onCacheEntryAdded(\n        channelId,\n        { updateCachedData, cacheDataLoaded, cacheEntryRemoved }\n      ) {\n        // Wait for initial data\n        await cacheDataLoaded;\n\n        // Create WebSocket connection\n        const ws = new WebSocket(`ws://api.example.com/channels/${channelId}`);\n\n        ws.onmessage = (event) => {\n          const message = JSON.parse(event.data);\n          // Update cache with new message\n          updateCachedData((draft) => {\n            draft.push(message);\n          });\n        };\n\n        // Cleanup on cache entry removal\n        await cacheEntryRemoved;\n        ws.close();\n      }\n    })\n  })\n});\n\n// Code splitting - inject endpoints\n// api/baseApi.js\nexport const baseApi = createApi({\n  reducerPath: 'api',\n  baseQuery: fetchBaseQuery({ baseUrl: '/api' }),\n  tagTypes: ['Post', 'User', 'Comment'],\n  endpoints: () => ({})\n});\n\n// api/postsApi.js\nimport { baseApi } from './baseApi';\n\nexport const postsApi = baseApi.injectEndpoints({\n  endpoints: (builder) => ({\n    getPosts: builder.query({\n      query: () => '/posts'\n    })\n  }),\n  overrideExisting: false\n});\n\n// api/usersApi.js\nimport { baseApi } from './baseApi';\n\nexport const usersApi = baseApi.injectEndpoints({\n  endpoints: (builder) => ({\n    getUsers: builder.query({\n      query: () => '/users'\n    })\n  })\n});\n\n// Dependent queries\nfunction UserPosts({ userId }) {\n  const { data: user } = useGetUserQuery(userId);\n  const { data: posts } = useGetPostsQuery(\n    { authorId: user?.id },\n    { skip: !user } // Skip until user is loaded\n  );\n\n  return <PostsList posts={posts} />;\n}\n\n// Parallel queries with useQueries\nfunction MultiUserPosts({ userIds }) {\n  const results = userIds.map(id => useGetUserPostsQuery(id));\n  \n  const isLoading = results.some(r => r.isLoading);\n  const allPosts = results.flatMap(r => r.data ?? []);\n\n  if (isLoading) return <Loading />;\n  return <PostsList posts={allPosts} />;\n}"
    }
  ]
},
{
  "id": "section-17",
  "title": "Redux Best Practices",
  "blocks": [
    {
      "type": "title",
      "level": 1,
      "content": "Redux Style Guide"
    },
    {
      "type": "description",
      "content": "The Redux team maintains an official Style Guide with recommended patterns and best practices. Following these guidelines ensures consistent, maintainable Redux code."
    },
    {
      "type": "code",
      "language": "text",
      "title": "Redux Style Guide Summary",
      "code": "┌─────────────────────────────────────────────────────────────────┐\n│                  REDUX STYLE GUIDE                              │\n├─────────────────────────────────────────────────────────────────┤\n│                                                                 │\n│  ESSENTIAL (Must Follow):                                       │\n│  ✅ Do Not Mutate State                                        │\n│  ✅ Reducers Must Not Have Side Effects                        │\n│  ✅ Do Not Put Non-Serializable Values in State                │\n│  ✅ Only One Redux Store Per App                               │\n│                                                                 │\n│  STRONGLY RECOMMENDED:                                          │\n│  ✅ Use Redux Toolkit                                          │\n│  ✅ Use Immer for Immutable Updates                            │\n│  ✅ Structure Files as Feature Folders                         │\n│  ✅ Put as Much Logic as Possible in Reducers                  │\n│  ✅ Use Selectors Everywhere                                   │\n│  ✅ Name State Slices Based on Stored Data                     │\n│                                                                 │\n│  RECOMMENDED:                                                   │\n│  ✅ Write Action Types as domain/eventName                     │\n│  ✅ Model Actions as Events, Not Setters                       │\n│  ✅ Use Meaningful Action Names                                │\n│  ✅ Normalize Complex Nested/Relational State                  │\n│  ✅ Keep State Minimal and Derive Additional Values            │\n│  ✅ Treat Reducers as State Machines                           │\n│                                                                 │\n│  DON'T:                                                         │\n│  ❌ Don't put form state in Redux                              │\n│  ❌ Don't store derived data in state                          │\n│  ❌ Don't put every piece of state in Redux                    │\n│  ❌ Don't connect every component                              │\n│                                                                 │\n└─────────────────────────────────────────────────────────────────┘"
    },
    {
      "type": "title",
      "level": 2,
      "content": "Project Structure"
    },
    {
      "type": "code",
      "language": "text",
      "title": "Recommended Project Structure",
      "code": "FEATURE-BASED STRUCTURE (Recommended):\n\nsrc/\n├── app/\n│   ├── store.js              # Store configuration\n│   └── hooks.js              # Typed hooks (useAppDispatch, useAppSelector)\n│\n├── features/\n│   ├── auth/\n│   │   ├── authSlice.js      # Slice with reducers & actions\n│   │   ├── authAPI.js        # API functions\n│   │   ├── authSelectors.js  # Selectors (optional, can be in slice)\n│   │   ├── LoginForm.jsx     # Feature components\n│   │   ├── AuthProvider.jsx\n│   │   └── index.js          # Public exports\n│   │\n│   ├── posts/\n│   │   ├── postsSlice.js\n│   │   ├── postsAPI.js\n│   │   ├── PostsList.jsx\n│   │   ├── PostItem.jsx\n│   │   ├── AddPostForm.jsx\n│   │   └── index.js\n│   │\n│   └── users/\n│       ├── usersSlice.js\n│       ├── UserProfile.jsx\n│       └── index.js\n│\n├── api/\n│   └── apiSlice.js           # RTK Query API definition\n│\n├── components/               # Shared/common components\n│   ├── Button.jsx\n│   ├── Modal.jsx\n│   └── Loading.jsx\n│\n├── utils/\n│   └── helpers.js\n│\n└── App.jsx\n\n\nDUCKS PATTERN (Alternative):\n\nsrc/\n├── store/\n│   ├── index.js              # Store configuration\n│   ├── rootReducer.js        # Combine reducers\n│   │\n│   └── ducks/\n│       ├── auth.js           # Actions, reducer, selectors together\n│       ├── posts.js\n│       └── users.js\n│\n└── components/"
    },
    {
      "type": "title",
      "level": 2,
      "content": "State Design Principles"
    },
    {
      "type": "code",
      "language": "javascript",
      "title": "State Design Best Practices",
      "code": "// ❌ BAD: Nested, denormalized state\nconst badState = {\n  posts: [\n    {\n      id: 1,\n      title: 'Post 1',\n      author: { id: 1, name: 'John', email: 'john@example.com' },\n      comments: [\n        {\n          id: 1,\n          text: 'Great!',\n          author: { id: 2, name: 'Jane', email: 'jane@example.com' }\n        }\n      ]\n    }\n  ]\n};\n\n// ✅ GOOD: Normalized state\nconst goodState = {\n  posts: {\n    ids: [1, 2, 3],\n    entities: {\n      1: { id: 1, title: 'Post 1', authorId: 1, commentIds: [1, 2] },\n      2: { id: 2, title: 'Post 2', authorId: 2, commentIds: [3] }\n    }\n  },\n  users: {\n    ids: [1, 2],\n    entities: {\n      1: { id: 1, name: 'John', email: 'john@example.com' },\n      2: { id: 2, name: 'Jane', email: 'jane@example.com' }\n    }\n  },\n  comments: {\n    ids: [1, 2, 3],\n    entities: {\n      1: { id: 1, text: 'Great!', postId: 1, authorId: 2 },\n      2: { id: 2, text: 'Thanks!', postId: 1, authorId: 1 },\n      3: { id: 3, text: 'Nice!', postId: 2, authorId: 1 }\n    }\n  },\n  // UI state separate from data\n  ui: {\n    selectedPostId: 1,\n    isModalOpen: false\n  }\n};\n\n// ❌ BAD: Storing derived data\nconst badDerivedState = {\n  todos: [...],\n  completedTodos: [...], // Derived! Don't store\n  activeTodos: [...],    // Derived! Don't store\n  todoCount: 5           // Derived! Don't store\n};\n\n// ✅ GOOD: Derive with selectors\nconst goodState = {\n  todos: {\n    items: [...],\n    filter: 'all'\n  }\n};\n\n// Derive in selectors\nconst selectCompletedTodos = createSelector(\n  [selectTodos],\n  (todos) => todos.filter(t => t.completed)\n);\n\n// ❌ BAD: Everything in Redux\nconst overKillState = {\n  inputValue: '',           // Form state - use local state\n  isDropdownOpen: false,    // UI state - use local state\n  currentTime: Date.now(),  // Changes constantly - don't store\n  // ... plus actual app state\n};\n\n// ✅ GOOD: Only global app state in Redux\nconst appropriateState = {\n  auth: { user, token },\n  posts: { items, loading },\n  notifications: []\n};\n// Keep form state, local UI state in component state\n\n// ✅ State machine approach for loading states\nconst stateWithStatus = {\n  users: {\n    data: [],\n    status: 'idle', // 'idle' | 'loading' | 'succeeded' | 'failed'\n    error: null\n  }\n};\n\n// Better than multiple booleans\n// ❌ isLoading: true, isError: false, isSuccess: false"
    },
    {
      "type": "title",
      "level": 2,
      "content": "Action Design Principles"
    },
    {
      "type": "code",
      "language": "javascript",
      "title": "Action Naming & Design",
      "code": "// ❌ BAD: Setter-style actions\nconst setUser = createAction('SET_USER');\nconst setLoading = createAction('SET_LOADING');\nconst setError = createAction('SET_ERROR');\n\n// ✅ GOOD: Event-style actions\nconst userLoggedIn = createAction('auth/userLoggedIn');\nconst loginFailed = createAction('auth/loginFailed');\nconst postsReceived = createAction('posts/postsReceived');\nconst postCreated = createAction('posts/postCreated');\nconst postUpdated = createAction('posts/postUpdated');\nconst postDeleted = createAction('posts/postDeleted');\n\n// ❌ BAD: Vague action names\nconst update = createAction('UPDATE');\nconst set = createAction('SET');\n\n// ✅ GOOD: Descriptive action names\nconst userProfileUpdated = createAction('users/profileUpdated');\nconst filterChanged = createAction('todos/filterChanged');\n\n// ✅ Action type format: domain/eventName\nconst actionExamples = {\n  'auth/loginRequested': {},\n  'auth/loginSucceeded': {},\n  'auth/loginFailed': {},\n  'auth/logoutRequested': {},\n  'posts/fetchStarted': {},\n  'posts/fetchSucceeded': {},\n  'posts/fetchFailed': {},\n  'todos/added': {},\n  'todos/toggled': {},\n  'todos/removed': {},\n  'ui/modalOpened': {},\n  'ui/themeChanged': {}\n};\n\n// ✅ One action, multiple reducers\n// Single action can update multiple slices\nconst userLoggedOut = createAction('auth/userLoggedOut');\n\n// authSlice\nextraReducers: (builder) => {\n  builder.addCase(userLoggedOut, (state) => {\n    state.user = null;\n    state.token = null;\n  });\n};\n\n// cartSlice\nextraReducers: (builder) => {\n  builder.addCase(userLoggedOut, (state) => {\n    state.items = [];\n  });\n};\n\n// notificationsSlice\nextraReducers: (builder) => {\n  builder.addCase(userLoggedOut, (state) => {\n    state.items = [];\n  });\n};"
    },
    {
      "type": "title",
      "level": 2,
      "content": "What Goes in Redux?"
    },
    {
      "type": "code",
      "language": "text",
      "title": "Deciding What State to Put in Redux",
      "code": "┌─────────────────────────────────────────────────────────────────┐\n│            SHOULD THIS STATE BE IN REDUX?                       │\n├─────────────────────────────────────────────────────────────────┤\n│                                                                 │\n│  ASK THESE QUESTIONS:                                           │\n│                                                                 │\n│  1. Do other parts of the app care about this data?            │\n│     YES → Redux | NO → Local State                              │\n│                                                                 │\n│  2. Do you need to derive other data from it?                  │\n│     YES → Redux | NO → Maybe Local                              │\n│                                                                 │\n│  3. Is the same data used by multiple components?              │\n│     YES → Redux | NO → Local State                              │\n│                                                                 │\n│  4. Do you need to restore state to a given point?             │\n│     YES → Redux | NO → Depends                                  │\n│                                                                 │\n│  5. Do you want to cache data to avoid re-fetching?            │\n│     YES → Redux (RTK Query) | NO → Local                        │\n│                                                                 │\n│  6. Do you need to persist the state?                          │\n│     YES → Redux + Persistence | NO → Local                      │\n│                                                                 │\n│  ALWAYS IN REDUX:                                               │\n│  ✅ User authentication state                                  │\n│  ✅ Globally shared data (users, posts, etc.)                  │\n│  ✅ App-wide settings (theme, language)                        │\n│  ✅ Notification/toast state                                   │\n│                                                                 │\n│  USUALLY LOCAL STATE:                                           │\n│  ✅ Form input values (before submission)                      │\n│  ✅ UI state (dropdowns, modals for single component)          │\n│  ✅ Current scroll position                                    │\n│  ✅ Hover/focus state                                          │\n│                                                                 │\n│  CONTEXT API (Alternative):                                     │\n│  ✅ Theme (if not persisted)                                   │\n│  ✅ Locale/language                                            │\n│  ✅ Current user (if no complex auth)                          │\n│                                                                 │\n└─────────────────────────────────────────────────────────────────┘"
    },
    {
      "type": "interview-tip",
      "tip": "Redux Anti-Patterns to Avoid",
      "explanation": "1. Mutating state directly (always use Immer or spread)\n2. Side effects in reducers (use middleware)\n3. Non-serializable values in state (no functions, class instances)\n4. Connecting every component (use container components)\n5. Storing all state in Redux (use local state too)\n6. Not using selectors (coupling components to state shape)\n7. Not normalizing nested data\n8. Using index as key with entities\n9. Dispatching in reducers\n10. Ignoring Redux DevTools"
    }
  ]
},
{
  "id": "section-18",
  "title": "Redux Advanced Patterns",
  "blocks": [
    {
      "type": "title",
      "level": 1,
      "content": "Advanced Redux Patterns"
    },
    {
      "type": "description",
      "content": "Advanced Redux patterns help manage complex state logic, improve code organization, and handle sophisticated use cases like normalization, undo/redo, and optimistic updates. These patterns are commonly asked in senior-level interviews."
    },
    {
      "type": "title",
      "level": 2,
      "content": "Normalizing State Shape"
    },
    {
      "type": "description",
      "content": "Normalization is the process of structuring data like a database - with entities stored in objects keyed by ID and arrays containing only IDs. This prevents data duplication, simplifies updates, and improves performance."
    },
    {
      "type": "code",
      "language": "javascript",
      "title": "Normalized State Structure",
      "code": "// ❌ DENORMALIZED (Nested) - Hard to update, data duplication\nconst denormalizedState = {\n  posts: [\n    {\n      id: 1,\n      title: 'First Post',\n      author: { id: 1, name: 'John', email: 'john@example.com' },\n      comments: [\n        {\n          id: 1,\n          text: 'Great post!',\n          author: { id: 2, name: 'Jane', email: 'jane@example.com' }\n        },\n        {\n          id: 2,\n          text: 'Thanks!',\n          author: { id: 1, name: 'John', email: 'john@example.com' } // Duplicated!\n        }\n      ]\n    }\n  ]\n};\n\n// ✅ NORMALIZED - Flat structure, no duplication\nconst normalizedState = {\n  entities: {\n    users: {\n      byId: {\n        1: { id: 1, name: 'John', email: 'john@example.com' },\n        2: { id: 2, name: 'Jane', email: 'jane@example.com' }\n      },\n      allIds: [1, 2]\n    },\n    posts: {\n      byId: {\n        1: {\n          id: 1,\n          title: 'First Post',\n          authorId: 1,           // Reference by ID\n          commentIds: [1, 2]     // Array of IDs\n        }\n      },\n      allIds: [1]\n    },\n    comments: {\n      byId: {\n        1: { id: 1, text: 'Great post!', authorId: 2, postId: 1 },\n        2: { id: 2, text: 'Thanks!', authorId: 1, postId: 1 }\n      },\n      allIds: [1, 2]\n    }\n  }\n};"
    },
    {
      "type": "code",
      "language": "javascript",
      "title": "Normalization with createEntityAdapter",
      "code": "import { createSlice, createEntityAdapter, createAsyncThunk } from '@reduxjs/toolkit';\n\n// Create entity adapter for users\nconst usersAdapter = createEntityAdapter({\n  // Custom ID selector (default is entity.id)\n  selectId: (user) => user.id,\n  // Sort comparator\n  sortComparer: (a, b) => a.name.localeCompare(b.name)\n});\n\n// Get initial state from adapter\nconst initialState = usersAdapter.getInitialState({\n  // Additional state properties\n  loading: 'idle',\n  error: null,\n  selectedUserId: null\n});\n\n// Async thunk for fetching users\nconst fetchUsers = createAsyncThunk('users/fetchAll', async () => {\n  const response = await fetch('/api/users');\n  return response.json();\n});\n\nconst usersSlice = createSlice({\n  name: 'users',\n  initialState,\n  reducers: {\n    // Adapter provides CRUD operations\n    userAdded: usersAdapter.addOne,\n    usersAdded: usersAdapter.addMany,\n    userUpdated: usersAdapter.updateOne,\n    userRemoved: usersAdapter.removeOne,\n    usersRemoved: usersAdapter.removeMany,\n    userUpserted: usersAdapter.upsertOne,\n    usersUpserted: usersAdapter.upsertMany,\n    allUsersRemoved: usersAdapter.removeAll,\n    usersReceived: usersAdapter.setAll,\n    \n    // Custom reducer using adapter\n    userDeactivated(state, action) {\n      usersAdapter.updateOne(state, {\n        id: action.payload,\n        changes: { active: false }\n      });\n    },\n    \n    userSelected(state, action) {\n      state.selectedUserId = action.payload;\n    }\n  },\n  extraReducers: (builder) => {\n    builder\n      .addCase(fetchUsers.pending, (state) => {\n        state.loading = 'pending';\n      })\n      .addCase(fetchUsers.fulfilled, (state, action) => {\n        state.loading = 'succeeded';\n        usersAdapter.setAll(state, action.payload);\n      })\n      .addCase(fetchUsers.rejected, (state, action) => {\n        state.loading = 'failed';\n        state.error = action.error.message;\n      });\n  }\n});\n\n// Export selectors\nexport const {\n  selectAll: selectAllUsers,\n  selectById: selectUserById,\n  selectIds: selectUserIds,\n  selectEntities: selectUserEntities,\n  selectTotal: selectTotalUsers\n} = usersAdapter.getSelectors((state) => state.users);\n\n// Custom selectors\nexport const selectActiveUsers = (state) => \n  selectAllUsers(state).filter(user => user.active);\n\nexport const selectSelectedUser = (state) =>\n  state.users.selectedUserId \n    ? selectUserById(state, state.users.selectedUserId) \n    : null;\n\nexport const { \n  userAdded, \n  userUpdated, \n  userRemoved,\n  userSelected \n} = usersSlice.actions;\n\nexport default usersSlice.reducer;"
    },
    {
      "type": "code",
      "language": "javascript",
      "title": "Manual Normalization with normalizr",
      "code": "import { normalize, schema } from 'normalizr';\n\n// Define schemas\nconst userSchema = new schema.Entity('users');\nconst commentSchema = new schema.Entity('comments', {\n  author: userSchema\n});\nconst postSchema = new schema.Entity('posts', {\n  author: userSchema,\n  comments: [commentSchema]\n});\n\n// API response (denormalized)\nconst apiResponse = {\n  id: 1,\n  title: 'My Post',\n  author: { id: 1, name: 'John' },\n  comments: [\n    {\n      id: 1,\n      text: 'Great!',\n      author: { id: 2, name: 'Jane' }\n    }\n  ]\n};\n\n// Normalize the data\nconst normalizedData = normalize(apiResponse, postSchema);\n\nconsole.log(normalizedData);\n// {\n//   result: 1,\n//   entities: {\n//     users: {\n//       1: { id: 1, name: 'John' },\n//       2: { id: 2, name: 'Jane' }\n//     },\n//     comments: {\n//       1: { id: 1, text: 'Great!', author: 2 }\n//     },\n//     posts: {\n//       1: { id: 1, title: 'My Post', author: 1, comments: [1] }\n//     }\n//   }\n// }\n\n// In reducer\nconst initialState = {\n  users: {},\n  posts: {},\n  comments: {},\n  postIds: []\n};\n\nfunction entitiesReducer(state = initialState, action) {\n  switch (action.type) {\n    case 'POSTS_RECEIVED': {\n      const normalized = normalize(action.payload, [postSchema]);\n      return {\n        ...state,\n        users: { ...state.users, ...normalized.entities.users },\n        posts: { ...state.posts, ...normalized.entities.posts },\n        comments: { ...state.comments, ...normalized.entities.comments },\n        postIds: [...new Set([...state.postIds, ...normalized.result])]\n      };\n    }\n    default:\n      return state;\n  }\n}"
    },
    {
      "type": "interview-tip",
      "tip": "Normalization Benefits",
      "explanation": "1. No data duplication - single source of truth\n2. Faster lookups - O(1) by ID vs O(n) array search\n3. Simpler updates - update one place, reflected everywhere\n4. Better performance - smaller state slices update\n5. Easier relationships - just store IDs\n6. Works well with backend - matches database structure"
    },
    {
      "type": "title",
      "level": 2,
      "content": "Optimistic Updates"
    },
    {
      "type": "description",
      "content": "Optimistic updates immediately reflect changes in the UI before the server confirms them. If the server request fails, the changes are rolled back. This creates a faster, more responsive user experience."
    },
    {
      "type": "code",
      "language": "javascript",
      "title": "Optimistic Updates Pattern",
      "code": "import { createSlice, createAsyncThunk, nanoid } from '@reduxjs/toolkit';\n\n// Create async thunk with optimistic update\nconst addTodo = createAsyncThunk(\n  'todos/add',\n  async (text, { rejectWithValue }) => {\n    try {\n      const response = await fetch('/api/todos', {\n        method: 'POST',\n        body: JSON.stringify({ text }),\n        headers: { 'Content-Type': 'application/json' }\n      });\n      \n      if (!response.ok) {\n        throw new Error('Failed to add todo');\n      }\n      \n      return response.json();\n    } catch (error) {\n      return rejectWithValue(error.message);\n    }\n  }\n);\n\nconst deleteTodo = createAsyncThunk(\n  'todos/delete',\n  async (id, { getState, rejectWithValue }) => {\n    // Store the todo for potential rollback\n    const todo = getState().todos.entities[id];\n    \n    try {\n      const response = await fetch(`/api/todos/${id}`, {\n        method: 'DELETE'\n      });\n      \n      if (!response.ok) {\n        throw new Error('Failed to delete');\n      }\n      \n      return { id, previousTodo: todo };\n    } catch (error) {\n      return rejectWithValue({ id, error: error.message, previousTodo: todo });\n    }\n  }\n);\n\nconst updateTodo = createAsyncThunk(\n  'todos/update',\n  async ({ id, changes }, { getState, rejectWithValue }) => {\n    const previousTodo = getState().todos.entities[id];\n    \n    try {\n      const response = await fetch(`/api/todos/${id}`, {\n        method: 'PATCH',\n        body: JSON.stringify(changes),\n        headers: { 'Content-Type': 'application/json' }\n      });\n      \n      if (!response.ok) {\n        throw new Error('Failed to update');\n      }\n      \n      return response.json();\n    } catch (error) {\n      return rejectWithValue({ id, previousTodo, error: error.message });\n    }\n  }\n);\n\nconst todosSlice = createSlice({\n  name: 'todos',\n  initialState: {\n    entities: {},\n    ids: [],\n    pendingActions: {} // Track pending optimistic updates\n  },\n  reducers: {},\n  extraReducers: (builder) => {\n    builder\n      // ADD TODO - Optimistic\n      .addCase(addTodo.pending, (state, action) => {\n        // Generate temporary ID\n        const tempId = `temp_${nanoid()}`;\n        const newTodo = {\n          id: tempId,\n          text: action.meta.arg,\n          completed: false,\n          pending: true\n        };\n        \n        state.entities[tempId] = newTodo;\n        state.ids.push(tempId);\n        state.pendingActions[action.meta.requestId] = tempId;\n      })\n      .addCase(addTodo.fulfilled, (state, action) => {\n        // Replace temp todo with real one\n        const tempId = state.pendingActions[action.meta.requestId];\n        const realTodo = action.payload;\n        \n        // Remove temp\n        delete state.entities[tempId];\n        const tempIndex = state.ids.indexOf(tempId);\n        \n        // Add real\n        state.entities[realTodo.id] = realTodo;\n        state.ids[tempIndex] = realTodo.id;\n        \n        delete state.pendingActions[action.meta.requestId];\n      })\n      .addCase(addTodo.rejected, (state, action) => {\n        // Rollback - remove temp todo\n        const tempId = state.pendingActions[action.meta.requestId];\n        \n        delete state.entities[tempId];\n        state.ids = state.ids.filter(id => id !== tempId);\n        \n        delete state.pendingActions[action.meta.requestId];\n      })\n      \n      // DELETE TODO - Optimistic\n      .addCase(deleteTodo.pending, (state, action) => {\n        const id = action.meta.arg;\n        // Store for rollback and remove immediately\n        state.pendingActions[action.meta.requestId] = state.entities[id];\n        delete state.entities[id];\n        state.ids = state.ids.filter(todoId => todoId !== id);\n      })\n      .addCase(deleteTodo.fulfilled, (state, action) => {\n        delete state.pendingActions[action.meta.requestId];\n      })\n      .addCase(deleteTodo.rejected, (state, action) => {\n        // Rollback - restore deleted todo\n        const previousTodo = action.payload.previousTodo;\n        state.entities[previousTodo.id] = previousTodo;\n        state.ids.push(previousTodo.id);\n        delete state.pendingActions[action.meta.requestId];\n      })\n      \n      // UPDATE TODO - Optimistic\n      .addCase(updateTodo.pending, (state, action) => {\n        const { id, changes } = action.meta.arg;\n        // Store previous state and apply changes immediately\n        state.pendingActions[action.meta.requestId] = { ...state.entities[id] };\n        state.entities[id] = { ...state.entities[id], ...changes, pending: true };\n      })\n      .addCase(updateTodo.fulfilled, (state, action) => {\n        const todo = action.payload;\n        state.entities[todo.id] = todo;\n        delete state.pendingActions[action.meta.requestId];\n      })\n      .addCase(updateTodo.rejected, (state, action) => {\n        // Rollback to previous state\n        const { id, previousTodo } = action.payload;\n        state.entities[id] = previousTodo;\n        delete state.pendingActions[action.meta.requestId];\n      });\n  }\n});\n\nexport default todosSlice.reducer;"
    },
    {
      "type": "code",
      "language": "javascript",
      "title": "Optimistic Updates with RTK Query",
      "code": "import { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react';\n\nconst todosApi = createApi({\n  reducerPath: 'todosApi',\n  baseQuery: fetchBaseQuery({ baseUrl: '/api' }),\n  tagTypes: ['Todo'],\n  endpoints: (builder) => ({\n    getTodos: builder.query({\n      query: () => '/todos',\n      providesTags: (result) =>\n        result\n          ? [\n              ...result.map(({ id }) => ({ type: 'Todo', id })),\n              { type: 'Todo', id: 'LIST' }\n            ]\n          : [{ type: 'Todo', id: 'LIST' }]\n    }),\n    \n    addTodo: builder.mutation({\n      query: (text) => ({\n        url: '/todos',\n        method: 'POST',\n        body: { text, completed: false }\n      }),\n      // Optimistic update\n      async onQueryStarted(text, { dispatch, queryFulfilled }) {\n        // Generate temp ID\n        const tempId = `temp_${Date.now()}`;\n        \n        // Optimistically update cache\n        const patchResult = dispatch(\n          todosApi.util.updateQueryData('getTodos', undefined, (draft) => {\n            draft.push({\n              id: tempId,\n              text,\n              completed: false,\n              isOptimistic: true\n            });\n          })\n        );\n        \n        try {\n          const { data: newTodo } = await queryFulfilled;\n          // Replace temp with real data\n          dispatch(\n            todosApi.util.updateQueryData('getTodos', undefined, (draft) => {\n              const index = draft.findIndex(t => t.id === tempId);\n              if (index !== -1) {\n                draft[index] = newTodo;\n              }\n            })\n          );\n        } catch {\n          // Rollback on failure\n          patchResult.undo();\n        }\n      }\n    }),\n    \n    updateTodo: builder.mutation({\n      query: ({ id, ...patch }) => ({\n        url: `/todos/${id}`,\n        method: 'PATCH',\n        body: patch\n      }),\n      async onQueryStarted({ id, ...patch }, { dispatch, queryFulfilled }) {\n        // Optimistically update\n        const patchResult = dispatch(\n          todosApi.util.updateQueryData('getTodos', undefined, (draft) => {\n            const todo = draft.find(t => t.id === id);\n            if (todo) {\n              Object.assign(todo, patch);\n            }\n          })\n        );\n        \n        try {\n          await queryFulfilled;\n        } catch {\n          patchResult.undo();\n        }\n      }\n    }),\n    \n    deleteTodo: builder.mutation({\n      query: (id) => ({\n        url: `/todos/${id}`,\n        method: 'DELETE'\n      }),\n      async onQueryStarted(id, { dispatch, queryFulfilled }) {\n        const patchResult = dispatch(\n          todosApi.util.updateQueryData('getTodos', undefined, (draft) => {\n            const index = draft.findIndex(t => t.id === id);\n            if (index !== -1) {\n              draft.splice(index, 1);\n            }\n          })\n        );\n        \n        try {\n          await queryFulfilled;\n        } catch {\n          patchResult.undo();\n        }\n      }\n    })\n  })\n});\n\nexport const {\n  useGetTodosQuery,\n  useAddTodoMutation,\n  useUpdateTodoMutation,\n  useDeleteTodoMutation\n} = todosApi;"
    },
    {
      "type": "title",
      "level": 2,
      "content": "Undo/Redo Pattern"
    },
    {
      "type": "description",
      "content": "Implementing undo/redo functionality in Redux involves maintaining a history of past and future states. This is commonly implemented using a higher-order reducer pattern."
    },
    {
      "type": "code",
      "language": "javascript",
      "title": "Undo/Redo Higher-Order Reducer",
      "code": "// Generic undo/redo wrapper\nfunction undoable(reducer, config = {}) {\n  const {\n    limit = 10,                    // History limit\n    undoType = 'UNDO',\n    redoType = 'REDO',\n    clearHistoryType = 'CLEAR_HISTORY',\n    filter = () => true,           // Filter which actions to track\n    groupBy = null                 // Group actions together\n  } = config;\n  \n  const initialState = {\n    past: [],\n    present: reducer(undefined, { type: '@@INIT' }),\n    future: []\n  };\n  \n  return function undoableReducer(state = initialState, action) {\n    const { past, present, future } = state;\n    \n    switch (action.type) {\n      case undoType: {\n        if (past.length === 0) return state;\n        \n        const previous = past[past.length - 1];\n        const newPast = past.slice(0, -1);\n        \n        return {\n          past: newPast,\n          present: previous,\n          future: [present, ...future]\n        };\n      }\n      \n      case redoType: {\n        if (future.length === 0) return state;\n        \n        const next = future[0];\n        const newFuture = future.slice(1);\n        \n        return {\n          past: [...past, present],\n          present: next,\n          future: newFuture\n        };\n      }\n      \n      case clearHistoryType: {\n        return {\n          past: [],\n          present,\n          future: []\n        };\n      }\n      \n      default: {\n        const newPresent = reducer(present, action);\n        \n        // If state didn't change, don't update history\n        if (newPresent === present) {\n          return state;\n        }\n        \n        // Check if this action should be tracked\n        if (!filter(action, newPresent, present)) {\n          return {\n            ...state,\n            present: newPresent\n          };\n        }\n        \n        // Add to history with limit\n        const newPast = [...past, present].slice(-limit);\n        \n        return {\n          past: newPast,\n          present: newPresent,\n          future: [] // Clear future on new action\n        };\n      }\n    }\n  };\n}\n\n// Usage\nconst counterReducer = (state = 0, action) => {\n  switch (action.type) {\n    case 'INCREMENT':\n      return state + 1;\n    case 'DECREMENT':\n      return state - 1;\n    case 'SET':\n      return action.payload;\n    default:\n      return state;\n  }\n};\n\nconst undoableCounter = undoable(counterReducer, {\n  limit: 20,\n  filter: (action) => action.type !== 'SOME_IGNORED_ACTION'\n});\n\n// Action creators\nconst undo = () => ({ type: 'UNDO' });\nconst redo = () => ({ type: 'REDO' });\nconst clearHistory = () => ({ type: 'CLEAR_HISTORY' });\n\n// Selectors\nconst selectPresent = (state) => state.counter.present;\nconst selectCanUndo = (state) => state.counter.past.length > 0;\nconst selectCanRedo = (state) => state.counter.future.length > 0;\nconst selectPastLength = (state) => state.counter.past.length;\nconst selectFutureLength = (state) => state.counter.future.length;"
    },
    {
      "type": "code",
      "language": "javascript",
      "title": "Undo/Redo with Redux Toolkit",
      "code": "import { createSlice, current } from '@reduxjs/toolkit';\n\nconst createUndoableSlice = (config) => {\n  const { name, initialState, reducers, limit = 10 } = config;\n  \n  return createSlice({\n    name,\n    initialState: {\n      past: [],\n      present: initialState,\n      future: []\n    },\n    reducers: {\n      undo: (state) => {\n        if (state.past.length === 0) return;\n        \n        const previous = state.past[state.past.length - 1];\n        state.future.unshift(current(state.present));\n        state.past.pop();\n        state.present = previous;\n      },\n      \n      redo: (state) => {\n        if (state.future.length === 0) return;\n        \n        const next = state.future[0];\n        state.past.push(current(state.present));\n        state.future.shift();\n        state.present = next;\n      },\n      \n      clearHistory: (state) => {\n        state.past = [];\n        state.future = [];\n      },\n      \n      // Wrap each reducer to track history\n      ...Object.fromEntries(\n        Object.entries(reducers).map(([key, reducer]) => [\n          key,\n          (state, action) => {\n            // Save current state to past\n            state.past.push(current(state.present));\n            \n            // Limit history\n            if (state.past.length > limit) {\n              state.past.shift();\n            }\n            \n            // Clear future\n            state.future = [];\n            \n            // Apply reducer to present\n            reducer(state.present, action);\n          }\n        ])\n      )\n    }\n  });\n};\n\n// Usage\nconst todosSlice = createUndoableSlice({\n  name: 'todos',\n  initialState: [],\n  limit: 20,\n  reducers: {\n    addTodo: (state, action) => {\n      state.push({\n        id: Date.now(),\n        text: action.payload,\n        completed: false\n      });\n    },\n    toggleTodo: (state, action) => {\n      const todo = state.find(t => t.id === action.payload);\n      if (todo) {\n        todo.completed = !todo.completed;\n      }\n    },\n    removeTodo: (state, action) => {\n      const index = state.findIndex(t => t.id === action.payload);\n      if (index !== -1) {\n        state.splice(index, 1);\n      }\n    }\n  }\n});\n\nexport const { undo, redo, clearHistory, addTodo, toggleTodo, removeTodo } = todosSlice.actions;\nexport default todosSlice.reducer;\n\n// Component\nfunction TodoApp() {\n  const dispatch = useDispatch();\n  const todos = useSelector(state => state.todos.present);\n  const canUndo = useSelector(state => state.todos.past.length > 0);\n  const canRedo = useSelector(state => state.todos.future.length > 0);\n  \n  return (\n    <div>\n      <button onClick={() => dispatch(undo())} disabled={!canUndo}>\n        Undo\n      </button>\n      <button onClick={() => dispatch(redo())} disabled={!canRedo}>\n        Redo\n      </button>\n      <TodoList todos={todos} />\n    </div>\n  );\n}"
    },
    {
      "type": "title",
      "level": 2,
      "content": "Saga Patterns"
    },
    {
      "type": "description",
      "content": "Redux Saga uses generator functions to handle complex async flows. Common patterns include takeLatest for search/autocomplete, takeEvery for logging, debounce for user input, and throttle for scroll events."
    },
    {
      "type": "code",
      "language": "javascript",
      "title": "Advanced Saga Patterns",
      "code": "import { \n  call, put, takeLatest, takeEvery, all, fork, \n  take, race, delay, select, cancel, cancelled,\n  debounce, throttle, retry, spawn\n} from 'redux-saga/effects';\n\n// 1. TAKE LATEST - Cancel previous, use latest\n// Good for: search, autocomplete\nfunction* searchSaga() {\n  yield takeLatest('SEARCH_REQUESTED', function* (action) {\n    try {\n      const results = yield call(api.search, action.payload);\n      yield put({ type: 'SEARCH_SUCCESS', payload: results });\n    } catch (error) {\n      yield put({ type: 'SEARCH_FAILURE', error });\n    }\n  });\n}\n\n// 2. DEBOUNCE - Wait for pause in actions\n// Good for: text input, resize events\nfunction* debouncedSearchSaga() {\n  yield debounce(300, 'SEARCH_INPUT_CHANGED', function* (action) {\n    const results = yield call(api.search, action.payload);\n    yield put({ type: 'SEARCH_RESULTS', payload: results });\n  });\n}\n\n// 3. THROTTLE - Max once per time period\n// Good for: scroll events, analytics\nfunction* throttledScrollSaga() {\n  yield throttle(1000, 'SCROLL_EVENT', function* (action) {\n    yield call(analytics.track, 'scroll', action.payload);\n  });\n}\n\n// 4. RETRY - Retry failed requests\nfunction* fetchWithRetrySaga(action) {\n  try {\n    // Retry 3 times with 1 second delay\n    const data = yield retry(3, 1000, api.fetchData, action.payload);\n    yield put({ type: 'FETCH_SUCCESS', payload: data });\n  } catch (error) {\n    yield put({ type: 'FETCH_FAILURE', error });\n  }\n}\n\n// 5. RACE - First to complete wins\nfunction* fetchWithTimeoutSaga(action) {\n  const { response, timeout } = yield race({\n    response: call(api.fetchData, action.payload),\n    timeout: delay(5000)\n  });\n  \n  if (timeout) {\n    yield put({ type: 'FETCH_TIMEOUT' });\n  } else {\n    yield put({ type: 'FETCH_SUCCESS', payload: response });\n  }\n}\n\n// 6. POLLING - Repeated fetching\nfunction* pollingSaga() {\n  while (true) {\n    try {\n      const data = yield call(api.fetchStatus);\n      yield put({ type: 'STATUS_UPDATED', payload: data });\n      yield delay(5000); // Poll every 5 seconds\n    } catch (error) {\n      yield put({ type: 'POLLING_ERROR', error });\n      yield delay(10000); // Wait longer on error\n    }\n  }\n}\n\n// 7. START/STOP POLLING\nfunction* watchPollingSaga() {\n  while (true) {\n    yield take('START_POLLING');\n    const pollTask = yield fork(pollingSaga);\n    \n    yield take('STOP_POLLING');\n    yield cancel(pollTask);\n  }\n}\n\n// 8. CANCELLATION with cleanup\nfunction* uploadFileSaga(action) {\n  const abortController = new AbortController();\n  \n  try {\n    yield put({ type: 'UPLOAD_STARTED' });\n    \n    const result = yield call(\n      api.uploadFile, \n      action.payload, \n      abortController.signal\n    );\n    \n    yield put({ type: 'UPLOAD_SUCCESS', payload: result });\n  } catch (error) {\n    if (error.name !== 'AbortError') {\n      yield put({ type: 'UPLOAD_FAILURE', error });\n    }\n  } finally {\n    if (yield cancelled()) {\n      abortController.abort();\n      yield put({ type: 'UPLOAD_CANCELLED' });\n    }\n  }\n}\n\n// 9. CHANNEL - Complex event handling\nimport { channel, buffers } from 'redux-saga';\n\nfunction* watchRequestsSaga() {\n  const requestChannel = yield call(channel, buffers.expanding());\n  \n  // Worker saga\n  for (let i = 0; i < 3; i++) {\n    yield fork(handleRequestSaga, requestChannel);\n  }\n  \n  // Dispatch requests to channel\n  while (true) {\n    const action = yield take('REQUEST');\n    yield put(requestChannel, action);\n  }\n}\n\nfunction* handleRequestSaga(chan) {\n  while (true) {\n    const action = yield take(chan);\n    yield call(processRequest, action);\n  }\n}\n\n// 10. OPTIMISTIC UPDATE with saga\nfunction* optimisticUpdateSaga(action) {\n  const { id, changes } = action.payload;\n  const previousState = yield select(state => state.items[id]);\n  \n  // Optimistically update\n  yield put({ type: 'UPDATE_ITEM', payload: { id, changes } });\n  \n  try {\n    yield call(api.updateItem, id, changes);\n    yield put({ type: 'UPDATE_CONFIRMED', payload: { id } });\n  } catch (error) {\n    // Rollback on failure\n    yield put({ type: 'ROLLBACK_ITEM', payload: { id, previousState } });\n    yield put({ type: 'UPDATE_FAILED', error });\n  }\n}\n\n// Root saga\nexport default function* rootSaga() {\n  yield all([\n    fork(searchSaga),\n    fork(debouncedSearchSaga),\n    fork(throttledScrollSaga),\n    fork(watchPollingSaga),\n    takeLatest('FETCH_WITH_RETRY', fetchWithRetrySaga),\n    takeLatest('FETCH_WITH_TIMEOUT', fetchWithTimeoutSaga),\n    takeEvery('OPTIMISTIC_UPDATE', optimisticUpdateSaga)\n  ]);\n}"
    },
    {
      "type": "title",
      "level": 2,
      "content": "Redux Observable Patterns"
    },
    {
      "type": "code",
      "language": "javascript",
      "title": "RxJS Epic Patterns",
      "code": "import { ofType } from 'redux-observable';\nimport { \n  map, mergeMap, switchMap, catchError, \n  debounceTime, throttleTime, takeUntil, \n  retry, retryWhen, delay, take,\n  exhaustMap, concatMap\n} from 'rxjs/operators';\nimport { of, from, timer, race } from 'rxjs';\n\n// 1. BASIC ASYNC - switchMap cancels previous\nconst fetchUserEpic = (action$) =>\n  action$.pipe(\n    ofType('FETCH_USER'),\n    switchMap(action =>\n      from(api.fetchUser(action.payload)).pipe(\n        map(user => ({ type: 'FETCH_USER_SUCCESS', payload: user })),\n        catchError(error => of({ type: 'FETCH_USER_FAILURE', error }))\n      )\n    )\n  );\n\n// 2. DEBOUNCED SEARCH\nconst searchEpic = (action$) =>\n  action$.pipe(\n    ofType('SEARCH_INPUT'),\n    debounceTime(300),\n    switchMap(action =>\n      from(api.search(action.payload)).pipe(\n        map(results => ({ type: 'SEARCH_SUCCESS', payload: results })),\n        catchError(error => of({ type: 'SEARCH_FAILURE', error }))\n      )\n    )\n  );\n\n// 3. THROTTLED EVENTS\nconst scrollEpic = (action$) =>\n  action$.pipe(\n    ofType('SCROLL'),\n    throttleTime(1000),\n    map(action => ({ type: 'SCROLL_TRACKED', payload: action.payload }))\n  );\n\n// 4. RETRY WITH BACKOFF\nconst fetchWithRetryEpic = (action$) =>\n  action$.pipe(\n    ofType('FETCH_DATA'),\n    switchMap(action =>\n      from(api.fetchData(action.payload)).pipe(\n        retryWhen(errors =>\n          errors.pipe(\n            delay(1000),\n            take(3)\n          )\n        ),\n        map(data => ({ type: 'FETCH_SUCCESS', payload: data })),\n        catchError(error => of({ type: 'FETCH_FAILURE', error }))\n      )\n    )\n  );\n\n// 5. CANCELLABLE REQUEST\nconst cancellableEpic = (action$) =>\n  action$.pipe(\n    ofType('START_REQUEST'),\n    switchMap(action =>\n      from(api.longRequest(action.payload)).pipe(\n        map(data => ({ type: 'REQUEST_SUCCESS', payload: data })),\n        takeUntil(action$.pipe(ofType('CANCEL_REQUEST'))),\n        catchError(error => of({ type: 'REQUEST_FAILURE', error }))\n      )\n    )\n  );\n\n// 6. POLLING\nconst pollingEpic = (action$) =>\n  action$.pipe(\n    ofType('START_POLLING'),\n    switchMap(() =>\n      timer(0, 5000).pipe(\n        takeUntil(action$.pipe(ofType('STOP_POLLING'))),\n        mergeMap(() =>\n          from(api.getStatus()).pipe(\n            map(status => ({ type: 'STATUS_UPDATED', payload: status })),\n            catchError(error => of({ type: 'POLLING_ERROR', error }))\n          )\n        )\n      )\n    )\n  );\n\n// 7. RACE - TIMEOUT\nconst timeoutEpic = (action$) =>\n  action$.pipe(\n    ofType('FETCH_WITH_TIMEOUT'),\n    switchMap(action =>\n      race(\n        from(api.fetchData(action.payload)).pipe(\n          map(data => ({ type: 'FETCH_SUCCESS', payload: data }))\n        ),\n        timer(5000).pipe(\n          map(() => ({ type: 'FETCH_TIMEOUT' }))\n        )\n      ).pipe(\n        catchError(error => of({ type: 'FETCH_FAILURE', error }))\n      )\n    )\n  );\n\n// 8. SEQUENTIAL REQUESTS - concatMap\nconst sequentialEpic = (action$) =>\n  action$.pipe(\n    ofType('SEQUENTIAL_REQUEST'),\n    concatMap(action =>\n      from(api.processItem(action.payload)).pipe(\n        map(result => ({ type: 'ITEM_PROCESSED', payload: result })),\n        catchError(error => of({ type: 'ITEM_FAILED', error }))\n      )\n    )\n  );\n\n// 9. IGNORE WHILE PROCESSING - exhaustMap\nconst exhaustEpic = (action$) =>\n  action$.pipe(\n    ofType('SUBMIT_FORM'),\n    exhaustMap(action =>\n      from(api.submitForm(action.payload)).pipe(\n        map(result => ({ type: 'SUBMIT_SUCCESS', payload: result })),\n        catchError(error => of({ type: 'SUBMIT_FAILURE', error }))\n      )\n    )\n  );\n\n// Combine epics\nimport { combineEpics } from 'redux-observable';\n\nexport const rootEpic = combineEpics(\n  fetchUserEpic,\n  searchEpic,\n  scrollEpic,\n  fetchWithRetryEpic,\n  cancellableEpic,\n  pollingEpic,\n  timeoutEpic\n);"
    },
    {
      "type": "interview-tip",
      "tip": "Choosing Async Pattern",
      "explanation": "Redux Thunk: Simple async, small apps, quick setup\nRedux Saga: Complex flows, testing, cancellation\nRedux Observable: RxJS knowledge, complex streams\nRTK Query: Data fetching, caching, built-in\n\nMost apps should start with RTK Query for data fetching and thunks for other async logic. Use Saga/Observable only for complex requirements."
    }
  ]
},
{
  "id": "section-19",
  "title": "Redux Best Practices & Anti-patterns",
  "blocks": [
    {
      "type": "title",
      "level": 1,
      "content": "Redux Best Practices"
    },
    {
      "type": "description",
      "content": "Following Redux best practices ensures maintainable, performant, and scalable applications. These patterns are essential knowledge for interviews and real-world development."
    },
    {
      "type": "title",
      "level": 2,
      "content": "State Structure Best Practices"
    },
    {
      "type": "code",
      "language": "javascript",
      "title": "State Structure Guidelines",
      "code": "// ✅ GOOD: Flat, normalized state\nconst goodState = {\n  // Entities - normalized data\n  users: {\n    byId: {\n      'user1': { id: 'user1', name: 'John', role: 'admin' },\n      'user2': { id: 'user2', name: 'Jane', role: 'user' }\n    },\n    allIds: ['user1', 'user2']\n  },\n  \n  // UI state - separate from data\n  ui: {\n    userList: {\n      isLoading: false,\n      error: null,\n      selectedId: 'user1',\n      filters: {\n        role: 'all',\n        search: ''\n      },\n      pagination: {\n        page: 1,\n        perPage: 10,\n        total: 100\n      }\n    },\n    modal: {\n      isOpen: false,\n      type: null\n    }\n  },\n  \n  // Domain/feature slices\n  auth: {\n    isAuthenticated: true,\n    token: 'abc123',\n    currentUserId: 'user1'\n  },\n  \n  // Derived data should NOT be stored\n  // Calculate in selectors instead\n};\n\n// ❌ BAD: Deeply nested, denormalized\nconst badState = {\n  users: [\n    {\n      id: 'user1',\n      name: 'John',\n      isSelected: true,          // ❌ UI state mixed with data\n      isLoading: false,          // ❌ UI state\n      posts: [                   // ❌ Deeply nested\n        {\n          id: 'post1',\n          title: 'Hello',\n          author: { id: 'user1', name: 'John' },  // ❌ Duplicated data\n          comments: [/*...*/]    // ❌ More nesting\n        }\n      ]\n    }\n  ],\n  filteredUsers: [/*...*/],      // ❌ Derived data stored\n  userCount: 2                   // ❌ Derived data stored\n};"
    },
    {
      "type": "code",
      "language": "text",
      "title": "State Design Principles",
      "code": "┌─────────────────────────────────────────────────────────────────┐\n│                 STATE DESIGN PRINCIPLES                         │\n├─────────────────────────────────────────────────────────────────┤\n│                                                                 │\n│  1. SINGLE SOURCE OF TRUTH                                      │\n│     • Each piece of data exists in ONE place                   │\n│     • Avoid duplication across slices                          │\n│     • Reference by ID, not copying                             │\n│                                                                 │\n│  2. NORMALIZE NESTED DATA                                       │\n│     • Flat structure like database tables                      │\n│     • Entities indexed by ID                                   │\n│     • Arrays only for order (IDs only)                         │\n│                                                                 │\n│  3. SEPARATE DATA FROM UI STATE                                 │\n│     • entities: {} - server data                               │\n│     • ui: {} - local UI state                                  │\n│     • Don't mix loading states in entities                     │\n│                                                                 │\n│  4. STORE MINIMAL STATE                                         │\n│     • Only store what you can't derive                         │\n│     • Compute derived data in selectors                        │\n│     • Don't store: filtered lists, counts, sorted data         │\n│                                                                 │\n│  5. ORGANIZE BY FEATURE/DOMAIN                                  │\n│     • Group related state together                             │\n│     • Each feature owns its slice                              │\n│     • Use combineReducers for organization                     │\n│                                                                 │\n└─────────────────────────────────────────────────────────────────┘"
    },
    {
      "type": "title",
      "level": 2,
      "content": "Action Best Practices"
    },
    {
      "type": "code",
      "language": "javascript",
      "title": "Action Design Patterns",
      "code": "// ✅ GOOD: Descriptive action names\nconst goodActions = {\n  // Format: domain/eventName (past tense for events)\n  'users/userLoggedIn': { id: '1', name: 'John' },\n  'users/userLoggedOut': undefined,\n  'posts/postCreated': { id: '1', title: 'Hello' },\n  'posts/postUpdated': { id: '1', changes: { title: 'Updated' } },\n  'posts/postDeleted': { id: '1' },\n  \n  // Request lifecycle\n  'users/fetchUsers/pending': undefined,\n  'users/fetchUsers/fulfilled': { users: [] },\n  'users/fetchUsers/rejected': { error: 'Failed' }\n};\n\n// ❌ BAD: Vague, imperative names\nconst badActions = {\n  'SET_USER': {},           // ❌ Too generic\n  'UPDATE': {},             // ❌ What is being updated?\n  'LOADING': {},            // ❌ Loading what?\n  'user_data': {}           // ❌ Inconsistent naming\n};\n\n// ✅ GOOD: Minimal action payload (event description)\n// Put logic in reducers, not action creators\nfunction addTodo(text) {\n  return {\n    type: 'todos/todoAdded',\n    payload: text  // Just the essential data\n  };\n}\n\n// Reducer handles the logic\nfunction todosReducer(state, action) {\n  switch (action.type) {\n    case 'todos/todoAdded':\n      return [\n        ...state,\n        {\n          id: Date.now(),      // ID generated in reducer\n          text: action.payload,\n          completed: false,    // Default value in reducer\n          createdAt: new Date().toISOString()\n        }\n      ];\n  }\n}\n\n// ❌ BAD: Fat action creator (logic outside reducer)\nfunction addTodoBad(text) {\n  return {\n    type: 'ADD_TODO',\n    payload: {\n      id: Date.now(),           // ❌ Logic in action creator\n      text,\n      completed: false,\n      createdAt: new Date().toISOString(),\n      userId: getCurrentUserId() // ❌ Side effect in action creator\n    }\n  };\n}\n\n// ✅ GOOD: Single action for related updates\n// When one user action affects multiple state parts\ndispatch({\n  type: 'checkout/orderPlaced',\n  payload: { orderId: '123', items: [...] }\n});\n\n// Multiple reducers can respond to this one action\n// cartReducer: clears cart\n// ordersReducer: adds new order\n// inventoryReducer: decrements stock"
    },
    {
      "type": "title",
      "level": 2,
      "content": "Selector Best Practices"
    },
    {
      "type": "code",
      "language": "javascript",
      "title": "Selector Patterns",
      "code": "import { createSelector } from '@reduxjs/toolkit';\n\n// ✅ GOOD: Basic selectors (input selectors)\nconst selectUsers = (state) => state.users.byId;\nconst selectUserIds = (state) => state.users.allIds;\nconst selectCurrentUserId = (state) => state.auth.currentUserId;\nconst selectFilters = (state) => state.ui.userList.filters;\n\n// ✅ GOOD: Memoized derived selectors\nconst selectAllUsers = createSelector(\n  [selectUsers, selectUserIds],\n  (usersById, ids) => ids.map(id => usersById[id])\n);\n\nconst selectCurrentUser = createSelector(\n  [selectUsers, selectCurrentUserId],\n  (usersById, currentId) => usersById[currentId]\n);\n\nconst selectFilteredUsers = createSelector(\n  [selectAllUsers, selectFilters],\n  (users, filters) => {\n    let result = users;\n    \n    if (filters.role !== 'all') {\n      result = result.filter(u => u.role === filters.role);\n    }\n    \n    if (filters.search) {\n      const search = filters.search.toLowerCase();\n      result = result.filter(u => \n        u.name.toLowerCase().includes(search)\n      );\n    }\n    \n    return result;\n  }\n);\n\n// ✅ GOOD: Selector factory for parameterized selectors\nconst makeSelectUserById = () => createSelector(\n  [selectUsers, (_, userId) => userId],\n  (users, userId) => users[userId]\n);\n\n// Usage in component\nfunction UserProfile({ userId }) {\n  const selectUserById = useMemo(makeSelectUserById, []);\n  const user = useSelector(state => selectUserById(state, userId));\n}\n\n// ✅ GOOD: Composing selectors\nconst selectUserStats = createSelector(\n  [selectAllUsers],\n  (users) => ({\n    total: users.length,\n    admins: users.filter(u => u.role === 'admin').length,\n    active: users.filter(u => u.isActive).length\n  })\n);\n\n// ✅ GOOD: Selector for sorted data\nconst selectUsersSorted = createSelector(\n  [selectFilteredUsers, (_, sortBy) => sortBy],\n  (users, sortBy) => {\n    return [...users].sort((a, b) => {\n      if (sortBy === 'name') return a.name.localeCompare(b.name);\n      if (sortBy === 'createdAt') return new Date(b.createdAt) - new Date(a.createdAt);\n      return 0;\n    });\n  }\n);\n\n// ❌ BAD: Non-memoized complex selectors\nconst selectUsersBad = (state) => {\n  // ❌ Creates new array every call\n  return Object.values(state.users.byId)\n    .filter(u => u.isActive)\n    .sort((a, b) => a.name.localeCompare(b.name));\n};\n\n// ❌ BAD: Selector with side effects\nconst selectWithSideEffect = (state) => {\n  console.log('Selector called');  // ❌ Side effect\n  localStorage.setItem('lastUser', state.currentUser);  // ❌ Side effect\n  return state.users;\n};"
    },
    {
      "type": "title",
      "level": 2,
      "content": "Common Anti-patterns"
    },
    {
      "type": "code",
      "language": "javascript",
      "title": "Anti-patterns to Avoid",
      "code": "// ❌ ANTI-PATTERN 1: Mutating state\nfunction badReducer(state, action) {\n  state.users.push(action.payload);  // ❌ Mutation!\n  state.count++;                      // ❌ Mutation!\n  return state;\n}\n\n// ✅ CORRECT\nfunction goodReducer(state, action) {\n  return {\n    ...state,\n    users: [...state.users, action.payload],\n    count: state.count + 1\n  };\n}\n\n// ❌ ANTI-PATTERN 2: Putting non-serializable values in state\nconst badState = {\n  callback: () => {},           // ❌ Functions\n  promise: fetch('/api'),       // ❌ Promises\n  classInstance: new MyClass(), // ❌ Class instances\n  symbol: Symbol('foo'),        // ❌ Symbols\n  map: new Map(),               // ❌ Maps/Sets\n  date: new Date()              // ❌ Date objects\n};\n\n// ✅ CORRECT\nconst goodState = {\n  // Store serializable data only\n  dateString: '2024-01-15T10:30:00Z',  // ISO string\n  data: { key: 'value' },               // Plain objects\n  items: ['a', 'b', 'c']                 // Arrays\n};\n\n// ❌ ANTI-PATTERN 3: Deriving state from other state\nconst badDerivedState = {\n  todos: [{ id: 1, completed: true }, { id: 2, completed: false }],\n  completedCount: 1,           // ❌ Can be derived\n  incompleteTodos: [{ id: 2 }] // ❌ Can be derived\n};\n\n// ✅ CORRECT: Use selectors\nconst selectCompletedCount = createSelector(\n  [selectTodos],\n  (todos) => todos.filter(t => t.completed).length\n);\n\n// ❌ ANTI-PATTERN 4: Connecting every component to Redux\nfunction DeepNestedChild() {\n  // ❌ Every tiny component connected\n  const theme = useSelector(state => state.theme);\n  return <span style={{ color: theme.textColor }}>text</span>;\n}\n\n// ✅ CORRECT: Connect at appropriate levels, pass props down\nfunction ParentContainer() {\n  const theme = useSelector(state => state.theme);\n  return (\n    <Parent theme={theme}>\n      <Child theme={theme} />\n    </Parent>\n  );\n}\n\n// ❌ ANTI-PATTERN 5: Using Redux for all state\nfunction Form() {\n  // ❌ Form input state in Redux\n  const inputValue = useSelector(state => state.form.inputValue);\n  const dispatch = useDispatch();\n  \n  return (\n    <input \n      value={inputValue}\n      onChange={(e) => dispatch(setInputValue(e.target.value))}\n    />\n  );\n}\n\n// ✅ CORRECT: Use local state for ephemeral UI state\nfunction Form() {\n  const [inputValue, setInputValue] = useState('');\n  const dispatch = useDispatch();\n  \n  const handleSubmit = () => {\n    dispatch(submitForm(inputValue));  // Only dispatch on submit\n  };\n  \n  return (\n    <input \n      value={inputValue}\n      onChange={(e) => setInputValue(e.target.value)}\n    />\n  );\n}\n\n// ❌ ANTI-PATTERN 6: Actions with callbacks\ndispatch({\n  type: 'FETCH_USER',\n  onSuccess: (user) => console.log(user),  // ❌ Callback in action\n  onError: (err) => alert(err)             // ❌ Not serializable\n});\n\n// ✅ CORRECT: Handle in component or middleware\nconst fetchUser = createAsyncThunk('user/fetch', async (id) => {\n  return await api.getUser(id);\n});\n\n// Handle states in component\nfunction UserComponent() {\n  const { status, error } = useSelector(state => state.user);\n  \n  useEffect(() => {\n    if (status === 'succeeded') {\n      console.log('User loaded');\n    }\n    if (status === 'failed') {\n      alert(error);\n    }\n  }, [status, error]);\n}"
    },
    {
      "type": "code",
      "language": "text",
      "title": "Anti-patterns Summary",
      "code": "┌─────────────────────────────────────────────────────────────────┐\n│                    REDUX ANTI-PATTERNS                          │\n├─────────────────────────────────────────────────────────────────┤\n│                                                                 │\n│  1. MUTATING STATE                                              │\n│     ❌ state.push(), state.property = value                    │\n│     ✅ Return new state with spread or Immer                   │\n│                                                                 │\n│  2. NON-SERIALIZABLE STATE                                      │\n│     ❌ Functions, Promises, Classes, Symbols, Maps, Dates      │\n│     ✅ Plain objects, arrays, primitives                       │\n│                                                                 │\n│  3. DERIVED STATE IN STORE                                      │\n│     ❌ Storing computed values (counts, filtered lists)        │\n│     ✅ Compute with memoized selectors                         │\n│                                                                 │\n│  4. OVER-CONNECTING COMPONENTS                                  │\n│     ❌ Every component connected to store                      │\n│     ✅ Connect container components, pass props down           │\n│                                                                 │\n│  5. USING REDUX FOR ALL STATE                                   │\n│     ❌ Form inputs, hover states, UI toggles                   │\n│     ✅ Local state for ephemeral UI, Redux for shared state    │\n│                                                                 │\n│  6. CALLBACKS IN ACTIONS                                        │\n│     ❌ onSuccess/onError callbacks in action payload           │\n│     ✅ Handle in components via selectors or useEffect         │\n│                                                                 │\n│  7. FAT ACTION CREATORS                                         │\n│     ❌ Business logic in action creators                       │\n│     ✅ Minimal payloads, logic in reducers                     │\n│                                                                 │\n│  8. ACCESSING STATE IN ACTION CREATORS                          │\n│     ❌ getState() everywhere                                   │\n│     ✅ Pass needed data, use thunks sparingly                  │\n│                                                                 │\n└─────────────────────────────────────────────────────────────────┘"
    },
    {
      "type": "interview-tip",
      "tip": "When to Use Redux",
      "explanation": "USE Redux when:\n• Large amounts of app state needed in many places\n• State is updated frequently\n• Complex update logic\n• Medium/large codebase with many developers\n• Need time-travel debugging\n\nDON'T USE Redux for:\n• Small apps with simple state\n• State used by single component\n• Rapidly changing state (mouse position, animations)\n• Form input values before submission\n• Local UI state (modals, tooltips)"
    }
  ]
},
{
  "id": "section-20",
  "title": "Testing Redux",
  "blocks": [
    {
      "type": "title",
      "level": 1,
      "content": "Testing Redux Applications"
    },
    {
      "type": "description",
      "content": "Testing Redux code is straightforward because reducers are pure functions, selectors are memoized functions, and actions are plain objects. This section covers testing reducers, actions, selectors, async thunks, and connected components."
    },
    {
      "type": "title",
      "level": 2,
      "content": "Testing Reducers"
    },
    {
      "type": "code",
      "language": "javascript",
      "title": "Reducer Tests",
      "code": "import todosReducer, {\n  addTodo,\n  toggleTodo,\n  removeTodo,\n  setFilter\n} from './todosSlice';\n\ndescribe('todosReducer', () => {\n  const initialState = {\n    items: [],\n    filter: 'all',\n    loading: false,\n    error: null\n  };\n\n  // Test initial state\n  it('should return initial state', () => {\n    expect(todosReducer(undefined, { type: 'unknown' })).toEqual(initialState);\n  });\n\n  // Test adding todo\n  it('should handle addTodo', () => {\n    const previousState = { ...initialState };\n    const action = addTodo('Test todo');\n    const nextState = todosReducer(previousState, action);\n\n    expect(nextState.items).toHaveLength(1);\n    expect(nextState.items[0]).toMatchObject({\n      text: 'Test todo',\n      completed: false\n    });\n    expect(nextState.items[0].id).toBeDefined();\n  });\n\n  // Test toggling todo\n  it('should handle toggleTodo', () => {\n    const previousState = {\n      ...initialState,\n      items: [\n        { id: '1', text: 'Test', completed: false }\n      ]\n    };\n    const action = toggleTodo('1');\n    const nextState = todosReducer(previousState, action);\n\n    expect(nextState.items[0].completed).toBe(true);\n  });\n\n  // Test removing todo\n  it('should handle removeTodo', () => {\n    const previousState = {\n      ...initialState,\n      items: [\n        { id: '1', text: 'Test 1', completed: false },\n        { id: '2', text: 'Test 2', completed: false }\n      ]\n    };\n    const action = removeTodo('1');\n    const nextState = todosReducer(previousState, action);\n\n    expect(nextState.items).toHaveLength(1);\n    expect(nextState.items[0].id).toBe('2');\n  });\n\n  // Test filter\n  it('should handle setFilter', () => {\n    const action = setFilter('completed');\n    const nextState = todosReducer(initialState, action);\n\n    expect(nextState.filter).toBe('completed');\n  });\n\n  // Test immutability\n  it('should not mutate previous state', () => {\n    const previousState = {\n      ...initialState,\n      items: [{ id: '1', text: 'Test', completed: false }]\n    };\n    const frozenState = Object.freeze(previousState);\n    \n    // Should not throw\n    expect(() => todosReducer(frozenState, toggleTodo('1'))).not.toThrow();\n  });\n});"
    },
    {
      "type": "title",
      "level": 2,
      "content": "Testing Selectors"
    },
    {
      "type": "code",
      "language": "javascript",
      "title": "Selector Tests",
      "code": "import {\n  selectAllTodos,\n  selectTodoById,\n  selectFilteredTodos,\n  selectTodoStats,\n  selectCompletedTodos\n} from './selectors';\n\ndescribe('Todo Selectors', () => {\n  const mockState = {\n    todos: {\n      items: [\n        { id: '1', text: 'Learn Redux', completed: true },\n        { id: '2', text: 'Build app', completed: false },\n        { id: '3', text: 'Write tests', completed: true }\n      ],\n      filter: 'all'\n    }\n  };\n\n  // Test basic selector\n  describe('selectAllTodos', () => {\n    it('should return all todos', () => {\n      const result = selectAllTodos(mockState);\n      expect(result).toHaveLength(3);\n    });\n  });\n\n  // Test parameterized selector\n  describe('selectTodoById', () => {\n    it('should return todo by id', () => {\n      const result = selectTodoById(mockState, '2');\n      expect(result).toEqual({ id: '2', text: 'Build app', completed: false });\n    });\n\n    it('should return undefined for non-existent id', () => {\n      const result = selectTodoById(mockState, '999');\n      expect(result).toBeUndefined();\n    });\n  });\n\n  // Test filter selector\n  describe('selectFilteredTodos', () => {\n    it('should return all todos when filter is \"all\"', () => {\n      const result = selectFilteredTodos(mockState);\n      expect(result).toHaveLength(3);\n    });\n\n    it('should return completed todos when filter is \"completed\"', () => {\n      const state = {\n        ...mockState,\n        todos: { ...mockState.todos, filter: 'completed' }\n      };\n      const result = selectFilteredTodos(state);\n      expect(result).toHaveLength(2);\n      expect(result.every(t => t.completed)).toBe(true);\n    });\n\n    it('should return active todos when filter is \"active\"', () => {\n      const state = {\n        ...mockState,\n        todos: { ...mockState.todos, filter: 'active' }\n      };\n      const result = selectFilteredTodos(state);\n      expect(result).toHaveLength(1);\n      expect(result[0].completed).toBe(false);\n    });\n  });\n\n  // Test computed selector\n  describe('selectTodoStats', () => {\n    it('should return correct statistics', () => {\n      const result = selectTodoStats(mockState);\n      expect(result).toEqual({\n        total: 3,\n        completed: 2,\n        active: 1,\n        completionRate: 66.67\n      });\n    });\n\n    it('should handle empty todos', () => {\n      const emptyState = {\n        todos: { items: [], filter: 'all' }\n      };\n      const result = selectTodoStats(emptyState);\n      expect(result).toEqual({\n        total: 0,\n        completed: 0,\n        active: 0,\n        completionRate: 0\n      });\n    });\n  });\n\n  // Test memoization\n  describe('selector memoization', () => {\n    it('should return same reference for same input', () => {\n      const result1 = selectFilteredTodos(mockState);\n      const result2 = selectFilteredTodos(mockState);\n      expect(result1).toBe(result2);\n    });\n\n    it('should return new reference when state changes', () => {\n      const result1 = selectFilteredTodos(mockState);\n      \n      const newState = {\n        ...mockState,\n        todos: {\n          ...mockState.todos,\n          items: [...mockState.todos.items, { id: '4', text: 'New', completed: false }]\n        }\n      };\n      const result2 = selectFilteredTodos(newState);\n      \n      expect(result1).not.toBe(result2);\n    });\n  });\n});"
    },
    {
      "type": "title",
      "level": 2,
      "content": "Testing Async Thunks"
    },
    {
      "type": "code",
      "language": "javascript",
      "title": "Async Thunk Tests",
      "code": "import configureMockStore from 'redux-mock-store';\nimport thunk from 'redux-thunk';\nimport {\n  fetchTodos,\n  createTodo,\n  updateTodo,\n  deleteTodo\n} from './todosSlice';\nimport * as api from './api';\n\n// Mock API\njest.mock('./api');\n\nconst mockStore = configureMockStore([thunk]);\n\ndescribe('Todo Thunks', () => {\n  let store;\n\n  beforeEach(() => {\n    store = mockStore({\n      todos: {\n        items: [],\n        loading: false,\n        error: null\n      }\n    });\n    jest.clearAllMocks();\n  });\n\n  describe('fetchTodos', () => {\n    it('should dispatch pending and fulfilled on success', async () => {\n      const mockTodos = [\n        { id: '1', text: 'Test', completed: false }\n      ];\n      api.getTodos.mockResolvedValue(mockTodos);\n\n      await store.dispatch(fetchTodos());\n\n      const actions = store.getActions();\n      expect(actions[0].type).toBe('todos/fetchTodos/pending');\n      expect(actions[1].type).toBe('todos/fetchTodos/fulfilled');\n      expect(actions[1].payload).toEqual(mockTodos);\n    });\n\n    it('should dispatch pending and rejected on failure', async () => {\n      const error = new Error('Network error');\n      api.getTodos.mockRejectedValue(error);\n\n      await store.dispatch(fetchTodos());\n\n      const actions = store.getActions();\n      expect(actions[0].type).toBe('todos/fetchTodos/pending');\n      expect(actions[1].type).toBe('todos/fetchTodos/rejected');\n      expect(actions[1].error.message).toBe('Network error');\n    });\n  });\n\n  describe('createTodo', () => {\n    it('should create todo and return it', async () => {\n      const newTodo = { id: '1', text: 'New todo', completed: false };\n      api.createTodo.mockResolvedValue(newTodo);\n\n      const result = await store.dispatch(createTodo('New todo'));\n\n      expect(result.type).toBe('todos/createTodo/fulfilled');\n      expect(result.payload).toEqual(newTodo);\n      expect(api.createTodo).toHaveBeenCalledWith('New todo');\n    });\n\n    it('should handle validation error', async () => {\n      const error = { message: 'Text is required', status: 400 };\n      api.createTodo.mockRejectedValue(error);\n\n      const result = await store.dispatch(createTodo(''));\n\n      expect(result.type).toBe('todos/createTodo/rejected');\n      expect(result.payload).toEqual(error);\n    });\n  });\n\n  // Testing thunk with getState\n  describe('conditionalFetch', () => {\n    it('should not fetch if already loading', async () => {\n      store = mockStore({\n        todos: { items: [], loading: true, error: null }\n      });\n\n      await store.dispatch(fetchTodos());\n\n      // With condition checking in thunk\n      expect(api.getTodos).not.toHaveBeenCalled();\n    });\n  });\n});\n\n// Alternative: Testing with real store\nimport { configureStore } from '@reduxjs/toolkit';\nimport todosReducer from './todosSlice';\n\ndescribe('Todo Thunks with Real Store', () => {\n  let store;\n\n  beforeEach(() => {\n    store = configureStore({\n      reducer: { todos: todosReducer }\n    });\n    jest.clearAllMocks();\n  });\n\n  it('should update state on fetchTodos success', async () => {\n    const mockTodos = [{ id: '1', text: 'Test', completed: false }];\n    api.getTodos.mockResolvedValue(mockTodos);\n\n    await store.dispatch(fetchTodos());\n\n    const state = store.getState();\n    expect(state.todos.items).toEqual(mockTodos);\n    expect(state.todos.loading).toBe(false);\n    expect(state.todos.error).toBeNull();\n  });\n\n  it('should set error on fetchTodos failure', async () => {\n    api.getTodos.mockRejectedValue(new Error('Failed'));\n\n    await store.dispatch(fetchTodos());\n\n    const state = store.getState();\n    expect(state.todos.items).toEqual([]);\n    expect(state.todos.loading).toBe(false);\n    expect(state.todos.error).toBe('Failed');\n  });\n});"
    },
    {
      "type": "title",
      "level": 2,
      "content": "Testing Connected Components"
    },
    {
      "type": "code",
      "language": "javascript",
      "title": "Connected Component Tests",
      "code": "import React from 'react';\nimport { render, screen, fireEvent, waitFor } from '@testing-library/react';\nimport userEvent from '@testing-library/user-event';\nimport { Provider } from 'react-redux';\nimport { configureStore } from '@reduxjs/toolkit';\nimport TodoList from './TodoList';\nimport todosReducer from './todosSlice';\n\n// Helper to render with Redux\nfunction renderWithRedux(\n  ui,\n  {\n    preloadedState = {},\n    store = configureStore({\n      reducer: { todos: todosReducer },\n      preloadedState\n    }),\n    ...renderOptions\n  } = {}\n) {\n  function Wrapper({ children }) {\n    return <Provider store={store}>{children}</Provider>;\n  }\n  return {\n    store,\n    ...render(ui, { wrapper: Wrapper, ...renderOptions })\n  };\n}\n\ndescribe('TodoList', () => {\n  const initialState = {\n    todos: {\n      items: [\n        { id: '1', text: 'Learn React', completed: false },\n        { id: '2', text: 'Learn Redux', completed: true }\n      ],\n      filter: 'all',\n      loading: false,\n      error: null\n    }\n  };\n\n  it('should render todos from Redux store', () => {\n    renderWithRedux(<TodoList />, { preloadedState: initialState });\n\n    expect(screen.getByText('Learn React')).toBeInTheDocument();\n    expect(screen.getByText('Learn Redux')).toBeInTheDocument();\n  });\n\n  it('should show loading state', () => {\n    const loadingState = {\n      todos: { ...initialState.todos, loading: true }\n    };\n    renderWithRedux(<TodoList />, { preloadedState: loadingState });\n\n    expect(screen.getByText(/loading/i)).toBeInTheDocument();\n  });\n\n  it('should show error message', () => {\n    const errorState = {\n      todos: { ...initialState.todos, error: 'Failed to fetch' }\n    };\n    renderWithRedux(<TodoList />, { preloadedState: errorState });\n\n    expect(screen.getByText(/failed to fetch/i)).toBeInTheDocument();\n  });\n\n  it('should dispatch addTodo when form submitted', async () => {\n    const { store } = renderWithRedux(<TodoList />, { preloadedState: initialState });\n    const user = userEvent.setup();\n\n    const input = screen.getByPlaceholderText(/add todo/i);\n    const button = screen.getByRole('button', { name: /add/i });\n\n    await user.type(input, 'New todo');\n    await user.click(button);\n\n    const state = store.getState();\n    expect(state.todos.items).toHaveLength(3);\n    expect(state.todos.items[2].text).toBe('New todo');\n  });\n\n  it('should dispatch toggleTodo when checkbox clicked', async () => {\n    const { store } = renderWithRedux(<TodoList />, { preloadedState: initialState });\n    const user = userEvent.setup();\n\n    const checkbox = screen.getAllByRole('checkbox')[0];\n    await user.click(checkbox);\n\n    const state = store.getState();\n    expect(state.todos.items[0].completed).toBe(true);\n  });\n\n  it('should dispatch removeTodo when delete clicked', async () => {\n    const { store } = renderWithRedux(<TodoList />, { preloadedState: initialState });\n    const user = userEvent.setup();\n\n    const deleteButtons = screen.getAllByRole('button', { name: /delete/i });\n    await user.click(deleteButtons[0]);\n\n    const state = store.getState();\n    expect(state.todos.items).toHaveLength(1);\n    expect(state.todos.items[0].id).toBe('2');\n  });\n\n  it('should filter todos based on filter state', () => {\n    const filteredState = {\n      todos: { ...initialState.todos, filter: 'completed' }\n    };\n    renderWithRedux(<TodoList />, { preloadedState: filteredState });\n\n    expect(screen.queryByText('Learn React')).not.toBeInTheDocument();\n    expect(screen.getByText('Learn Redux')).toBeInTheDocument();\n  });\n});\n\n// Testing with MSW (Mock Service Worker)\nimport { rest } from 'msw';\nimport { setupServer } from 'msw/node';\n\nconst server = setupServer(\n  rest.get('/api/todos', (req, res, ctx) => {\n    return res(\n      ctx.json([\n        { id: '1', text: 'Server todo', completed: false }\n      ])\n    );\n  })\n);\n\nbeforeAll(() => server.listen());\nafterEach(() => server.resetHandlers());\nafterAll(() => server.close());\n\ndescribe('TodoList with API', () => {\n  it('should fetch and display todos from API', async () => {\n    renderWithRedux(<TodoList />);\n\n    // Wait for loading to finish and data to appear\n    await waitFor(() => {\n      expect(screen.getByText('Server todo')).toBeInTheDocument();\n    });\n  });\n\n  it('should show error when API fails', async () => {\n    server.use(\n      rest.get('/api/todos', (req, res, ctx) => {\n        return res(ctx.status(500), ctx.json({ error: 'Server error' }));\n      })\n    );\n\n    renderWithRedux(<TodoList />);\n\n    await waitFor(() => {\n      expect(screen.getByText(/error/i)).toBeInTheDocument();\n    });\n  });\n});"
    },
    {
      "type": "interview-tip",
      "tip": "Redux Testing Best Practices",
      "explanation": "1. Test reducers as pure functions - input/output\n2. Test selectors in isolation with mock state\n3. Test thunks verify correct actions dispatched\n4. Use mock store for action sequence testing\n5. Use real store for state update testing\n6. Connected components: render with Provider\n7. Use MSW for API mocking in integration tests\n8. Test behavior, not implementation"
    }
  ]
},
{
  "id": "section-21",
  "title": "React + Redux Integration Patterns",
  "blocks": [
    {
      "type": "title",
      "level": 1,
      "content": "React-Redux Integration"
    },
    {
      "type": "description",
      "content": "React-Redux provides bindings to connect React components with Redux store. The hooks API (useSelector, useDispatch) is the modern approach, while connect() HOC is still used in class components and some codebases."
    },
    {
      "type": "title",
      "level": 2,
      "content": "Hooks API (Modern)"
    },
    {
      "type": "code",
      "language": "javascript",
      "title": "useSelector & useDispatch",
      "code": "import { useSelector, useDispatch, shallowEqual } from 'react-redux';\nimport { useCallback, useMemo } from 'react';\n\n// Basic usage\nfunction TodoList() {\n  // useSelector - select state\n  const todos = useSelector(state => state.todos.items);\n  const filter = useSelector(state => state.todos.filter);\n  \n  // useDispatch - get dispatch function\n  const dispatch = useDispatch();\n  \n  const handleToggle = (id) => {\n    dispatch(toggleTodo(id));\n  };\n  \n  return (\n    <ul>\n      {todos.map(todo => (\n        <li key={todo.id} onClick={() => handleToggle(todo.id)}>\n          {todo.text}\n        </li>\n      ))}\n    </ul>\n  );\n}\n\n// Selecting multiple values\nfunction TodoStats() {\n  // Option 1: Multiple useSelector calls (preferred for simple values)\n  const total = useSelector(state => state.todos.items.length);\n  const completed = useSelector(\n    state => state.todos.items.filter(t => t.completed).length\n  );\n  \n  // Option 2: Single useSelector with object (needs shallowEqual)\n  const { items, filter } = useSelector(\n    state => ({\n      items: state.todos.items,\n      filter: state.todos.filter\n    }),\n    shallowEqual  // Important! Prevents unnecessary re-renders\n  );\n  \n  return <div>Completed: {completed} / {total}</div>;\n}\n\n// Using memoized selectors\nimport { selectFilteredTodos, selectTodoStats } from './selectors';\n\nfunction OptimizedTodoList() {\n  // Memoized selector - only recalculates when dependencies change\n  const filteredTodos = useSelector(selectFilteredTodos);\n  const stats = useSelector(selectTodoStats);\n  \n  return (\n    <div>\n      <p>{stats.completed} of {stats.total} completed</p>\n      <ul>\n        {filteredTodos.map(todo => (\n          <TodoItem key={todo.id} todo={todo} />\n        ))}\n      </ul>\n    </div>\n  );\n}\n\n// Selector with component props (parameterized)\nimport { makeSelectTodoById } from './selectors';\n\nfunction TodoItem({ todoId }) {\n  // Create memoized selector instance per component\n  const selectTodoById = useMemo(makeSelectTodoById, []);\n  \n  const todo = useSelector(state => selectTodoById(state, todoId));\n  \n  if (!todo) return null;\n  return <div>{todo.text}</div>;\n}\n\n// Memoizing dispatch callbacks\nfunction TodoActions({ todoId }) {\n  const dispatch = useDispatch();\n  \n  // Memoize callback to prevent child re-renders\n  const handleToggle = useCallback(() => {\n    dispatch(toggleTodo(todoId));\n  }, [dispatch, todoId]);\n  \n  const handleDelete = useCallback(() => {\n    dispatch(deleteTodo(todoId));\n  }, [dispatch, todoId]);\n  \n  return (\n    <div>\n      <button onClick={handleToggle}>Toggle</button>\n      <button onClick={handleDelete}>Delete</button>\n    </div>\n  );\n}\n\n// Custom hooks for reusable Redux logic\nfunction useTodos() {\n  const todos = useSelector(selectAllTodos);\n  const filter = useSelector(state => state.todos.filter);\n  const dispatch = useDispatch();\n  \n  const addTodo = useCallback((text) => {\n    dispatch(todoAdded(text));\n  }, [dispatch]);\n  \n  const toggleTodo = useCallback((id) => {\n    dispatch(todoToggled(id));\n  }, [dispatch]);\n  \n  const setFilter = useCallback((newFilter) => {\n    dispatch(filterChanged(newFilter));\n  }, [dispatch]);\n  \n  return {\n    todos,\n    filter,\n    addTodo,\n    toggleTodo,\n    setFilter\n  };\n}\n\n// Usage\nfunction MyComponent() {\n  const { todos, addTodo, toggleTodo } = useTodos();\n  // ...\n}"
    },
    {
      "type": "title",
      "level": 2,
      "content": "connect() HOC (Legacy)"
    },
    {
      "type": "code",
      "language": "javascript",
      "title": "connect() Pattern",
      "code": "import { connect } from 'react-redux';\nimport { bindActionCreators } from 'redux';\nimport { toggleTodo, deleteTodo, setFilter } from './actions';\nimport { selectFilteredTodos, selectTodoStats } from './selectors';\n\n// Presentational Component\nfunction TodoList({ todos, stats, toggleTodo, deleteTodo, setFilter }) {\n  return (\n    <div>\n      <FilterButtons currentFilter={stats.filter} onFilterChange={setFilter} />\n      <ul>\n        {todos.map(todo => (\n          <li key={todo.id}>\n            <input\n              type=\"checkbox\"\n              checked={todo.completed}\n              onChange={() => toggleTodo(todo.id)}\n            />\n            {todo.text}\n            <button onClick={() => deleteTodo(todo.id)}>Delete</button>\n          </li>\n        ))}\n      </ul>\n    </div>\n  );\n}\n\n// mapStateToProps - Select data from store\nconst mapStateToProps = (state, ownProps) => ({\n  todos: selectFilteredTodos(state),\n  stats: selectTodoStats(state),\n  // Can use ownProps for component-specific selection\n  // selectedTodo: selectTodoById(state, ownProps.selectedId)\n});\n\n// mapDispatchToProps - Object shorthand (preferred)\nconst mapDispatchToProps = {\n  toggleTodo,\n  deleteTodo,\n  setFilter\n};\n\n// Alternative: mapDispatchToProps as function\nconst mapDispatchToPropsFunc = (dispatch) => ({\n  toggleTodo: (id) => dispatch(toggleTodo(id)),\n  deleteTodo: (id) => dispatch(deleteTodo(id)),\n  setFilter: (filter) => dispatch(setFilter(filter))\n});\n\n// Alternative: Using bindActionCreators\nconst mapDispatchWithBind = (dispatch) => ({\n  ...bindActionCreators(\n    { toggleTodo, deleteTodo, setFilter },\n    dispatch\n  )\n});\n\n// Connect component to Redux\nconst ConnectedTodoList = connect(\n  mapStateToProps,\n  mapDispatchToProps\n)(TodoList);\n\nexport default ConnectedTodoList;\n\n// With options\nconst ConnectedWithOptions = connect(\n  mapStateToProps,\n  mapDispatchToProps,\n  null,  // mergeProps\n  {\n    // Options\n    pure: true,           // Default: true - enables optimization\n    areStatesEqual: (next, prev) => next === prev,\n    areOwnPropsEqual: shallowEqual,\n    areStatePropsEqual: shallowEqual,\n    areMergedPropsEqual: shallowEqual,\n    forwardRef: false     // Set true to forward ref\n  }\n)(TodoList);\n\n// HOC for specific use cases\nfunction withTodosData(WrappedComponent) {\n  return connect(\n    state => ({ todos: selectAllTodos(state) }),\n    { addTodo, toggleTodo }\n  )(WrappedComponent);\n}"
    },
    {
      "type": "code",
      "language": "text",
      "title": "Hooks vs connect()",
      "code": "┌────────────────────┬─────────────────────┬─────────────────────┐\n│ Aspect             │ Hooks               │ connect()           │\n├────────────────────┼─────────────────────┼─────────────────────┤\n│ Syntax             │ Functions in comp   │ HOC wrapper         │\n│ Boilerplate        │ Less                │ More                │\n│ Readability        │ Inline, clear       │ Separate mapXToProps│\n│ Type inference     │ Better              │ Manual types        │\n│ Component type     │ Functional only     │ Any component       │\n│ Testing            │ Simpler             │ Can test mappers    │\n│ Performance        │ Manual optimization │ Built-in memo       │\n│ Ref forwarding     │ Natural             │ Needs forwardRef    │\n│ Custom comparison  │ shallowEqual param  │ Options object      │\n└────────────────────┴─────────────────────┴─────────────────────┘\n\nUse Hooks when:\n• New projects\n• Functional components\n• Simpler, more readable code\n\nUse connect() when:\n• Class components\n• Need fine-grained performance control\n• Separating data from presentation\n• Legacy codebase"
    },
    {
      "type": "title",
      "level": 2,
      "content": "Performance Optimization"
    },
    {
      "type": "code",
      "language": "javascript",
      "title": "React-Redux Performance",
      "code": "import { useSelector, shallowEqual } from 'react-redux';\nimport { createSelector } from '@reduxjs/toolkit';\nimport { memo, useMemo, useCallback } from 'react';\n\n// 1. AVOID: New reference on every render\nfunction BadComponent() {\n  // ❌ Creates new array every render = always re-renders\n  const todos = useSelector(state => \n    state.todos.filter(t => t.completed)\n  );\n  \n  // ❌ Creates new object every render\n  const data = useSelector(state => ({\n    todos: state.todos,\n    users: state.users\n  }));\n}\n\n// 2. USE: Memoized selectors\nconst selectCompletedTodos = createSelector(\n  [state => state.todos],\n  (todos) => todos.filter(t => t.completed)\n);\n\nfunction GoodComponent() {\n  // ✅ Memoized selector - same reference if input unchanged\n  const completedTodos = useSelector(selectCompletedTodos);\n}\n\n// 3. USE: shallowEqual for object selection\nfunction GoodMultiSelect() {\n  // ✅ shallowEqual compares object properties\n  const { todos, users } = useSelector(\n    state => ({\n      todos: state.todos,\n      users: state.users\n    }),\n    shallowEqual\n  );\n}\n\n// 4. SPLIT: Multiple small selectors\nfunction SplitSelectors() {\n  // ✅ Each selector is independent\n  const todos = useSelector(state => state.todos);\n  const users = useSelector(state => state.users);\n  const filter = useSelector(state => state.ui.filter);\n}\n\n// 5. MEMOIZE: Child components with React.memo\nconst TodoItem = memo(function TodoItem({ todo, onToggle }) {\n  return (\n    <li onClick={() => onToggle(todo.id)}>\n      {todo.text}\n    </li>\n  );\n});\n\nfunction TodoList() {\n  const todos = useSelector(selectAllTodos);\n  const dispatch = useDispatch();\n  \n  // ✅ Stable callback reference\n  const handleToggle = useCallback((id) => {\n    dispatch(toggleTodo(id));\n  }, [dispatch]);\n  \n  return (\n    <ul>\n      {todos.map(todo => (\n        <TodoItem \n          key={todo.id} \n          todo={todo} \n          onToggle={handleToggle}  // Stable reference\n        />\n      ))}\n    </ul>\n  );\n}\n\n// 6. PARAMETERIZED: Factory selectors for per-item\nconst makeSelectTodoById = () =>\n  createSelector(\n    [state => state.todos, (_, id) => id],\n    (todos, id) => todos.find(t => t.id === id)\n  );\n\nfunction TodoItemById({ id }) {\n  // ✅ Each component has its own memoized selector\n  const selectTodoById = useMemo(makeSelectTodoById, []);\n  const todo = useSelector(state => selectTodoById(state, id));\n  \n  return <div>{todo?.text}</div>;\n}\n\n// 7. NORMALIZE: Lookup by ID instead of find\nfunction OptimalLookup({ id }) {\n  // ✅ O(1) lookup with normalized state\n  const todo = useSelector(state => state.todos.byId[id]);\n  return <div>{todo?.text}</div>;\n}\n\n// 8. AVOID: Selecting entire slice when only need part\nfunction PartialSelect() {\n  // ❌ Re-renders when ANY part of todos changes\n  const todosSlice = useSelector(state => state.todos);\n  const count = todosSlice.items.length;\n  \n  // ✅ Only re-renders when length changes\n  const count = useSelector(state => state.todos.items.length);\n}"
    },
    {
      "type": "title",
      "level": 2,
      "content": "Store Setup Patterns"
    },
    {
      "type": "code",
      "language": "javascript",
      "title": "Store Configuration",
      "code": "import { configureStore, combineReducers } from '@reduxjs/toolkit';\nimport {\n  persistStore,\n  persistReducer,\n  FLUSH,\n  REHYDRATE,\n  PAUSE,\n  PERSIST,\n  PURGE,\n  REGISTER\n} from 'redux-persist';\nimport storage from 'redux-persist/lib/storage';\nimport { setupListeners } from '@reduxjs/toolkit/query';\n\n// Import reducers\nimport authReducer from './features/auth/authSlice';\nimport todosReducer from './features/todos/todosSlice';\nimport uiReducer from './features/ui/uiSlice';\nimport { apiSlice } from './features/api/apiSlice';\n\n// Combine reducers\nconst rootReducer = combineReducers({\n  auth: authReducer,\n  todos: todosReducer,\n  ui: uiReducer,\n  [apiSlice.reducerPath]: apiSlice.reducer\n});\n\n// Persist configuration\nconst persistConfig = {\n  key: 'root',\n  version: 1,\n  storage,\n  whitelist: ['auth', 'todos'], // Only persist these\n  // blacklist: ['ui']          // Or exclude these\n};\n\nconst persistedReducer = persistReducer(persistConfig, rootReducer);\n\n// Configure store\nexport const store = configureStore({\n  reducer: persistedReducer,\n  \n  middleware: (getDefaultMiddleware) =>\n    getDefaultMiddleware({\n      // Customize default middleware\n      thunk: {\n        extraArgument: { api: apiService }  // Inject extra arg\n      },\n      serializableCheck: {\n        // Ignore persist actions\n        ignoredActions: [FLUSH, REHYDRATE, PAUSE, PERSIST, PURGE, REGISTER]\n      },\n      immutableCheck: { warnAfter: 128 }  // Warn for large state\n    }).concat(\n      apiSlice.middleware,\n      loggerMiddleware,\n      errorMiddleware\n    ),\n  \n  devTools: process.env.NODE_ENV !== 'production' && {\n    name: 'MyApp',\n    trace: true,\n    traceLimit: 25\n  },\n  \n  preloadedState: undefined,  // Optional initial state\n  \n  enhancers: (getDefaultEnhancers) =>\n    getDefaultEnhancers().concat(sentryEnhancer)\n});\n\n// Setup listeners for RTK Query\nsetupListeners(store.dispatch);\n\n// Create persistor\nexport const persistor = persistStore(store);\n\n// Types for TypeScript\nexport type RootState = ReturnType<typeof store.getState>;\nexport type AppDispatch = typeof store.dispatch;\n\n// Custom hooks for TypeScript\nimport { TypedUseSelectorHook, useDispatch, useSelector } from 'react-redux';\n\nexport const useAppDispatch = () => useDispatch<AppDispatch>();\nexport const useAppSelector: TypedUseSelectorHook<RootState> = useSelector;\n\n// App entry point\nimport { Provider } from 'react-redux';\nimport { PersistGate } from 'redux-persist/integration/react';\n\nfunction App() {\n  return (\n    <Provider store={store}>\n      <PersistGate loading={<LoadingScreen />} persistor={persistor}>\n        <Router>\n          <AppRoutes />\n        </Router>\n      </PersistGate>\n    </Provider>\n  );\n}"
    },
    {
      "type": "interview-tip",
      "tip": "React-Redux Interview Points",
      "explanation": "1. useSelector subscribes to store - component re-renders on selected state change\n2. useSelector uses strict equality (===) by default\n3. shallowEqual for object comparisons\n4. Memoized selectors prevent unnecessary recalculations\n5. dispatch is stable - doesn't need to be in deps\n6. connect() has built-in memo, hooks components need React.memo\n7. Multiple useSelector calls are fine - each subscribes independently"
    }
  ]
}
]
}