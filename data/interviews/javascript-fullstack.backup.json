{
  "id": "javascript-fullstack",
  "title": "Full Stack JavaScript & Angular Developer",
  "description": "Complete technical skills Q&A reference guide covering JavaScript fundamentals, TypeScript, Angular, Node.js, Web Security, Testing, CI/CD, Databases, and Performance Optimization",
  "difficulty": "beginner-to-advanced",
  "estimatedTime": "20-25 hours",
  "sections": [
    {
      "id": "section-1",
      "title": "JavaScript - Arrays",
      "blocks": [
        {
          "type": "title",
          "level": 2,
          "content": "Q1. What is the difference between slice() and splice() methods?"
        },
        {
          "type": "description",
          "content": "slice() returns a shallow copy of a portion of an array without modifying the original array. It takes start and end parameters. splice() modifies the original array by removing, replacing, or adding elements. It takes start, deleteCount, and items to add as parameters."
        },
        {
          "type": "code",
          "language": "javascript",
          "title": "slice() vs splice() Examples",
          "code": "// slice() - Non-mutating\nconst arr1 = [1, 2, 3, 4, 5];\nconst sliced = arr1.slice(1, 4); // [2, 3, 4]\nconsole.log(arr1); // [1, 2, 3, 4, 5] - original unchanged\n\n// splice() - Mutating\nconst arr2 = [1, 2, 3, 4, 5];\nconst removed = arr2.splice(1, 2); // removes 2 elements starting at index 1\nconsole.log(removed); // [2, 3]\nconsole.log(arr2); // [1, 4, 5] - original modified\n\n// splice() - Adding elements\nconst arr3 = [1, 2, 5];\narr3.splice(2, 0, 3, 4); // insert 3, 4 at index 2\nconsole.log(arr3); // [1, 2, 3, 4, 5]\n\n// splice() - Replacing elements\nconst arr4 = [1, 2, 3, 4, 5];\narr4.splice(2, 1, 99); // replace 1 element at index 2\nconsole.log(arr4); // [1, 2, 99, 4, 5]"
        },
        {
          "type": "interview-tip",
          "tip": "Key Differences",
          "explanation": "1. slice() creates new array, splice() modifies original\n2. slice(start, end) excludes end index\n3. splice(start, deleteCount, ...items) can add/remove/replace\n4. slice() safer for functional programming\n5. splice() useful when mutation is acceptable"
        },
        {
          "type": "title",
          "level": 2,
          "content": "Q2. Explain the difference between map() and forEach()?"
        },
        {
          "type": "description",
          "content": "map() creates and returns a new array with the results of calling a function on every element. forEach() executes a function on each element but returns undefined. Use map() when you need to transform data, forEach() when you just need to iterate."
        },
        {
          "type": "code",
          "language": "javascript",
          "title": "map() vs forEach() Comparison",
          "code": "const numbers = [1, 2, 3, 4, 5];\n\n// map() - Returns new array\nconst doubled = numbers.map(num => num * 2);\nconsole.log(doubled); // [2, 4, 6, 8, 10]\nconsole.log(numbers); // [1, 2, 3, 4, 5] - original unchanged\n\n// forEach() - Returns undefined\nconst result = numbers.forEach(num => num * 2);\nconsole.log(result); // undefined\n\n// forEach() - Use for side effects\nconst output = [];\nnumbers.forEach(num => output.push(num * 2));\nconsole.log(output); // [2, 4, 6, 8, 10]\n\n// Chaining with map()\nconst processed = numbers\n  .map(x => x * 2)    // [2, 4, 6, 8, 10]\n  .filter(x => x > 5) // [6, 8, 10]\n  .map(x => x / 2);   // [3, 4, 5]\n\n// Cannot chain forEach (returns undefined)\n// numbers.forEach(x => x * 2).filter(...); // Error!"
        },
        {
          "type": "interview-tip",
          "tip": "When to Use Each",
          "explanation": "1. map(): Transform data, need new array, functional approach\n2. forEach(): Side effects (logging, DOM updates), don't need return value\n3. map() is chainable, forEach() is not\n4. Both iterate entire array (can't break early)\n5. For breaking early, use for...of or traditional for loop"
        },
        {
          "type": "title",
          "level": 2,
          "content": "Q3. What does the reduce() method do?"
        },
        {
          "type": "description",
          "content": "reduce() executes a reducer function on each array element, resulting in a single output value. It takes an accumulator and current value as parameters. Common uses include summing numbers, flattening arrays, and grouping objects."
        },
        {
          "type": "code",
          "language": "javascript",
          "title": "reduce() Examples",
          "code": "// 1. Sum numbers\nconst numbers = [1, 2, 3, 4, 5];\nconst sum = numbers.reduce((acc, curr) => acc + curr, 0);\nconsole.log(sum); // 15\n\n// 2. Flatten array\nconst nested = [[1, 2], [3, 4], [5]];\nconst flat = nested.reduce((acc, arr) => acc.concat(arr), []);\nconsole.log(flat); // [1, 2, 3, 4, 5]\n\n// 3. Count occurrences\nconst fruits = ['apple', 'banana', 'apple', 'orange', 'banana', 'apple'];\nconst count = fruits.reduce((acc, fruit) => {\n  acc[fruit] = (acc[fruit] || 0) + 1;\n  return acc;\n}, {});\nconsole.log(count); // { apple: 3, banana: 2, orange: 1 }\n\n// 4. Group by property\nconst users = [\n  { name: 'Alice', age: 25 },\n  { name: 'Bob', age: 30 },\n  { name: 'Charlie', age: 25 }\n];\nconst groupedByAge = users.reduce((acc, user) => {\n  const age = user.age;\n  if (!acc[age]) acc[age] = [];\n  acc[age].push(user);\n  return acc;\n}, {});\n// { 25: [{Alice}, {Charlie}], 30: [{Bob}] }\n\n// 5. Transform array to object\nconst arr = ['a', 'b', 'c'];\nconst obj = arr.reduce((acc, val, idx) => {\n  acc[val] = idx;\n  return acc;\n}, {});\nconsole.log(obj); // { a: 0, b: 1, c: 2 }\n\n// 6. Pipe functions\nconst pipe = (...fns) => x => fns.reduce((v, f) => f(v), x);\nconst add5 = x => x + 5;\nconst multiply3 = x => x * 3;\nconst result = pipe(add5, multiply3)(10); // (10 + 5) * 3 = 45"
        },
        {
          "type": "interview-tip",
          "tip": "reduce() Best Practices",
          "explanation": "1. Always provide initial value (second parameter)\n2. Accumulator can be any type: number, object, array\n3. Return accumulator in each iteration\n4. More powerful than map/filter but harder to read\n5. Consider using specific methods for simple cases (sum → reduce, but map/filter for transformations)"
        },
        {
          "type": "title",
          "level": 2,
          "content": "Q4. Explain the difference between for...of and for...in loops?"
        },
        {
          "type": "description",
          "content": "for...of iterates over iterable objects (arrays, strings, Maps, Sets) returning values. for...in iterates over enumerable properties of objects returning keys/indices. Use for...of for arrays, for...in for object properties."
        },
        {
          "type": "code",
          "language": "javascript",
          "title": "for...of vs for...in Examples",
          "code": "// for...of - Iterates over VALUES\nconst array = ['a', 'b', 'c'];\nfor (const value of array) {\n  console.log(value); // 'a', 'b', 'c'\n}\n\n// for...in - Iterates over KEYS/INDICES\nfor (const index in array) {\n  console.log(index); // '0', '1', '2' (strings!)\n  console.log(typeof index); // 'string'\n}\n\n// Object iteration\nconst obj = { name: 'Alice', age: 25, city: 'NYC' };\n\n// for...in - Works with objects\nfor (const key in obj) {\n  console.log(key, obj[key]);\n  // name Alice\n  // age 25\n  // city NYC\n}\n\n// for...of - Doesn't work with plain objects\n// for (const val of obj) {} // Error: obj is not iterable\n\n// for...of with Object methods\nfor (const key of Object.keys(obj)) {\n  console.log(key); // name, age, city\n}\n\nfor (const value of Object.values(obj)) {\n  console.log(value); // Alice, 25, NYC\n}\n\nfor (const [key, value] of Object.entries(obj)) {\n  console.log(key, value); // name Alice, age 25, city NYC\n}\n\n// String iteration\nconst str = 'hello';\nfor (const char of str) {\n  console.log(char); // h, e, l, l, o\n}\n\n// Map and Set\nconst map = new Map([['a', 1], ['b', 2]]);\nfor (const [key, value] of map) {\n  console.log(key, value); // a 1, b 2\n}\n\nconst set = new Set([1, 2, 3]);\nfor (const value of set) {\n  console.log(value); // 1, 2, 3\n}\n\n// Array with custom properties (edge case)\nconst arr = [1, 2, 3];\narr.customProp = 'hello';\n\nfor (const val of arr) {\n  console.log(val); // 1, 2, 3 (only array elements)\n}\n\nfor (const key in arr) {\n  console.log(key); // '0', '1', '2', 'customProp' (includes custom property!)\n}"
        },
        {
          "type": "interview-tip",
          "tip": "Usage Guidelines",
          "explanation": "1. for...of: Arrays, strings, Maps, Sets, any iterable\n2. for...in: Object properties (but beware of prototype chain)\n3. for...of gets VALUES, for...in gets KEYS\n4. for...in returns strings, not numbers for array indices\n5. Avoid for...in for arrays (can include inherited properties)\n6. Use Object.hasOwnProperty() with for...in to skip inherited properties"
        }
      ]
    },
    {
      "id": "section-2",
      "title": "JavaScript - Data Types",
      "blocks": [
        {
          "type": "title",
          "level": 2,
          "content": "Q1. What is the difference between null and undefined?"
        },
        {
          "type": "description",
          "content": "undefined means a variable has been declared but not assigned a value, or a function doesn't return anything. null is an assignment value representing no value or empty. typeof null returns 'object' (historical bug), typeof undefined returns 'undefined'."
        },
        {
          "type": "code",
          "language": "javascript",
          "title": "null vs undefined Examples",
          "code": "// undefined - Variable declared but not assigned\nlet x;\nconsole.log(x); // undefined\nconsole.log(typeof x); // 'undefined'\n\n// undefined - Function with no return\nfunction noReturn() {}\nconsole.log(noReturn()); // undefined\n\n// undefined - Non-existent object property\nconst obj = { name: 'Alice' };\nconsole.log(obj.age); // undefined\n\n// undefined - Missing function parameter\nfunction greet(name) {\n  console.log(name); // undefined if not provided\n}\ngreet();\n\n// null - Intentional absence of value\nlet user = null; // explicitly set to null\nconsole.log(user); // null\nconsole.log(typeof user); // 'object' (JavaScript bug!)\n\n// Comparisons\nconsole.log(null == undefined);  // true (loose equality)\nconsole.log(null === undefined); // false (strict equality)\nconsole.log(null == 0);          // false\nconsole.log(undefined == 0);     // false\n\n// Practical usage\nfunction findUser(id) {\n  // return null to indicate \"searched but not found\"\n  // undefined would mean \"didn't search\" or error\n  return users.find(u => u.id === id) || null;\n}\n\n// Default values\nfunction config(options = {}) {\n  // undefined triggers default, null doesn't\n  const timeout = options.timeout ?? 1000; // nullish coalescing\n  const retry = options.retry !== undefined ? options.retry : 3;\n}\n\nconfig({ timeout: undefined }); // timeout = 1000\nconfig({ timeout: null });      // timeout = null (not default!)\nconfig({ timeout: 0 });         // timeout = 0 (falsy but defined)"
        },
        {
          "type": "interview-tip",
          "tip": "Key Differences",
          "explanation": "1. undefined: automatic, means 'not assigned'\n2. null: manual, means 'intentionally empty'\n3. typeof null === 'object' is a JavaScript bug from 1995\n4. Use null to reset/clear a value explicitly\n5. Use optional chaining (?.) to handle both: obj?.prop\n6. Nullish coalescing (???) only checks for null/undefined, not all falsy values"
        },
        {
          "type": "title",
          "level": 2,
          "content": "Q2. What is a Symbol in JavaScript?"
        },
        {
          "type": "description",
          "content": "Symbol is a primitive data type introduced in ES6 that creates unique, immutable identifiers. Used for creating unique object property keys that won't conflict. Created using Symbol() or Symbol.for() for global registry."
        },
        {
          "type": "code",
          "language": "javascript",
          "title": "Symbol Examples",
          "code": "// Creating symbols - each is unique\nconst sym1 = Symbol();\nconst sym2 = Symbol();\nconst sym3 = Symbol('description');\n\nconsole.log(sym1 === sym2); // false (always unique)\nconsole.log(sym3.toString()); // 'Symbol(description)'\n\n// Symbol as object property\nconst ID = Symbol('id');\nconst user = {\n  name: 'Alice',\n  [ID]: 12345 // symbol as computed property\n};\n\nconsole.log(user[ID]); // 12345\nconsole.log(user.ID);  // undefined (not the same as string 'ID')\n\n// Symbols are hidden from iteration\nfor (let key in user) {\n  console.log(key); // Only 'name' (symbol is skipped)\n}\n\nconsole.log(Object.keys(user)); // ['name']\nconsole.log(Object.getOwnPropertySymbols(user)); // [Symbol(id)]\n\n// Global symbol registry - Symbol.for()\nconst globalSym1 = Symbol.for('app.id');\nconst globalSym2 = Symbol.for('app.id');\nconsole.log(globalSym1 === globalSym2); // true (same from registry)\n\n// Get key from global symbol\nconsole.log(Symbol.keyFor(globalSym1)); // 'app.id'\nconsole.log(Symbol.keyFor(sym1)); // undefined (not in global registry)\n\n// Well-known symbols - built-in JavaScript symbols\nconst arr = [1, 2, 3];\nconsole.log(arr[Symbol.iterator]); // ƒ values() { [native code] }\n\n// Custom iterator using Symbol.iterator\nconst range = {\n  from: 1,\n  to: 5,\n  \n  [Symbol.iterator]() {\n    let current = this.from;\n    let last = this.to;\n    \n    return {\n      next() {\n        if (current <= last) {\n          return { value: current++, done: false };\n        }\n        return { done: true };\n      }\n    };\n  }\n};\n\nfor (let num of range) {\n  console.log(num); // 1, 2, 3, 4, 5\n}\n\n// Private-like properties (not truly private)\nconst _private = Symbol('private');\nclass MyClass {\n  constructor() {\n    this[_private] = 'secret';\n    this.public = 'visible';\n  }\n  \n  getPrivate() {\n    return this[_private];\n  }\n}\n\nconst instance = new MyClass();\nconsole.log(instance.public);        // 'visible'\nconsole.log(instance[_private]);     // undefined (don't have reference)\nconsole.log(instance.getPrivate());  // 'secret'"
        },
        {
          "type": "interview-tip",
          "tip": "Symbol Use Cases",
          "explanation": "1. Unique property keys (avoid name collisions)\n2. Meta-programming with well-known symbols (Symbol.iterator, Symbol.toStringTag)\n3. Semi-private object properties\n4. Constants that must be unique\n5. Symbols are not truly private (can access via Object.getOwnPropertySymbols())\n6. Common well-known symbols: iterator, hasInstance, toPrimitive, toStringTag"
        },
        {
          "type": "title",
          "level": 2,
          "content": "Q3. What is the difference between Set and Map?"
        },
        {
          "type": "description",
          "content": "Set stores unique values of any type, like a collection with no duplicates. Map stores key-value pairs where keys can be any type (not just strings). Set has add/has/delete, Map has set/get/has/delete methods."
        },
        {
          "type": "code",
          "language": "javascript",
          "title": "Set vs Map Examples",
          "code": "// SET - Unique values collection\nconst set = new Set();\n\n// Adding values\nset.add(1);\nset.add(2);\nset.add(2); // Duplicate ignored\nset.add('2'); // Different type, so added\n\nconsole.log(set); // Set(3) { 1, 2, '2' }\nconsole.log(set.size); // 3\nconsole.log(set.has(2)); // true\n\n// Remove duplicates from array\nconst numbers = [1, 2, 2, 3, 3, 3, 4];\nconst unique = [...new Set(numbers)];\nconsole.log(unique); // [1, 2, 3, 4]\n\n// Set operations\nconst setA = new Set([1, 2, 3]);\nconst setB = new Set([3, 4, 5]);\n\n// Union\nconst union = new Set([...setA, ...setB]);\nconsole.log(union); // Set(5) { 1, 2, 3, 4, 5 }\n\n// Intersection\nconst intersection = new Set([...setA].filter(x => setB.has(x)));\nconsole.log(intersection); // Set(1) { 3 }\n\n// Difference\nconst difference = new Set([...setA].filter(x => !setB.has(x)));\nconsole.log(difference); // Set(2) { 1, 2 }\n\n// Iteration\nfor (const value of set) {\n  console.log(value); // 1, 2, '2'\n}\n\nset.forEach(value => console.log(value));\n\n// MAP - Key-value pairs with any type keys\nconst map = new Map();\n\n// Setting values\nmap.set('name', 'Alice');\nmap.set(1, 'one');\nmap.set(true, 'boolean key');\n\nconst obj = { id: 1 };\nmap.set(obj, 'object as key'); // Object as key!\n\nconsole.log(map.size); // 4\nconsole.log(map.get('name')); // 'Alice'\nconsole.log(map.get(obj)); // 'object as key'\nconsole.log(map.has(1)); // true\n\n// Map from array of pairs\nconst map2 = new Map([\n  ['a', 1],\n  ['b', 2],\n  ['c', 3]\n]);\n\n// Iteration\nfor (const [key, value] of map) {\n  console.log(key, value);\n}\n\nmap.forEach((value, key) => {\n  console.log(key, value);\n});\n\n// Keys, values, entries\nconsole.log([...map.keys()]);   // ['name', 1, true, {id: 1}]\nconsole.log([...map.values()]); // ['Alice', 'one', 'boolean key', 'object as key']\nconsole.log([...map.entries()]); // [[key, value], ...]\n\n// Object vs Map\nconst plainObj = {};\nplainObj['1'] = 'string one';\nplainObj[1] = 'number one';\nconsole.log(plainObj); // { '1': 'number one' } - keys are strings!\n\nconst mapObj = new Map();\nmapObj.set('1', 'string one');\nmapObj.set(1, 'number one');\nconsole.log(mapObj.get('1')); // 'string one'\nconsole.log(mapObj.get(1));   // 'number one' - keys maintain type!\n\n// Performance comparison\nconst perfMap = new Map();\nconst perfObj = {};\n\n// Map is faster for frequent additions/deletions\n// Object is better for static key-value storage\n// Map maintains insertion order (objects do too in modern JS)"
        },
        {
          "type": "interview-tip",
          "tip": "Set vs Map Comparison",
          "explanation": "SET:\n1. Stores unique values only\n2. Methods: add(), has(), delete(), clear()\n3. Use for: removing duplicates, membership testing\n\nMAP:\n1. Stores key-value pairs\n2. Keys can be any type (objects, functions, primitives)\n3. Methods: set(), get(), has(), delete(), clear()\n4. Better than objects when: frequent add/delete, non-string keys, need size property\n5. Maintains insertion order\n\nBoth are iterable and have size property"
        },
        {
          "type": "title",
          "level": 2,
          "content": "Q4. What are WeakSet and WeakMap?"
        },
        {
          "type": "description",
          "content": "WeakSet and WeakMap hold 'weak' references to objects, allowing garbage collection if no other references exist. Keys must be objects. They're not enumerable and don't prevent garbage collection, useful for memory-sensitive scenarios."
        },
        {
          "type": "code",
          "language": "javascript",
          "title": "WeakSet and WeakMap Examples",
          "code": "// WEAKSET - Weak references to objects only\nconst weakSet = new WeakSet();\n\nlet obj1 = { name: 'Alice' };\nlet obj2 = { name: 'Bob' };\n\nweakSet.add(obj1);\nweakSet.add(obj2);\n\nconsole.log(weakSet.has(obj1)); // true\n\n// Cannot add primitives\n// weakSet.add(1); // TypeError: Invalid value used in weak set\n// weakSet.add('string'); // TypeError\n\n// Not enumerable\n// console.log(weakSet.size); // undefined\n// for (let item of weakSet) {} // TypeError: not iterable\n\n// Garbage collection\nobj1 = null; // Now obj1 can be garbage collected\n// WeakSet doesn't prevent garbage collection\n\n// Use case: Track object visited state\nconst visited = new WeakSet();\n\nfunction traverse(node) {\n  if (visited.has(node)) return; // Already visited\n  \n  visited.add(node);\n  // Process node...\n  \n  if (node.children) {\n    node.children.forEach(child => traverse(child));\n  }\n}\n\n// WEAKMAP - Weak references for keys\nconst weakMap = new WeakMap();\n\nlet user = { id: 1, name: 'Alice' };\nlet metadata = { lastLogin: new Date(), visits: 5 };\n\n// Store metadata associated with user object\nweakMap.set(user, metadata);\n\nconsole.log(weakMap.get(user)); // { lastLogin: ..., visits: 5 }\nconsole.log(weakMap.has(user)); // true\n\nweakMap.delete(user);\n\n// Keys must be objects\n// weakMap.set('key', 'value'); // TypeError\n\n// Not enumerable\n// console.log(weakMap.size); // undefined\n// weakMap.forEach(...); // Not available\n\n// Garbage collection\nuser = null; // metadata can now be garbage collected too\n\n// Use case 1: Private data storage\nconst privateData = new WeakMap();\n\nclass Person {\n  constructor(name, ssn) {\n    this.name = name; // public\n    privateData.set(this, { ssn }); // private via WeakMap\n  }\n  \n  getSSN() {\n    return privateData.get(this).ssn;\n  }\n}\n\nconst person = new Person('Alice', '123-45-6789');\nconsole.log(person.name); // 'Alice'\nconsole.log(person.ssn); // undefined (not accessible)\nconsole.log(person.getSSN()); // '123-45-6789'\n\n// Use case 2: Caching with automatic cleanup\nconst cache = new WeakMap();\n\nfunction computeExpensive(obj) {\n  if (cache.has(obj)) {\n    console.log('Using cached result');\n    return cache.get(obj);\n  }\n  \n  console.log('Computing...');\n  const result = /* expensive computation */ obj.value * 1000;\n  cache.set(obj, result);\n  return result;\n}\n\nlet data = { value: 42 };\ncomputeExpensive(data); // Computing... 42000\ncomputeExpensive(data); // Using cached result 42000\ndata = null; // Cache entry automatically removed when data is garbage collected\n\n// Use case 3: DOM node metadata\nconst elementData = new WeakMap();\n\nfunction attachData(element, data) {\n  elementData.set(element, data);\n}\n\nfunction getData(element) {\n  return elementData.get(element);\n}\n\n// When DOM element is removed, data is automatically cleaned up\nconst div = document.createElement('div');\nattachData(div, { clicks: 0, timestamp: Date.now() });\n// If div is removed from DOM and no references exist, data is GC'd"
        },
        {
          "type": "interview-tip",
          "tip": "Weak Collections Key Points",
          "explanation": "WHEN TO USE:\n1. WeakSet: Track object state without preventing GC (visited nodes, DOM elements)\n2. WeakMap: Associate metadata with objects (private data, caching)\n3. Memory-sensitive applications where cleanup is important\n\nLIMITATIONS:\n1. Keys/values must be objects (no primitives)\n2. Not enumerable (no size, no iteration)\n3. Can't get list of all keys/values\n4. Perfect for temporary associations that should not extend object lifetime"
        }
      ]
    },
    {
      "id": "section-3",
      "title": "JavaScript - Objects",
      "blocks": [
        {
          "type": "title",
          "level": 2,
          "content": "Q1. What is the difference between shallow copy and deep copy? How to implement each?"
        },
        {
          "type": "description",
          "content": "Shallow copy creates a new object but copies references to nested objects (one level deep). Deep copy creates a completely independent copy including all nested objects. Shallow: spread operator, Object.assign(). Deep: JSON.parse(JSON.stringify()), structuredClone(), or custom recursive function."
        },
        {
          "type": "code",
          "language": "javascript",
          "title": "Shallow vs Deep Copy Examples",
          "code": "// Original object with nested structure\nconst original = {\n  name: 'Alice',\n  age: 25,\n  address: {\n    city: 'NYC',\n    zip: '10001'\n  },\n  hobbies: ['reading', 'coding']\n};\n\n// SHALLOW COPY - Method 1: Spread operator\nconst shallow1 = { ...original };\nshallow1.name = 'Bob'; // OK - primitive copied\nshallow1.address.city = 'LA'; // PROBLEM - affects original!\n\nconsole.log(original.address.city); // 'LA' (changed!)\nconsole.log(shallow1.address === original.address); // true (same reference)\n\n// SHALLOW COPY - Method 2: Object.assign()\nconst shallow2 = Object.assign({}, original);\nshallow2.hobbies.push('gaming'); // PROBLEM - affects original!\nconsole.log(original.hobbies); // ['reading', 'coding', 'gaming']\n\n// DEEP COPY - Method 1: JSON (limitations!)\nconst deep1 = JSON.parse(JSON.stringify(original));\ndeep1.address.city = 'SF';\ndeep1.hobbies.push('swimming');\n\nconsole.log(original.address.city); // 'NYC' (unchanged!)\nconsole.log(original.hobbies.length); // 3 (unchanged)\nconsole.log(deep1.address === original.address); // false\n\n// JSON method limitations\nconst withFunctions = {\n  name: 'Test',\n  method: function() { return 'hello'; },\n  date: new Date(),\n  undefined: undefined,\n  symbol: Symbol('test'),\n  circular: null\n};\nwithFunctions.circular = withFunctions; // circular reference\n\nconst jsonCopy = JSON.parse(JSON.stringify(withFunctions));\nconsole.log(jsonCopy.method); // undefined (functions lost!)\nconsole.log(jsonCopy.date); // string, not Date object\nconsole.log(jsonCopy.undefined); // undefined (property lost!)\nconsole.log(jsonCopy.symbol); // undefined (symbols lost!)\n// Circular reference would throw error\n\n// DEEP COPY - Method 2: structuredClone (modern, best)\nconst deep2 = structuredClone(original);\ndeep2.address.city = 'Boston';\nconsole.log(original.address.city); // 'NYC' (unchanged)\n\n// structuredClone handles more types\nconst complex = {\n  date: new Date(),\n  map: new Map([['a', 1]]),\n  set: new Set([1, 2, 3]),\n  arrayBuffer: new ArrayBuffer(8),\n  regex: /test/gi\n};\n\nconst complexCopy = structuredClone(complex);\nconsole.log(complexCopy.date instanceof Date); // true\nconsole.log(complexCopy.map instanceof Map); // true\n\n// structuredClone limitations (no functions, symbols)\nconst withFunc = { fn: () => 'test' };\n// structuredClone(withFunc); // Error: functions not cloneable\n\n// DEEP COPY - Method 3: Custom recursive\nfunction deepClone(obj, hash = new WeakMap()) {\n  // Handle primitives and null\n  if (obj === null || typeof obj !== 'object') return obj;\n  \n  // Handle circular references\n  if (hash.has(obj)) return hash.get(obj);\n  \n  // Handle Date\n  if (obj instanceof Date) return new Date(obj);\n  \n  // Handle RegExp\n  if (obj instanceof RegExp) return new RegExp(obj);\n  \n  // Handle Array\n  if (Array.isArray(obj)) {\n    const arrCopy = [];\n    hash.set(obj, arrCopy);\n    obj.forEach((item, index) => {\n      arrCopy[index] = deepClone(item, hash);\n    });\n    return arrCopy;\n  }\n  \n  // Handle Object\n  const objCopy = {};\n  hash.set(obj, objCopy);\n  \n  Object.keys(obj).forEach(key => {\n    objCopy[key] = deepClone(obj[key], hash);\n  });\n  \n  return objCopy;\n}\n\n// Test custom deep clone\nconst testObj = {\n  a: 1,\n  b: { c: 2 },\n  d: [3, 4],\n  e: new Date(),\n  f: /test/\n};\ntestObj.circular = testObj;\n\nconst cloned = deepClone(testObj);\ncloned.b.c = 999;\nconsole.log(testObj.b.c); // 2 (unchanged)\nconsole.log(cloned.circular === cloned); // true (circular maintained)"
        },
        {
          "type": "interview-tip",
          "tip": "Copy Methods Summary",
          "explanation": "SHALLOW COPY:\n- Spread (...), Object.assign(), Array.slice()\n- Fast, one-level deep only\n- Nested objects share references\n\nDEEP COPY:\n- structuredClone() - BEST for most cases (modern browsers)\n- JSON.parse(JSON.stringify()) - Simple but loses functions, dates become strings\n- Custom recursive - Full control, handles all cases\n- Libraries: lodash.cloneDeep() for production\n\nChoose based on: data complexity, performance needs, browser support"
        },
        {
          "type": "title",
          "level": 2,
          "content": "Q2. Explain Object.assign() and its use cases?"
        },
        {
          "type": "description",
          "content": "Object.assign() copies enumerable own properties from one or more source objects to a target object. Returns the target object. Used for shallow copying, merging objects, and cloning. Syntax: Object.assign(target, ...sources)."
        },
        {
          "type": "code",
          "language": "javascript",
          "title": "Object.assign() Examples",
          "code": "// Basic usage: Object.assign(target, source1, source2, ...)\n\n// 1. Cloning an object (shallow)\nconst original = { a: 1, b: 2 };\nconst clone = Object.assign({}, original);\nclone.a = 99;\nconsole.log(original.a); // 1 (unchanged)\n\n// 2. Merging objects\nconst defaults = { theme: 'light', lang: 'en', timeout: 5000 };\nconst userConfig = { theme: 'dark', timeout: 3000 };\nconst config = Object.assign({}, defaults, userConfig);\nconsole.log(config); // { theme: 'dark', lang: 'en', timeout: 3000 }\n// userConfig properties override defaults\n\n// 3. Adding properties to existing object\nconst user = { name: 'Alice' };\nObject.assign(user, { age: 25, email: 'alice@example.com' });\nconsole.log(user); // { name: 'Alice', age: 25, email: 'alice@example.com' }\n\n// 4. Multiple sources (later sources override earlier)\nconst obj1 = { a: 1, b: 2 };\nconst obj2 = { b: 3, c: 4 };\nconst obj3 = { c: 5, d: 6 };\nconst merged = Object.assign({}, obj1, obj2, obj3);\nconsole.log(merged); // { a: 1, b: 3, c: 5, d: 6 }\n\n// 5. Shallow copy problem\nconst source = {\n  name: 'Alice',\n  address: { city: 'NYC' }\n};\nconst copy = Object.assign({}, source);\ncopy.address.city = 'LA';\nconsole.log(source.address.city); // 'LA' (affected!)\n\n// 6. Only enumerable properties\nconst source2 = Object.create(\n  { inherited: 1 }, // prototype (not copied)\n  {\n    own: { value: 2, enumerable: true },\n    hidden: { value: 3, enumerable: false }\n  }\n);\n\nconst copy2 = Object.assign({}, source2);\nconsole.log(copy2); // { own: 2 } (only enumerable own properties)\nconsole.log(copy2.inherited); // undefined\nconsole.log(copy2.hidden); // undefined\n\n// 7. Copying symbols\nconst sym = Symbol('test');\nconst withSymbol = { [sym]: 'symbol value', regular: 'regular' };\nconst copiedSymbol = Object.assign({}, withSymbol);\nconsole.log(copiedSymbol[sym]); // 'symbol value' (symbols copied!)\n\n// 8. Triggering setters\nconst target = {\n  set name(value) {\n    console.log(`Setting name to ${value}`);\n    this._name = value;\n  }\n};\n\nObject.assign(target, { name: 'Alice' }); // Logs: Setting name to Alice\n\n// 9. Error handling (stops on error)\ntry {\n  const target = {};\n  const source1 = { a: 1 };\n  const source2 = Object.defineProperty({}, 'b', {\n    get() { throw new Error('Error!'); }\n  });\n  const source3 = { c: 3 };\n  \n  Object.assign(target, source1, source2, source3);\n} catch (e) {\n  console.log(e.message); // 'Error!'\n  // target has { a: 1 } but not c: 3 (stopped on error)\n}\n\n// 10. vs Spread operator (similar but different)\nconst a = { x: 1, y: 2 };\nconst b = { y: 3, z: 4 };\n\n// Object.assign modifies first argument\nconst result1 = Object.assign(a, b);\nconsole.log(a); // { x: 1, y: 3, z: 4 } (modified!)\nconsole.log(result1 === a); // true (same object)\n\n// Spread creates new object\nconst c = { x: 1, y: 2 };\nconst d = { y: 3, z: 4 };\nconst result2 = { ...c, ...d };\nconsole.log(c); // { x: 1, y: 2 } (unchanged)\nconsole.log(result2 === c); // false (new object)\n\n// Common patterns\n// Pattern 1: Default options\nfunction createUser(options) {\n  const defaults = {\n    role: 'user',\n    active: true,\n    permissions: ['read']\n  };\n  return Object.assign({}, defaults, options);\n}\n\n// Pattern 2: Immutable update\nfunction updateState(state, updates) {\n  return Object.assign({}, state, updates);\n}\n\nconst state = { count: 0, loading: false };\nconst newState = updateState(state, { count: 1 });\nconsole.log(state); // { count: 0, loading: false } (unchanged)\nconsole.log(newState); // { count: 1, loading: false }"
        },
        {
          "type": "interview-tip",
          "tip": "Object.assign() Key Points",
          "explanation": "1. RETURNS the target object (mutates it)\n2. Shallow copy only (nested objects referenced)\n3. Copies enumerable own properties + symbols\n4. Later sources override earlier ones\n5. Triggers setters on target object\n6. Stops on first error\n\nMODERN ALTERNATIVE:\nSpread operator {...a, ...b} is preferred:\n- More readable\n- Creates new object (doesn't mutate)\n- Same shallow copy behavior\n\nUSE CASES:\n- Merging configs/options\n- Shallow cloning\n- Adding properties\n- Polyfills (older browsers)"
        },
        {
          "type": "title",
          "level": 2,
          "content": "Q3. What are property descriptors? Explain Object.defineProperty()?"
        },
        {
          "type": "description",
          "content": "Property descriptors are objects that define the characteristics of object properties: value, writable, enumerable, configurable, get, set. Object.defineProperty() allows precise control over property behavior. Used for read-only properties, getters/setters, and hiding properties from iteration."
        },
        {
          "type": "code",
          "language": "javascript",
          "title": "Property Descriptors Examples",
          "code": "// Getting property descriptor\nconst obj = { name: 'Alice', age: 25 };\nconst descriptor = Object.getOwnPropertyDescriptor(obj, 'name');\nconsole.log(descriptor);\n// {\n//   value: 'Alice',\n//   writable: true,     // can change value\n//   enumerable: true,   // shows in for...in, Object.keys()\n//   configurable: true  // can delete or change descriptor\n// }\n\n// Defining property with custom descriptor\nconst person = {};\n\nObject.defineProperty(person, 'name', {\n  value: 'Bob',\n  writable: false,     // Read-only!\n  enumerable: true,\n  configurable: false  // Can't delete or reconfigure!\n});\n\nperson.name = 'Charlie'; // Fails silently (strict mode: TypeError)\nconsole.log(person.name); // 'Bob' (unchanged)\n\ndelete person.name; // Fails silently\nconsole.log(person.name); // 'Bob' (still there)\n\n// Attempting to reconfigure\ntry {\n  Object.defineProperty(person, 'name', { writable: true });\n} catch (e) {\n  console.log(e.message); // TypeError: Cannot redefine property\n}\n\n// Non-enumerable property (hidden from iteration)\nconst user = { firstName: 'Alice', lastName: 'Smith' };\n\nObject.defineProperty(user, 'ssn', {\n  value: '123-45-6789',\n  enumerable: false  // Hidden!\n});\n\nconsole.log(user.ssn); // '123-45-6789' (accessible)\nconsole.log(Object.keys(user)); // ['firstName', 'lastName'] (ssn hidden)\nfor (let key in user) {\n  console.log(key); // firstName, lastName (no ssn)\n}\n\n// Get all properties including non-enumerable\nconsole.log(Object.getOwnPropertyNames(user)); // ['firstName', 'lastName', 'ssn']\n\n// Getter and Setter\nconst account = {\n  _balance: 1000 // convention: underscore for 'internal'\n};\n\nObject.defineProperty(account, 'balance', {\n  get() {\n    console.log('Getting balance');\n    return this._balance;\n  },\n  set(value) {\n    if (value < 0) {\n      throw new Error('Balance cannot be negative');\n    }\n    console.log(`Setting balance to ${value}`);\n    this._balance = value;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nconsole.log(account.balance); // Logs 'Getting balance', returns 1000\naccount.balance = 2000; // Logs 'Setting balance to 2000'\ntry {\n  account.balance = -100; // Throws error\n} catch (e) {\n  console.log(e.message);\n}\n\n// Computed property\nconst person2 = {\n  firstName: 'John',\n  lastName: 'Doe'\n};\n\nObject.defineProperty(person2, 'fullName', {\n  get() {\n    return `${this.firstName} ${this.lastName}`;\n  },\n  set(value) {\n    const parts = value.split(' ');\n    this.firstName = parts[0];\n    this.lastName = parts[1];\n  },\n  enumerable: true\n});\n\nconsole.log(person2.fullName); // 'John Doe'\nperson2.fullName = 'Jane Smith';\nconsole.log(person2.firstName); // 'Jane'\nconsole.log(person2.lastName); // 'Smith'\n\n// Define multiple properties\nconst product = {};\n\nObject.defineProperties(product, {\n  id: {\n    value: 1,\n    writable: false,\n    enumerable: true\n  },\n  name: {\n    value: 'Laptop',\n    writable: true,\n    enumerable: true\n  },\n  _price: {\n    value: 1000,\n    writable: true,\n    enumerable: false  // Internal property\n  },\n  price: {\n    get() { return this._price; },\n    set(val) {\n      if (val < 0) throw new Error('Invalid price');\n      this._price = val;\n    },\n    enumerable: true\n  }\n});\n\nconsole.log(product); // { id: 1, name: 'Laptop', price: [Getter/Setter] }\n\n// Preventing object modification\nconst config = { api: 'https://api.example.com', timeout: 5000 };\n\n// Prevent adding new properties\nObject.preventExtensions(config);\nconfig.newProp = 'test'; // Fails silently\nconsole.log(config.newProp); // undefined\nconfig.timeout = 3000; // OK - can still modify existing\n\n// Make all properties non-configurable\nconst settings = { theme: 'dark' };\nObject.seal(settings);\nsettings.theme = 'light'; // OK - can modify value\nsettings.newProp = 'test'; // Fails - can't add\ndelete settings.theme; // Fails - can't delete\n\n// Make all properties read-only\nconst constants = { PI: 3.14159, E: 2.71828 };\nObject.freeze(constants);\nconstants.PI = 3; // Fails\nconstants.newProp = 1; // Fails\ndelete constants.PI; // Fails\nconsole.log(Object.isFrozen(constants)); // true\n\n// Note: freeze/seal are shallow!\nconst data = {\n  user: { name: 'Alice' }\n};\nObject.freeze(data);\ndata.user.name = 'Bob'; // Works! (nested object not frozen)\nconsole.log(data.user.name); // 'Bob'\n\n// Deep freeze implementation\nfunction deepFreeze(obj) {\n  Object.freeze(obj);\n  Object.getOwnPropertyNames(obj).forEach(prop => {\n    if (obj[prop] !== null\n        && (typeof obj[prop] === 'object' || typeof obj[prop] === 'function')\n        && !Object.isFrozen(obj[prop])) {\n      deepFreeze(obj[prop]);\n    }\n  });\n  return obj;\n}"
        },
        {
          "type": "interview-tip",
          "tip": "Property Descriptor Flags",
          "explanation": "DESCRIPTOR PROPERTIES:\n- value: property value\n- writable: can change value (default: false for defineProperty)\n- enumerable: shows in iteration (default: false for defineProperty)\n- configurable: can delete/modify descriptor (default: false for defineProperty)\n- get: getter function\n- set: setter function\n\nOBJECT PROTECTION LEVELS:\n1. Object.preventExtensions() - can't add new properties\n2. Object.seal() - can't add/delete, can modify values\n3. Object.freeze() - completely immutable (shallow)\n\nUSE CASES:\n- Read-only constants\n- Validation in setters\n- Computed properties\n- Hiding internal properties"
        },
        {
          "type": "title",
          "level": 2,
          "content": "Q4. What is optional chaining (?.) and nullish coalescing (???)?"
        },
        {
          "type": "description",
          "content": "Optional chaining (?.) safely accesses nested properties without throwing errors if intermediate values are null/undefined. Nullish coalescing (??) provides default values only for null/undefined (unlike || which treats all falsy values). Both introduced in ES2020."
        },
        {
          "type": "code",
          "language": "javascript",
          "title": "Optional Chaining & Nullish Coalescing",
          "code": "// OPTIONAL CHAINING (?.) - Safe property access\n\n// Without optional chaining (old way)\nconst user = {\n  name: 'Alice',\n  address: {\n    city: 'NYC'\n    // no street property\n  }\n};\n\n// Throws TypeError if address is undefined\n// const street = user.address.street.name; // Error!\n\n// Old defensive approach\nconst street1 = user && user.address && user.address.street && user.address.street.name;\nconsole.log(street1); // undefined (no error)\n\n// With optional chaining (modern)\nconst street2 = user?.address?.street?.name;\nconsole.log(street2); // undefined (clean!)\n\n// Optional chaining short-circuits\nlet count = 0;\nconst result = user?.missing?.prop?.[count++];\nconsole.log(count); // 0 (never incremented, short-circuited at 'missing')\n\n// Optional chaining with methods\nconst api = {\n  getData: () => ({ data: [1, 2, 3] })\n};\n\n// Safe method call\nconst data = api.getData?.();\nconsole.log(data); // { data: [1, 2, 3] }\n\nconst missingData = api.fetchData?.(); // undefined (method doesn't exist)\nconsole.log(missingData); // undefined (no error)\n\n// Optional chaining with arrays\nconst users = [\n  { name: 'Alice', settings: { theme: 'dark' } },\n  { name: 'Bob' } // no settings\n];\n\nconsole.log(users[0]?.settings?.theme); // 'dark'\nconsole.log(users[1]?.settings?.theme); // undefined\nconsole.log(users[5]?.settings?.theme); // undefined (index doesn't exist)\n\n// Dynamic property access\nconst propName = 'address';\nconst city = user?.[propName]?.city;\nconsole.log(city); // 'NYC'\n\n// NULLISH COALESCING (??) - Default values\n\n// Problem with logical OR (||)\nconst config1 = {\n  timeout: 0,      // valid value!\n  retry: '',       // valid value!\n  debug: false     // valid value!\n};\n\n// || treats all falsy values as \"use default\"\nconst timeout1 = config1.timeout || 5000;\nconst retry1 = config1.retry || 'default';\nconst debug1 = config1.debug || true;\n\nconsole.log(timeout1); // 5000 (wanted 0!)\nconsole.log(retry1);   // 'default' (wanted ''!)\nconsole.log(debug1);   // true (wanted false!)\n\n// ?? only treats null/undefined as \"use default\"\nconst timeout2 = config1.timeout ?? 5000;\nconst retry2 = config1.retry ?? 'default';\nconst debug2 = config1.debug ?? true;\n\nconsole.log(timeout2); // 0 (correct!)\nconsole.log(retry2);   // '' (correct!)\nconsole.log(debug2);   // false (correct!)\n\n// Only null/undefined trigger default\nconst value1 = null ?? 'default';      // 'default'\nconst value2 = undefined ?? 'default'; // 'default'\nconst value3 = 0 ?? 'default';         // 0\nconst value4 = '' ?? 'default';        // ''\nconst value5 = false ?? 'default';     // false\nconst value6 = NaN ?? 'default';       // NaN\n\n// Combining both operators\nconst userConfig = {\n  user: {\n    preferences: {\n      notifications: null\n    }\n  }\n};\n\nconst notifications = userConfig?.user?.preferences?.notifications ?? true;\nconsole.log(notifications); // true (null → default)\n\n// Practical example: API response handling\nfunction getUserData(apiResponse) {\n  return {\n    name: apiResponse?.user?.name ?? 'Guest',\n    email: apiResponse?.user?.email ?? 'no-email@example.com',\n    age: apiResponse?.user?.age ?? 0,\n    premium: apiResponse?.user?.premium ?? false,\n    settings: apiResponse?.user?.settings ?? { theme: 'light' }\n  };\n}\n\nconst response1 = { user: { name: 'Alice', age: 0 } };\nconst data1 = getUserData(response1);\nconsole.log(data1);\n// {\n//   name: 'Alice',\n//   email: 'no-email@example.com',\n//   age: 0,  // keeps 0, doesn't use default!\n//   premium: false,\n//   settings: { theme: 'light' }\n// }\n\nconst response2 = null;\nconst data2 = getUserData(response2);\nconsole.log(data2); // All defaults\n\n// Cannot combine with || or &&\n// const x = a ?? b || c;  // SyntaxError!\n// const y = a && b ?? c;  // SyntaxError!\n\n// Must use parentheses\nconst x = (a ?? b) || c;  // OK\nconst y = a && (b ?? c);  // OK\n\n// Nullish coalescing assignment (??=)\nlet config = { timeout: 1000 };\nconfig.timeout ??= 5000;  // 1000 (no change)\nconfig.retry ??= 3;        // 3 (assigned)\nconfig.debug ??= false;    // false (assigned)\nconsole.log(config); // { timeout: 1000, retry: 3, debug: false }\n\n// Real-world: form validation\nfunction validateForm(formData) {\n  return {\n    username: formData?.username ?? '',\n    email: formData?.email ?? '',\n    age: formData?.age ?? null,\n    terms: formData?.terms ?? false\n  };\n}\n\n// Real-world: localStorage with defaults\nfunction getSetting(key, defaultValue) {\n  const stored = localStorage.getItem(key);\n  return stored !== null ? JSON.parse(stored) : defaultValue;\n}\n\n// Using ?? operator\nfunction getSetting2(key, defaultValue) {\n  return JSON.parse(localStorage.getItem(key)) ?? defaultValue;\n}"
        },
        {
          "type": "interview-tip",
          "tip": "Optional Chaining & Nullish Coalescing",
          "explanation": "OPTIONAL CHAINING (?.):\n- Returns undefined if any part is null/undefined\n- Works with: properties (?.), methods (?.()), arrays (?.[i])\n- Short-circuits evaluation (stops at first null/undefined)\n- Can't be used on left side of assignment\n\nNULLISH COALESCING (??):\n- Only null/undefined trigger default (not 0, '', false)\n- Better than || for default values\n- Can't mix with && or || without parentheses\n- Assignment variant: ??=\n\nCOMBINE THEM:\nuser?.profile?.theme ?? 'light'\n\nBROWSER SUPPORT: ES2020+ (most modern browsers)"
        }
      ]
    },
    {
      "id": "section-4",
      "title": "JavaScript - Functions",
      "blocks": [
        {
          "type": "title",
          "level": 2,
          "content": "Q1. Explain 'this' keyword and how its value is determined?"
        },
        {
          "type": "description",
          "content": "The 'this' keyword refers to the object that is executing the current function. Its value is determined by how the function is called (call-site), not where it's defined. Rules: method call (object), standalone function (global/undefined in strict), constructor (new object), explicit binding (call/apply/bind), arrow functions (lexical this)."
        },
        {
          "type": "code",
          "language": "javascript",
          "title": "'this' Keyword Examples",
          "code": "// Rule 1: Method invocation - 'this' is the object\nconst user = {\n  name: 'Alice',\n  greet() {\n    console.log(`Hello, ${this.name}`);\n  }\n};\n\nuser.greet(); // 'Hello, Alice' (this = user)\n\n// Losing 'this' context\nconst greetFunc = user.greet;\ngreetFunc(); // 'Hello, undefined' (this = global/undefined in strict)\n\n// Rule 2: Standalone function - 'this' is global (or undefined in strict mode)\nfunction showThis() {\n  console.log(this);\n}\n\nshowThis(); // Window (browser) or global (Node.js)\n\n'use strict';\nfunction strictThis() {\n  console.log(this);\n}\nstrictThis(); // undefined (in strict mode)\n\n// Rule 3: Constructor invocation - 'this' is the new object\nfunction Person(name) {\n  this.name = name;\n  this.greet = function() {\n    console.log(`Hi, I'm ${this.name}`);\n  };\n}\n\nconst person1 = new Person('Bob');\nperson1.greet(); // 'Hi, I'm Bob' (this = person1)\n\n// Rule 4: Explicit binding - call(), apply(), bind()\nfunction introduce(greeting, punctuation) {\n  console.log(`${greeting}, I'm ${this.name}${punctuation}`);\n}\n\nconst user1 = { name: 'Alice' };\nconst user2 = { name: 'Bob' };\n\n// call() - arguments separately\nintroduce.call(user1, 'Hello', '!'); // 'Hello, I'm Alice!'\nintroduce.call(user2, 'Hi', '.'); // 'Hi, I'm Bob.'\n\n// apply() - arguments as array\nintroduce.apply(user1, ['Hello', '!']); // 'Hello, I'm Alice!'\n\n// bind() - returns new function with fixed 'this'\nconst introduceAlice = introduce.bind(user1);\nintroduceAlice('Hey', '!!!'); // 'Hey, I'm Alice!!!'\n\n// Rule 5: Arrow functions - lexical 'this' (from enclosing scope)\nconst obj = {\n  name: 'Charlie',\n  regularFunc: function() {\n    console.log('Regular:', this.name); // 'Charlie'\n    \n    setTimeout(function() {\n      console.log('Callback regular:', this.name); // undefined (this = global)\n    }, 100);\n    \n    setTimeout(() => {\n      console.log('Callback arrow:', this.name); // 'Charlie' (lexical this)\n    }, 100);\n  },\n  \n  arrowFunc: () => {\n    console.log('Arrow:', this.name); // undefined (this from outer scope)\n  }\n};\n\nobj.regularFunc();\nobj.arrowFunc();\n\n// Practical example: Event handlers\nclass Button {\n  constructor(label) {\n    this.label = label;\n    this.clicks = 0;\n  }\n  \n  // Wrong: loses 'this' context\n  handleClickWrong() {\n    this.clicks++;\n    console.log(`${this.label} clicked ${this.clicks} times`);\n  }\n  \n  // Solution 1: Arrow function (recommended)\n  handleClickArrow = () => {\n    this.clicks++;\n    console.log(`${this.label} clicked ${this.clicks} times`);\n  }\n  \n  // Solution 2: Bind in constructor\n  constructor2(label) {\n    this.label = label;\n    this.clicks = 0;\n    this.handleClickWrong = this.handleClickWrong.bind(this);\n  }\n}\n\nconst btn = new Button('Submit');\n// In browser:\n// element.addEventListener('click', btn.handleClickWrong); // Error! 'this' = element\n// element.addEventListener('click', btn.handleClickArrow); // Works!\n\n// Complex example: method chaining\nclass Calculator {\n  constructor() {\n    this.value = 0;\n  }\n  \n  add(n) {\n    this.value += n;\n    return this; // return 'this' for chaining\n  }\n  \n  subtract(n) {\n    this.value -= n;\n    return this;\n  }\n  \n  multiply(n) {\n    this.value *= n;\n    return this;\n  }\n  \n  getResult() {\n    return this.value;\n  }\n}\n\nconst calc = new Calculator();\nconst result = calc.add(5).multiply(2).subtract(3).getResult();\nconsole.log(result); // 7\n\n// 'this' in nested objects\nconst company = {\n  name: 'TechCorp',\n  employee: {\n    name: 'John',\n    getName() {\n      return this.name; // 'this' = employee, not company\n    }\n  }\n};\n\nconsole.log(company.employee.getName()); // 'John'\n\n// Arrow function can't be used as constructor\ntry {\n  const ArrowPerson = (name) => {\n    this.name = name;\n  };\n  new ArrowPerson('Test'); // TypeError: ArrowPerson is not a constructor\n} catch (e) {\n  console.log(e.message);\n}\n\n// 'this' priority (highest to lowest)\n// 1. new binding\n// 2. explicit binding (call, apply, bind)\n// 3. implicit binding (method call)\n// 4. default binding (global/undefined)\n// Note: Arrow functions ignore all above rules and use lexical scope"
        },
        {
          "type": "interview-tip",
          "tip": "'this' Determination Rules",
          "explanation": "PRIORITY ORDER:\n1. new Constructor() → 'this' = new object\n2. func.call/apply/bind(obj) → 'this' = obj\n3. obj.method() → 'this' = obj\n4. standalone function → 'this' = global (undefined in strict)\n5. Arrow function → 'this' = lexical (from outer scope)\n\nCOMMON PITFALLS:\n- Event handlers lose 'this' (use arrow or bind)\n- Callbacks lose 'this' (use arrow functions)\n- Method extraction loses context\n\nSOLUTIONS:\n- Arrow functions for callbacks\n- bind() for event handlers\n- const self = this (old pattern, avoid)"
        },
        {
          "type": "title",
          "level": 2,
          "content": "Q2. What is the difference between call(), apply(), and bind()?"
        },
        {
          "type": "description",
          "content": "All three methods set the 'this' value for a function. call() invokes immediately with arguments separately. apply() invokes immediately with arguments as array. bind() returns a new function with 'this' bound permanently (doesn't invoke immediately)."
        },
        {
          "type": "code",
          "language": "javascript",
          "title": "call(), apply(), bind() Examples",
          "code": "const person1 = { name: 'Alice', age: 25 };\nconst person2 = { name: 'Bob', age: 30 };\n\nfunction introduce(greeting, punctuation) {\n  console.log(`${greeting}, I'm ${this.name}, ${this.age} years old${punctuation}`);\n}\n\n// CALL - func.call(thisArg, arg1, arg2, ...)\n// Arguments passed individually\nintroduce.call(person1, 'Hello', '!'); // 'Hello, I'm Alice, 25 years old!'\nintroduce.call(person2, 'Hi', '.'); // 'Hi, I'm Bob, 30 years old.'\n\n// APPLY - func.apply(thisArg, [argsArray])\n// Arguments passed as array\nintroduce.apply(person1, ['Hello', '!']); // 'Hello, I'm Alice, 25 years old!'\nintroduce.apply(person2, ['Hi', '.']); // 'Hi, I'm Bob, 30 years old.'\n\n// BIND - func.bind(thisArg, arg1, arg2, ...)\n// Returns NEW function, doesn't invoke immediately\nconst introduceAlice = introduce.bind(person1);\nintroduceAlice('Hey', '!!!'); // 'Hey, I'm Alice, 25 years old!!!'\n\nconst introduceBob = introduce.bind(person2, 'Greetings'); // Partial application\nintroduceBob('...'); // 'Greetings, I'm Bob, 30 years old...'\n\n// Use case 1: Borrowing methods\nconst nums1 = { data: [1, 2, 3] };\nconst nums2 = { data: [4, 5, 6] };\n\nfunction sum() {\n  return this.data.reduce((acc, n) => acc + n, 0);\n}\n\nconsole.log(sum.call(nums1)); // 6\nconsole.log(sum.call(nums2)); // 15\n\n// Use case 2: Array-like objects to arrays\nfunction showArgs() {\n  // arguments is array-like, not real array\n  console.log(arguments); // { 0: 'a', 1: 'b', 2: 'c', length: 3 }\n  \n  // Convert to real array using call\n  const argsArray = Array.prototype.slice.call(arguments);\n  console.log(argsArray); // ['a', 'b', 'c']\n  \n  // Modern way: spread or Array.from()\n  const args1 = [...arguments];\n  const args2 = Array.from(arguments);\n}\n\nshowArgs('a', 'b', 'c');\n\n// Use case 3: Finding max/min with apply\nconst numbers = [5, 6, 2, 3, 7, 1, 9];\n\n// Math.max expects separate arguments, not array\nconst max = Math.max.apply(null, numbers);\nconsole.log(max); // 9\n\n// Modern way: spread\nconst max2 = Math.max(...numbers);\nconsole.log(max2); // 9\n\n// Use case 4: Function currying with bind\nfunction multiply(a, b) {\n  return a * b;\n}\n\nconst double = multiply.bind(null, 2); // Fix first argument\nconsole.log(double(5)); // 10\nconsole.log(double(10)); // 20\n\nconst triple = multiply.bind(null, 3);\nconsole.log(triple(5)); // 15\n\n// Use case 5: Event handlers\nclass Counter {\n  constructor() {\n    this.count = 0;\n    // Bind in constructor\n    this.increment = this.increment.bind(this);\n  }\n  \n  increment() {\n    this.count++;\n    console.log(`Count: ${this.count}`);\n  }\n}\n\nconst counter = new Counter();\n// In browser: button.addEventListener('click', counter.increment);\nsetTimeout(counter.increment, 1000); // Works because bound\n\n// Use case 6: Partial application\nfunction greet(greeting, name, punctuation) {\n  return `${greeting}, ${name}${punctuation}`;\n}\n\nconst sayHelloTo = greet.bind(null, 'Hello');\nconsole.log(sayHelloTo('Alice', '!')); // 'Hello, Alice!'\nconsole.log(sayHelloTo('Bob', '.')); // 'Hello, Bob.'\n\nconst sayHelloToAlice = greet.bind(null, 'Hello', 'Alice');\nconsole.log(sayHelloToAlice('!')); // 'Hello, Alice!'\n\n// Advanced: Implementing bind polyfill\nif (!Function.prototype.bind) {\n  Function.prototype.bind = function(context, ...boundArgs) {\n    const fn = this;\n    return function(...args) {\n      return fn.apply(context, [...boundArgs, ...args]);\n    };\n  };\n}\n\n// Implementing call polyfill\nFunction.prototype.myCall = function(context, ...args) {\n  context = context || globalThis;\n  const fnSymbol = Symbol();\n  context[fnSymbol] = this;\n  const result = context[fnSymbol](...args);\n  delete context[fnSymbol];\n  return result;\n};\n\n// Implementing apply polyfill\nFunction.prototype.myApply = function(context, args = []) {\n  return this.myCall(context, ...args);\n};\n\n// Testing custom implementations\nfunction test(a, b) {\n  console.log(`${this.name}: ${a + b}`);\n}\n\nconst obj = { name: 'Test' };\ntest.myCall(obj, 2, 3); // 'Test: 5'\ntest.myApply(obj, [2, 3]); // 'Test: 5'\n\n// Performance comparison\nconsole.time('call');\nfor (let i = 0; i < 1000000; i++) {\n  introduce.call(person1, 'Hi', '!');\n}\nconsole.timeEnd('call');\n\nconsole.time('apply');\nfor (let i = 0; i < 1000000; i++) {\n  introduce.apply(person1, ['Hi', '!']);\n}\nconsole.timeEnd('apply');\n\nconsole.time('bind');\nconst boundFunc = introduce.bind(person1, 'Hi', '!');\nfor (let i = 0; i < 1000000; i++) {\n  boundFunc();\n}\nconsole.timeEnd('bind');\n// Generally: call ≈ apply > bind (bind creates new function)"
        },
        {
          "type": "interview-tip",
          "tip": "call vs apply vs bind",
          "explanation": "SYNTAX:\n- call(thisArg, arg1, arg2, ...)\n- apply(thisArg, [arg1, arg2, ...])\n- bind(thisArg, arg1, arg2, ...) → returns function\n\nWHEN TO USE:\n- call: Invoke now, few arguments, know them upfront\n- apply: Invoke now, many arguments or have array (now use spread instead)\n- bind: Need function for later (callbacks, event handlers)\n\nMEMORY TIP:\n'A' for Apply = 'A' for Array\n\nMODERN ALTERNATIVES:\n- Spread operator replaces apply: func(...args)\n- Arrow functions replace bind for 'this': () => {}"
        },
        {
          "type": "title",
          "level": 2,
          "content": "Q3. What are closures? Provide practical examples?"
        },
        {
          "type": "description",
          "content": "A closure is a function that has access to variables from its outer (enclosing) scope, even after the outer function has returned. Closures remember the environment in which they were created. Used for data privacy, factory functions, callbacks, and maintaining state."
        },
        {
          "type": "code",
          "language": "javascript",
          "title": "Closures Examples",
          "code": "// Basic closure\nfunction outer() {\n  const message = 'Hello'; // outer scope variable\n  \n  function inner() {\n    console.log(message); // accesses outer variable\n  }\n  \n  return inner;\n}\n\nconst myFunc = outer(); // outer() has finished executing\nmyFunc(); // 'Hello' - still has access to 'message'!\n\n// Practical example 1: Data privacy (private variables)\nfunction createCounter() {\n  let count = 0; // private variable\n  \n  return {\n    increment() {\n      count++;\n      return count;\n    },\n    decrement() {\n      count--;\n      return count;\n    },\n    getCount() {\n      return count;\n    }\n  };\n}\n\nconst counter1 = createCounter();\nconsole.log(counter1.increment()); // 1\nconsole.log(counter1.increment()); // 2\nconsole.log(counter1.getCount()); // 2\nconsole.log(counter1.count); // undefined (private!)\n\nconst counter2 = createCounter(); // separate instance\nconsole.log(counter2.getCount()); // 0 (independent)\n\n// Practical example 2: Function factory\nfunction createMultiplier(multiplier) {\n  return function(number) {\n    return number * multiplier;\n  };\n}\n\nconst double = createMultiplier(2);\nconst triple = createMultiplier(3);\nconst quadruple = createMultiplier(4);\n\nconsole.log(double(5)); // 10\nconsole.log(triple(5)); // 15\nconsole.log(quadruple(5)); // 20\n\n// Practical example 3: Event handlers with private state\nfunction setupButton(buttonId) {\n  let clickCount = 0;\n  \n  const button = document.getElementById(buttonId);\n  button.addEventListener('click', function() {\n    clickCount++;\n    console.log(`Button clicked ${clickCount} times`);\n  });\n}\n\n// Each button maintains its own click count\nsetupButton('btn1');\nsetupButton('btn2');\n\n// Practical example 4: Memoization (caching)\nfunction memoize(fn) {\n  const cache = {}; // closure variable\n  \n  return function(...args) {\n    const key = JSON.stringify(args);\n    if (key in cache) {\n      console.log('Returning cached result');\n      return cache[key];\n    }\n    \n    console.log('Computing result');\n    const result = fn(...args);\n    cache[key] = result;\n    return result;\n  };\n}\n\nfunction slowFunction(n) {\n  // Simulate expensive computation\n  let result = 0;\n  for (let i = 0; i < n * 1000000; i++) {\n    result += i;\n  }\n  return result;\n}\n\nconst memoizedSlow = memoize(slowFunction);\nconsole.log(memoizedSlow(10)); // Computing... (slow)\nconsole.log(memoizedSlow(10)); // Cached! (instant)\n\n// Practical example 5: Module pattern\nconst bankAccount = (function() {\n  let balance = 0; // private\n  const transactions = []; // private\n  \n  return {\n    deposit(amount) {\n      if (amount > 0) {\n        balance += amount;\n        transactions.push({ type: 'deposit', amount, date: new Date() });\n        return balance;\n      }\n    },\n    \n    withdraw(amount) {\n      if (amount > 0 && amount <= balance) {\n        balance -= amount;\n        transactions.push({ type: 'withdraw', amount, date: new Date() });\n        return balance;\n      }\n      return 'Insufficient funds';\n    },\n    \n    getBalance() {\n      return balance;\n    },\n    \n    getTransactions() {\n      return [...transactions]; // return copy, not reference\n    }\n  };\n})(); // IIFE - immediately invoked\n\nbankAccount.deposit(1000);\nbankAccount.withdraw(500);\nconsole.log(bankAccount.getBalance()); // 500\nconsole.log(bankAccount.balance); // undefined (private)\n\n// Common mistake: Closures in loops\n// Wrong way (all buttons log 5)\nfor (var i = 0; i < 5; i++) {\n  setTimeout(function() {\n    console.log(i); // All log 5!\n  }, 1000);\n}\n\n// Solution 1: Use 'let' (block scope)\nfor (let i = 0; i < 5; i++) {\n  setTimeout(function() {\n    console.log(i); // 0, 1, 2, 3, 4\n  }, 1000);\n}\n\n// Solution 2: IIFE to capture value\nfor (var i = 0; i < 5; i++) {\n  (function(j) {\n    setTimeout(function() {\n      console.log(j); // 0, 1, 2, 3, 4\n    }, 1000);\n  })(i);\n}\n\n// Solution 3: bind\nfor (var i = 0; i < 5; i++) {\n  setTimeout(function(i) {\n    console.log(i);\n  }.bind(null, i), 1000);\n}\n\n// Advanced: Closure with multiple levels\nfunction outer1(x) {\n  return function middle(y) {\n    return function inner(z) {\n      return x + y + z;\n    };\n  };\n}\n\nconst step1 = outer1(1);\nconst step2 = step1(2);\nconst result = step2(3);\nconsole.log(result); // 6\n\n// Or in one line\nconsole.log(outer1(1)(2)(3)); // 6\n\n// Memory consideration\nfunction createHeavyClosures() {\n  const hugeArray = new Array(1000000).fill('data');\n  \n  return {\n    // Bad: keeps hugeArray in memory even if not needed\n    getFirst() {\n      return hugeArray[0];\n    },\n    \n    // Better: only keep what you need\n    getFirstOptimized: (function() {\n      const first = hugeArray[0];\n      return function() {\n        return first;\n      };\n    })()\n  };\n}"
        },
        {
          "type": "interview-tip",
          "tip": "Closures Key Concepts",
          "explanation": "WHAT IS A CLOSURE:\nFunction + its lexical environment (outer variables it can access)\n\nUSE CASES:\n1. Data privacy / encapsulation\n2. Factory functions\n3. Callbacks and event handlers\n4. Memoization / caching\n5. Module pattern\n6. Function currying\n\nIMPORTANT:\n- Inner function has access to outer scope even after outer returns\n- Each closure instance has its own scope\n- Be careful with loops (use let, IIFE, or bind)\n- Memory: closures keep referenced variables alive\n\nINTERVIEW QUESTION:\n'What variables does a closure have access to?'\n→ Own variables, outer function variables, global variables"
        },
        {
          "type": "title",
          "level": 2,
          "content": "Q4. What is currying? How to implement it?"
        },
        {
          "type": "description",
          "content": "Currying transforms a function with multiple arguments into a sequence of functions, each taking a single argument. Instead of f(a, b, c), you get f(a)(b)(c). Used for partial application, creating specialized functions, and functional programming patterns."
        },
        {
          "type": "code",
          "language": "javascript",
          "title": "Currying Examples",
          "code": "// Non-curried function\nfunction add(a, b, c) {\n  return a + b + c;\n}\nconsole.log(add(1, 2, 3)); // 6\n\n// Curried version\nfunction curriedAdd(a) {\n  return function(b) {\n    return function(c) {\n      return a + b + c;\n    };\n  };\n}\n\nconsole.log(curriedAdd(1)(2)(3)); // 6\n\n// Arrow function syntax (cleaner)\nconst curriedAddArrow = a => b => c => a + b + c;\nconsole.log(curriedAddArrow(1)(2)(3)); // 6\n\n// Practical use: Partial application\nconst add1 = curriedAdd(1); // fix first arg\nconst add1And2 = add1(2); // fix second arg\nconsole.log(add1And2(3)); // 6\nconsole.log(add1And2(10)); // 13\n\nconst add5 = curriedAdd(5);\nconsole.log(add5(3)(2)); // 10\n\n// Generic curry function - transforms any function\nfunction curry(fn) {\n  return function curried(...args) {\n    if (args.length >= fn.length) {\n      // All arguments provided\n      return fn.apply(this, args);\n    } else {\n      // Return function waiting for more arguments\n      return function(...nextArgs) {\n        return curried.apply(this, [...args, ...nextArgs]);\n      };\n    }\n  };\n}\n\n// Using curry helper\nfunction multiply(a, b, c) {\n  return a * b * c;\n}\n\nconst curriedMultiply = curry(multiply);\n\n// All these work:\nconsole.log(curriedMultiply(2)(3)(4)); // 24\nconsole.log(curriedMultiply(2, 3)(4)); // 24\nconsole.log(curriedMultiply(2)(3, 4)); // 24\nconsole.log(curriedMultiply(2, 3, 4)); // 24\n\n// Practical example 1: API request builder\nconst makeRequest = curry((method, url, data) => {\n  return fetch(url, {\n    method,\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify(data)\n  });\n});\n\nconst get = makeRequest('GET');\nconst post = makeRequest('POST');\nconst put = makeRequest('PUT');\n\n// Specialized functions\nconst getUsersAPI = get('/api/users');\nconst createUserAPI = post('/api/users');\n\n// Usage\ngetUsersAPI(null).then(res => res.json());\ncreateUserAPI({ name: 'Alice' }).then(res => res.json());\n\n// Practical example 2: Validation\nconst validate = curry((regex, message, value) => {\n  return regex.test(value) ? null : message;\n});\n\nconst validateEmail = validate(\n  /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/,\n  'Invalid email'\n);\n\nconst validatePhone = validate(\n  /^\\d{10}$/,\n  'Phone must be 10 digits'\n);\n\nconsole.log(validateEmail('test@example.com')); // null (valid)\nconsole.log(validateEmail('invalid')); // 'Invalid email'\nconsole.log(validatePhone('1234567890')); // null (valid)\nconsole.log(validatePhone('123')); // 'Phone must be 10 digits'\n\n// Practical example 3: Logging with context\nconst log = curry((level, context, message) => {\n  console.log(`[${level}] [${context}] ${message}`);\n});\n\nconst debugLog = log('DEBUG');\nconst infoLog = log('INFO');\nconst errorLog = log('ERROR');\n\nconst dbDebug = debugLog('Database');\nconst apiInfo = infoLog('API');\n\ndbDebug('Connection established');\ndbDebug('Query executed');\napiInfo('Request received');\nerrorLog('Auth')('Invalid token');\n\n// Practical example 4: Discount calculator\nconst calculatePrice = curry((tax, discount, price) => {\n  const afterDiscount = price * (1 - discount);\n  return afterDiscount * (1 + tax);\n});\n\nconst usPrice = calculatePrice(0.08); // 8% tax\nconst euPrice = calculatePrice(0.20); // 20% tax\n\nconst usSale = usPrice(0.10); // 10% discount\nconst usClearance = usPrice(0.50); // 50% discount\n\nconsole.log(usSale(100)); // 100 * 0.9 * 1.08 = 97.2\nconsole.log(usClearance(100)); // 100 * 0.5 * 1.08 = 54\n\n// Advanced: Infinite currying (sum until no args)\nfunction infiniteAdd(a) {\n  let sum = a;\n  \n  function inner(b) {\n    if (b === undefined) {\n      return sum;\n    }\n    sum += b;\n    return inner;\n  }\n  \n  // Allow both call and toString\n  inner.valueOf = () => sum;\n  inner.toString = () => sum.toString();\n  \n  return inner;\n}\n\nconsole.log(infiniteAdd(1)(2)(3)(4)()); // 10\nconsole.log(+infiniteAdd(1)(2)(3)(4)); // 10 (using valueOf)\n\n// Practical example 5: Compose with curry\nconst map = curry((fn, arr) => arr.map(fn));\nconst filter = curry((fn, arr) => arr.filter(fn));\nconst reduce = curry((fn, init, arr) => arr.reduce(fn, init));\n\nconst numbers = [1, 2, 3, 4, 5];\n\nconst double = map(x => x * 2);\nconst onlyEven = filter(x => x % 2 === 0);\nconst sum = reduce((a, b) => a + b, 0);\n\nconsole.log(double(numbers)); // [2, 4, 6, 8, 10]\nconsole.log(onlyEven(numbers)); // [2, 4]\nconsole.log(sum(numbers)); // 15\n\n// Compose functions\nconst doubleEvenSum = arr => sum(onlyEven(double(arr)));\nconsole.log(doubleEvenSum([1, 2, 3, 4, 5])); // 12 (4 + 8)\n\n// Curry vs Partial application\n// Partial: fix some arguments, get function expecting rest\nconst partial = (fn, ...fixedArgs) => {\n  return (...remainingArgs) => {\n    return fn(...fixedArgs, ...remainingArgs);\n  };\n};\n\nfunction greet(greeting, name, punctuation) {\n  return `${greeting}, ${name}${punctuation}`;\n}\n\nconst sayHello = partial(greet, 'Hello'); // fix greeting\nconsole.log(sayHello('Alice', '!')); // 'Hello, Alice!'\nconsole.log(sayHello('Bob', '.')); // 'Hello, Bob.'\n\n// Curried version\nconst curriedGreet = curry(greet);\nconst curriedHello = curriedGreet('Hello');\nconsole.log(curriedHello('Alice')('!')); // 'Hello, Alice!'\n\n// Performance consideration\nfunction normalAdd(a, b, c) {\n  return a + b + c;\n}\n\nconst curriedAddFn = curry(normalAdd);\n\nconsole.time('normal');\nfor (let i = 0; i < 1000000; i++) {\n  normalAdd(1, 2, 3);\n}\nconsole.timeEnd('normal'); // Faster\n\nconsole.time('curried');\nfor (let i = 0; i < 1000000; i++) {\n  curriedAddFn(1)(2)(3);\n}\nconsole.timeEnd('curried'); // Slower (more function calls)"
        },
        {
          "type": "interview-tip",
          "tip": "Currying Key Points",
          "explanation": "DEFINITION:\nTransform f(a, b, c) → f(a)(b)(c)\n\nBENEFITS:\n1. Partial application - create specialized functions\n2. Function reusability\n3. Easier testing (test each step)\n4. Better composition\n5. Cleaner functional programming\n\nIMPLEMENTATION:\n- Manual: nested functions\n- Generic: curry() helper function\n- Arrow syntax: a => b => c => ...\n\nWHEN TO USE:\n- Configuration functions\n- Validation\n- API builders\n- Functional programming patterns\n\nCURRYING vs PARTIAL APPLICATION:\n- Curry: always one arg at a time\n- Partial: fix any number of args"
        },
        {
          "type": "title",
          "level": 2,
          "content": "Q5. What is memoization? Implement a memoize function?"
        },
        {
          "type": "description",
          "content": "Memoization is an optimization technique that caches function results based on inputs. When called with same arguments, returns cached result instead of recomputing. Useful for expensive computations, recursive functions (like Fibonacci), and API calls."
        },
        {
          "type": "code",
          "language": "javascript",
          "title": "Memoization Examples",
          "code": "// Basic memoization implementation\nfunction memoize(fn) {\n  const cache = {};\n  \n  return function(...args) {\n    const key = JSON.stringify(args);\n    \n    if (key in cache) {\n      console.log('Cache hit!');\n      return cache[key];\n    }\n    \n    console.log('Computing...');\n    const result = fn.apply(this, args);\n    cache[key] = result;\n    return result;\n  };\n}\n\n// Example 1: Expensive calculation\nfunction slowSquare(n) {\n  // Simulate expensive operation\n  let result = 0;\n  for (let i = 0; i < 1000000000; i++) {\n    result = n * n;\n  }\n  return result;\n}\n\nconst memoizedSquare = memoize(slowSquare);\n\nconsole.time('first call');\nconsole.log(memoizedSquare(5)); // Computing... 25 (slow)\nconsole.timeEnd('first call');\n\nconsole.time('second call');\nconsole.log(memoizedSquare(5)); // Cache hit! 25 (instant)\nconsole.timeEnd('second call');\n\n// Example 2: Fibonacci (classic use case)\n// Without memoization - exponential time O(2^n)\nfunction fib(n) {\n  if (n <= 1) return n;\n  return fib(n - 1) + fib(n - 2);\n}\n\nconsole.time('fib(40) without memoization');\nconsole.log(fib(40)); // Very slow!\nconsole.timeEnd('fib(40) without memoization');\n\n// With memoization - linear time O(n)\nconst memoizedFib = memoize(function fib(n) {\n  if (n <= 1) return n;\n  return memoizedFib(n - 1) + memoizedFib(n - 2);\n});\n\nconsole.time('fib(40) with memoization');\nconsole.log(memoizedFib(40)); // Fast!\nconsole.timeEnd('fib(40) with memoization');\n\n// Advanced: Memoization with Map (better than object)\nfunction memoizeWithMap(fn) {\n  const cache = new Map();\n  \n  return function(...args) {\n    const key = JSON.stringify(args);\n    \n    if (cache.has(key)) {\n      return cache.get(key);\n    }\n    \n    const result = fn.apply(this, args);\n    cache.set(key, result);\n    return result;\n  };\n}\n\n// Advanced: Memoization with TTL (time-to-live)\nfunction memoizeWithTTL(fn, ttl = 5000) {\n  const cache = new Map();\n  \n  return function(...args) {\n    const key = JSON.stringify(args);\n    const cached = cache.get(key);\n    \n    if (cached && Date.now() - cached.timestamp < ttl) {\n      console.log('Cache hit (within TTL)');\n      return cached.value;\n    }\n    \n    console.log('Computing or cache expired');\n    const result = fn.apply(this, args);\n    cache.set(key, { value: result, timestamp: Date.now() });\n    return result;\n  };\n}\n\nconst apiCall = memoizeWithTTL(function(userId) {\n  return fetch(`/api/users/${userId}`).then(r => r.json());\n}, 60000); // Cache for 1 minute\n\n// Advanced: Memoization with max size (LRU-like)\nfunction memoizeWithMaxSize(fn, maxSize = 100) {\n  const cache = new Map();\n  \n  return function(...args) {\n    const key = JSON.stringify(args);\n    \n    if (cache.has(key)) {\n      const value = cache.get(key);\n      // Move to end (most recently used)\n      cache.delete(key);\n      cache.set(key, value);\n      return value;\n    }\n    \n    const result = fn.apply(this, args);\n    \n    // Remove oldest if at max size\n    if (cache.size >= maxSize) {\n      const firstKey = cache.keys().next().value;\n      cache.delete(firstKey);\n    }\n    \n    cache.set(key, result);\n    return result;\n  };\n}\n\n// Practical example 1: API response caching\nfunction createCachedFetch() {\n  const cache = new Map();\n  \n  return async function cachedFetch(url, options = {}) {\n    const cacheKey = url + JSON.stringify(options);\n    \n    if (cache.has(cacheKey)) {\n      console.log('Returning cached response');\n      return cache.get(cacheKey);\n    }\n    \n    console.log('Fetching from network');\n    const response = await fetch(url, options);\n    const data = await response.json();\n    cache.set(cacheKey, data);\n    return data;\n  };\n}\n\nconst cachedFetch = createCachedFetch();\n\n// First call hits network, subsequent calls use cache\nawait cachedFetch('/api/users');\nawait cachedFetch('/api/users'); // Cached!\n\n// Practical example 2: Memoized factorial\nconst factorial = memoize(function fact(n) {\n  if (n <= 1) return 1;\n  return n * factorial(n - 1);\n});\n\nconsole.log(factorial(5)); // 120 (computes 5, 4, 3, 2, 1)\nconsole.log(factorial(6)); // 720 (only computes 6, rest cached!)\n\n// Practical example 3: Memoized prime checker\nconst isPrime = memoize(function(num) {\n  if (num < 2) return false;\n  for (let i = 2; i <= Math.sqrt(num); i++) {\n    if (num % i === 0) return false;\n  }\n  return true;\n});\n\nconsole.log(isPrime(17)); // Computing... true\nconsole.log(isPrime(17)); // Cache hit! true\n\n// React-style useMemo simulation\nfunction useMemoSimulation(fn, dependencies) {\n  // In real React, this uses internal state\n  // This is just a conceptual example\n  if (!useMemoSimulation.cache) {\n    useMemoSimulation.cache = {};\n  }\n  \n  const key = JSON.stringify(dependencies);\n  \n  if (key in useMemoSimulation.cache) {\n    return useMemoSimulation.cache[key];\n  }\n  \n  const result = fn();\n  useMemoSimulation.cache[key] = result;\n  return result;\n}\n\n// Memoization pitfalls\n\n// Pitfall 1: Mutating cached objects\nconst getUser = memoize(id => ({ id, name: 'User' + id }));\nconst user1 = getUser(1);\nuser1.name = 'Modified'; // Mutates cached object!\nconst user2 = getUser(1); // Returns mutated object\nconsole.log(user2.name); // 'Modified' (unexpected!)\n\n// Solution: Deep clone or return new object\nconst getUserSafe = memoize(id => {\n  return { id, name: 'User' + id };\n});\n// Or use Object.freeze() on cached values\n\n// Pitfall 2: Memory leaks with large cache\nconst memoizedWithLeak = memoize(x => x * 2);\nfor (let i = 0; i < 1000000; i++) {\n  memoizedWithLeak(i); // Cache grows indefinitely!\n}\n\n// Solution: Use memoizeWithMaxSize or WeakMap for objects\n\n// Pitfall 3: Reference types as arguments\nconst memoizedFunc = memoize(obj => obj.value * 2);\nconst obj1 = { value: 5 };\nconst obj2 = { value: 5 };\n\nmemoizedFunc(obj1); // Computing...\nmemoizedFunc(obj2); // Computing... (different object reference!)\n\n// Lodash-style memoize with custom resolver\nfunction memoizeWithResolver(fn, resolver) {\n  const cache = new Map();\n  \n  return function(...args) {\n    const key = resolver ? resolver.apply(this, args) : args[0];\n    \n    if (cache.has(key)) {\n      return cache.get(key);\n    }\n    \n    const result = fn.apply(this, args);\n    cache.set(key, result);\n    return result;\n  };\n}\n\n// Custom key resolver for objects\nconst memoizedObjFunc = memoizeWithResolver(\n  obj => obj.value * 2,\n  obj => obj.value // Use value property as key\n);\n\nmemoizedObjFunc({ value: 5 }); // Computing...\nmemoizedObjFunc({ value: 5 }); // Cache hit! (same value)\n\n// Clear cache utility\nfunction memoizeWithClear(fn) {\n  const cache = new Map();\n  \n  const memoized = function(...args) {\n    const key = JSON.stringify(args);\n    \n    if (cache.has(key)) {\n      return cache.get(key);\n    }\n    \n    const result = fn.apply(this, args);\n    cache.set(key, result);\n    return result;\n  };\n  \n  memoized.clear = () => cache.clear();\n  memoized.delete = (...args) => cache.delete(JSON.stringify(args));\n  memoized.has = (...args) => cache.has(JSON.stringify(args));\n  \n  return memoized;\n}\n\nconst memoizedWithClear = memoizeWithClear(x => x * 2);\nmemoizedWithClear(5); // Computing...\nmemoizedWithClear(5); // Cache hit\nmemoizedWithClear.clear(); // Clear all cache\nmemoizedWithClear(5); // Computing... (cache was cleared)"
        },
        {
          "type": "interview-tip",
          "tip": "Memoization Best Practices",
          "explanation": "WHEN TO USE:\n- Expensive pure functions (same input → same output)\n- Recursive algorithms (Fibonacci, factorial)\n- API calls with same parameters\n- Complex calculations in React components\n\nWHEN NOT TO USE:\n- Functions with side effects\n- Functions that return different values for same input\n- Very cheap computations (overhead not worth it)\n- Infinite possible inputs (memory leak)\n\nCONSIDERATIONS:\n1. Key generation (JSON.stringify limitations)\n2. Memory usage (cache size limits)\n3. Cache invalidation (TTL, max size)\n4. Reference types as arguments\n5. Mutable objects (clone or freeze)\n\nLIBRARIES:\n- lodash.memoize\n- memoizee\n- React.memo, useMemo, useCallback"
        }
      ]
    },
    {
      "id": "section-5",
      "title": "JavaScript - Promises & Async",
      "blocks": [
        {
          "type": "title",
          "level": 2,
          "content": "Q1. Explain Promises and their states? How do they work?"
        },
        {
          "type": "description",
          "content": "A Promise represents the eventual completion or failure of an asynchronous operation. It has three states: Pending (initial), Fulfilled (success), Rejected (failure). Once settled (fulfilled or rejected), a promise cannot change state. Promises provide .then(), .catch(), and .finally() methods for handling results."
        },
        {
          "type": "code",
          "language": "javascript",
          "title": "Promises Examples",
          "code": "// Creating a Promise\nconst promise = new Promise((resolve, reject) => {\n  // Asynchronous operation\n  const success = true;\n  \n  setTimeout(() => {\n    if (success) {\n      resolve('Operation successful!'); // Fulfilled\n    } else {\n      reject('Operation failed!'); // Rejected\n    }\n  }, 1000);\n});\n\n// Consuming a Promise\npromise\n  .then(result => {\n    console.log(result); // 'Operation successful!'\n    return 'Next step';\n  })\n  .then(result => {\n    console.log(result); // 'Next step'\n  })\n  .catch(error => {\n    console.error(error); // Handles rejection\n  })\n  .finally(() => {\n    console.log('Cleanup'); // Always runs\n  });\n\n// Promise states\nconst pending = new Promise(() => {}); // Never resolves\nconst fulfilled = Promise.resolve('Success');\nconst rejected = Promise.reject('Error');\n\nconsole.log(pending); // Promise { <pending> }\nconsole.log(fulfilled); // Promise { 'Success' }\nconsole.log(rejected); // Promise { <rejected> 'Error' }\n\n// Practical example: API call\nfunction fetchUser(userId) {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      if (userId > 0) {\n        resolve({ id: userId, name: `User ${userId}` });\n      } else {\n        reject(new Error('Invalid user ID'));\n      }\n    }, 1000);\n  });\n}\n\nfetchUser(1)\n  .then(user => console.log(user)) // { id: 1, name: 'User 1' }\n  .catch(error => console.error(error.message));\n\n// Chaining promises\nfunction step1() {\n  return Promise.resolve('Step 1 complete');\n}\n\nfunction step2(prevResult) {\n  return new Promise(resolve => {\n    setTimeout(() => resolve(`${prevResult} -> Step 2 complete`), 500);\n  });\n}\n\nfunction step3(prevResult) {\n  return Promise.resolve(`${prevResult} -> Step 3 complete`);\n}\n\nstep1()\n  .then(result1 => step2(result1))\n  .then(result2 => step3(result2))\n  .then(final => console.log(final))\n  // 'Step 1 complete -> Step 2 complete -> Step 3 complete'\n  .catch(error => console.error('Pipeline failed:', error));\n\n// Promise.all - Wait for all promises (parallel)\nconst promise1 = Promise.resolve(1);\nconst promise2 = new Promise(resolve => setTimeout(() => resolve(2), 100));\nconst promise3 = Promise.resolve(3);\n\nPromise.all([promise1, promise2, promise3])\n  .then(results => console.log(results)) // [1, 2, 3]\n  .catch(error => console.error('One failed:', error));\n\n// If any fails, all fails\nPromise.all([\n  Promise.resolve(1),\n  Promise.reject('Error!'),\n  Promise.resolve(3)\n])\n  .then(results => console.log(results)) // Won't run\n  .catch(error => console.error(error)); // 'Error!'\n\n// Promise.allSettled - Wait for all, regardless of outcome (ES2020)\nPromise.allSettled([\n  Promise.resolve(1),\n  Promise.reject('Error!'),\n  Promise.resolve(3)\n])\n  .then(results => console.log(results));\n// [\n//   { status: 'fulfilled', value: 1 },\n//   { status: 'rejected', reason: 'Error!' },\n//   { status: 'fulfilled', value: 3 }\n// ]\n\n// Promise.race - First to settle wins\nPromise.race([\n  new Promise(resolve => setTimeout(() => resolve('slow'), 1000)),\n  new Promise(resolve => setTimeout(() => resolve('fast'), 100))\n])\n  .then(result => console.log(result)); // 'fast'\n\n// Promise.any - First to fulfill wins (ES2021)\nPromise.any([\n  Promise.reject('Error 1'),\n  new Promise(resolve => setTimeout(() => resolve('Success'), 100)),\n  Promise.reject('Error 2')\n])\n  .then(result => console.log(result)) // 'Success'\n  .catch(error => console.error(error)); // AggregateError if all reject\n\n// Error handling: propagation\nPromise.resolve(1)\n  .then(x => {\n    throw new Error('Oops!');\n  })\n  .then(x => console.log('Skipped')) // Skipped!\n  .catch(error => {\n    console.error('Caught:', error.message); // 'Caught: Oops!'\n    return 'Recovered';\n  })\n  .then(x => console.log(x)); // 'Recovered'\n\n// Returning promises from .then()\nfunction getUser(id) {\n  return fetch(`/api/users/${id}`).then(r => r.json());\n}\n\nfunction getPosts(userId) {\n  return fetch(`/api/posts?user=${userId}`).then(r => r.json());\n}\n\ngetUser(1)\n  .then(user => {\n    console.log('User:', user);\n    return getPosts(user.id); // Return promise!\n  })\n  .then(posts => console.log('Posts:', posts))\n  .catch(error => console.error(error));\n\n// vs nested promises (callback hell)\ngetUser(1).then(user => {\n  getPosts(user.id).then(posts => {\n    // Hard to manage!\n  });\n});\n\n// Implementing Promise.all manually\nfunction promiseAll(promises) {\n  return new Promise((resolve, reject) => {\n    if (!Array.isArray(promises)) {\n      return reject(new TypeError('Argument must be an array'));\n    }\n    \n    const results = [];\n    let completed = 0;\n    \n    if (promises.length === 0) {\n      return resolve(results);\n    }\n    \n    promises.forEach((promise, index) => {\n      Promise.resolve(promise)\n        .then(value => {\n          results[index] = value;\n          completed++;\n          \n          if (completed === promises.length) {\n            resolve(results);\n          }\n        })\n        .catch(reject); // Reject on first error\n    });\n  });\n}\n\n// Promise with timeout\nfunction withTimeout(promise, ms) {\n  const timeout = new Promise((_, reject) => {\n    setTimeout(() => reject(new Error('Timeout')), ms);\n  });\n  \n  return Promise.race([promise, timeout]);\n}\n\nconst slowPromise = new Promise(resolve => {\n  setTimeout(() => resolve('Done'), 5000);\n});\n\nwithTimeout(slowPromise, 2000)\n  .then(result => console.log(result))\n  .catch(error => console.error(error.message)); // 'Timeout'\n\n// Retry mechanism\nfunction retry(fn, maxAttempts = 3, delay = 1000) {\n  return new Promise((resolve, reject) => {\n    function attempt(attemptNumber) {\n      fn()\n        .then(resolve)\n        .catch(error => {\n          if (attemptNumber >= maxAttempts) {\n            reject(error);\n          } else {\n            console.log(`Attempt ${attemptNumber} failed, retrying...`);\n            setTimeout(() => attempt(attemptNumber + 1), delay);\n          }\n        });\n    }\n    \n    attempt(1);\n  });\n}\n\nretry(() => fetch('/api/data'), 3, 1000)\n  .then(response => response.json())\n  .catch(error => console.error('All attempts failed'));"
        },
        {
          "type": "interview-tip",
          "tip": "Promises Key Points",
          "explanation": "STATES:\n- Pending → initial state\n- Fulfilled → operation succeeded (resolve())\n- Rejected → operation failed (reject())\n- Once settled, cannot change\n\nMETHODS:\n- .then(onFulfilled, onRejected)\n- .catch(onRejected) - sugar for .then(null, onRejected)\n- .finally(onFinally) - always runs\n\nSTATIC METHODS:\n- Promise.all() - all must succeed, parallel execution\n- Promise.allSettled() - wait for all, get all results\n- Promise.race() - first to settle wins\n- Promise.any() - first to fulfill wins\n- Promise.resolve/reject() - create settled promises\n\nBEST PRACTICES:\n- Always handle errors (.catch)\n- Return promises in .then() for chaining\n- Avoid nesting (use chaining)"
        },
        {
          "type": "title",
          "level": 2,
          "content": "Q2. What is async/await? How is it different from Promises?"
        },
        {
          "type": "description",
          "content": "async/await is syntactic sugar over Promises, making asynchronous code look and behave more like synchronous code. 'async' keyword makes a function return a Promise. 'await' keyword pauses execution until Promise settles. Improves readability and error handling with try/catch."
        },
        {
          "type": "code",
          "language": "javascript",
          "title": "async/await Examples",
          "code": "// Basic async function\nasync function fetchData() {\n  return 'Data'; // Automatically wrapped in Promise.resolve()\n}\n\nfetchData().then(data => console.log(data)); // 'Data'\n\n// async function always returns a Promise\nasync function example() {\n  return 42;\n}\n\nconsole.log(example()); // Promise { 42 }\n\n// await keyword (only works inside async functions)\nasync function getData() {\n  const response = await fetch('/api/data');\n  const data = await response.json();\n  return data;\n}\n\n// Error handling with try/catch\nasync function fetchUserSafe(id) {\n  try {\n    const response = await fetch(`/api/users/${id}`);\n    \n    if (!response.ok) {\n      throw new Error(`HTTP error! status: ${response.status}`);\n    }\n    \n    const user = await response.json();\n    return user;\n  } catch (error) {\n    console.error('Failed to fetch user:', error);\n    throw error; // Re-throw if needed\n  }\n}\n\n// Comparison: Promises vs async/await\n\n// With Promises (chaining)\nfunction getUserPosts_Promise(userId) {\n  return fetch(`/api/users/${userId}`)\n    .then(response => response.json())\n    .then(user => {\n      console.log('User:', user.name);\n      return fetch(`/api/posts?userId=${userId}`);\n    })\n    .then(response => response.json())\n    .then(posts => {\n      console.log('Posts:', posts.length);\n      return posts;\n    })\n    .catch(error => {\n      console.error('Error:', error);\n      throw error;\n    });\n}\n\n// With async/await (cleaner)\nasync function getUserPosts_Async(userId) {\n  try {\n    const userResponse = await fetch(`/api/users/${userId}`);\n    const user = await userResponse.json();\n    console.log('User:', user.name);\n    \n    const postsResponse = await fetch(`/api/posts?userId=${userId}`);\n    const posts = await postsResponse.json();\n    console.log('Posts:', posts.length);\n    \n    return posts;\n  } catch (error) {\n    console.error('Error:', error);\n    throw error;\n  }\n}\n\n// Parallel execution with Promise.all\nasync function fetchMultipleUsers(ids) {\n  // Sequential (slow - one after another)\n  const users1 = [];\n  for (const id of ids) {\n    const user = await fetchUser(id); // Waits for each!\n    users1.push(user);\n  }\n  \n  // Parallel (fast - all at once)\n  const promises = ids.map(id => fetchUser(id));\n  const users2 = await Promise.all(promises);\n  \n  return users2;\n}\n\n// Real-world example: Multiple API calls\nasync function getDashboardData(userId) {\n  try {\n    // Parallel execution\n    const [user, posts, comments, notifications] = await Promise.all([\n      fetch(`/api/users/${userId}`).then(r => r.json()),\n      fetch(`/api/posts?userId=${userId}`).then(r => r.json()),\n      fetch(`/api/comments?userId=${userId}`).then(r => r.json()),\n      fetch(`/api/notifications?userId=${userId}`).then(r => r.json())\n    ]);\n    \n    return { user, posts, comments, notifications };\n  } catch (error) {\n    console.error('Dashboard data fetch failed:', error);\n    throw error;\n  }\n}\n\n// await with Promise.race\nasync function fetchWithTimeout(url, timeout = 5000) {\n  const controller = new AbortController();\n  const timeoutId = setTimeout(() => controller.abort(), timeout);\n  \n  try {\n    const response = await fetch(url, { signal: controller.signal });\n    clearTimeout(timeoutId);\n    return await response.json();\n  } catch (error) {\n    if (error.name === 'AbortError') {\n      throw new Error('Request timeout');\n    }\n    throw error;\n  }\n}\n\n// Top-level await (ES2022, module only)\n// In module files:\n// const data = await fetch('/api/config').then(r => r.json());\n// console.log(data);\n\n// IIFE for top-level await in non-module\n(async () => {\n  const data = await fetch('/api/config').then(r => r.json());\n  console.log(data);\n})();\n\n// Error handling patterns\n\n// Pattern 1: try/catch per operation\nasync function pattern1() {\n  let user, posts;\n  \n  try {\n    user = await fetchUser(1);\n  } catch (error) {\n    console.error('User fetch failed:', error);\n    user = null;\n  }\n  \n  try {\n    posts = await fetchPosts(1);\n  } catch (error) {\n    console.error('Posts fetch failed:', error);\n    posts = [];\n  }\n  \n  return { user, posts };\n}\n\n// Pattern 2: Single try/catch\nasync function pattern2() {\n  try {\n    const user = await fetchUser(1);\n    const posts = await fetchPosts(1);\n    return { user, posts };\n  } catch (error) {\n    console.error('Operation failed:', error);\n    return { user: null, posts: [] };\n  }\n}\n\n// Pattern 3: Promise-style error handling\nasync function pattern3() {\n  const user = await fetchUser(1).catch(err => null);\n  const posts = await fetchPosts(1).catch(err => []);\n  return { user, posts };\n}\n\n// Returning from async function\nasync function returnExample() {\n  return 'value'; // Returns Promise.resolve('value')\n}\n\nasync function returnPromise() {\n  return Promise.resolve('value'); // Same as above (unwrapped)\n}\n\nasync function throwError() {\n  throw new Error('Oops'); // Returns Promise.reject(Error)\n}\n\n// await in loops\n\n// Sequential processing\nasync function processSequential(items) {\n  const results = [];\n  \n  for (const item of items) {\n    const result = await processItem(item); // One at a time\n    results.push(result);\n  }\n  \n  return results;\n}\n\n// Parallel processing\nasync function processParallel(items) {\n  const promises = items.map(item => processItem(item));\n  return await Promise.all(promises); // All at once\n}\n\n// Controlled concurrency\nasync function processBatch(items, batchSize = 3) {\n  const results = [];\n  \n  for (let i = 0; i < items.length; i += batchSize) {\n    const batch = items.slice(i, i + batchSize);\n    const batchResults = await Promise.all(\n      batch.map(item => processItem(item))\n    );\n    results.push(...batchResults);\n  }\n  \n  return results;\n}\n\n// Common mistakes\n\n// Mistake 1: Forgetting await\nasync function mistake1() {\n  const data = fetchData(); // Forgot await! Returns Promise\n  console.log(data); // Promise { <pending> }\n}\n\n// Mistake 2: Using await in non-async function\nfunction mistake2() {\n  const data = await fetchData(); // SyntaxError!\n}\n\n// Mistake 3: Not handling errors\nasync function mistake3() {\n  const data = await fetchData(); // Unhandled rejection if fails!\n  return data;\n}\n\n// Mistake 4: Sequential when could be parallel\nasync function mistake4() {\n  const user = await fetchUser(1); // Wait\n  const posts = await fetchPosts(1); // Wait\n  // Should use Promise.all if independent!\n}\n\n// Correct version\nasync function correct4() {\n  const [user, posts] = await Promise.all([\n    fetchUser(1),\n    fetchPosts(1)\n  ]);\n}\n\n// Advanced: Async iteration\nasync function* asyncGenerator() {\n  yield await Promise.resolve(1);\n  yield await Promise.resolve(2);\n  yield await Promise.resolve(3);\n}\n\n(async () => {\n  for await (const value of asyncGenerator()) {\n    console.log(value); // 1, 2, 3\n  }\n})();\n\n// Practical: Retry with exponential backoff\nasync function retryWithBackoff(fn, maxRetries = 3) {\n  for (let i = 0; i < maxRetries; i++) {\n    try {\n      return await fn();\n    } catch (error) {\n      if (i === maxRetries - 1) throw error;\n      \n      const delay = Math.pow(2, i) * 1000; // 1s, 2s, 4s\n      console.log(`Retry ${i + 1} after ${delay}ms`);\n      await new Promise(resolve => setTimeout(resolve, delay));\n    }\n  }\n}\n\nretryWithBackoff(() => fetch('/api/data'))\n  .then(response => response.json())\n  .catch(error => console.error('All retries failed'));"
        },
        {
          "type": "interview-tip",
          "tip": "async/await vs Promises",
          "explanation": "ASYNC/AWAIT BENEFITS:\n- More readable (looks synchronous)\n- Better error handling (try/catch)\n- Easier debugging (better stack traces)\n- Less nesting\n\nKEY RULES:\n- async function always returns Promise\n- await only works in async functions (or top-level in modules)\n- await pauses execution until Promise settles\n- Thrown errors become rejected Promises\n\nCOMMON PATTERNS:\n- Promise.all() for parallel execution\n- try/catch for error handling\n- .catch() for individual error handling\n\nPERFORMANCE:\n- Use Promise.all() for independent operations\n- Avoid sequential awaits when parallel is possible\n\nWHEN TO USE PROMISES:\n- Complex chaining logic\n- Multiple catch blocks\n- Promise utilities (race, any)"
        },
        {
          "type": "title",
          "level": 2,
          "content": "Q3. What is Promise chaining? How to handle errors in chains?"
        },
        {
          "type": "description",
          "content": "Promise chaining connects multiple asynchronous operations by returning promises from .then() handlers. Each .then() returns a new promise, allowing sequential async operations. Errors propagate down the chain until caught. .catch() handles errors, and .finally() runs regardless of outcome."
        },
        {
          "type": "code",
          "language": "javascript",
          "title": "Promise Chaining Examples",
          "code": "// Basic chaining\nPromise.resolve(1)\n  .then(x => x + 1)      // 2\n  .then(x => x * 2)      // 4\n  .then(x => x - 1)      // 3\n  .then(result => console.log(result)); // 3\n\n// Chaining with async operations\nfetch('/api/user/1')\n  .then(response => {\n    console.log('Got response');\n    return response.json(); // Returns promise!\n  })\n  .then(user => {\n    console.log('User:', user.name);\n    return fetch(`/api/posts?userId=${user.id}`);\n  })\n  .then(response => response.json())\n  .then(posts => {\n    console.log('Posts:', posts.length);\n    return posts;\n  })\n  .catch(error => console.error('Error:', error));\n\n// Error propagation\nPromise.resolve(1)\n  .then(x => {\n    throw new Error('Oops!'); // or return Promise.reject()\n  })\n  .then(x => {\n    console.log('Skipped!'); // Not executed\n    return x + 1;\n  })\n  .then(x => {\n    console.log('Also skipped!'); // Not executed\n    return x * 2;\n  })\n  .catch(error => {\n    console.error('Caught:', error.message); // 'Caught: Oops!'\n    return 'recovered'; // Can recover!\n  })\n  .then(x => {\n    console.log('Continues:', x); // 'Continues: recovered'\n  });\n\n// Multiple catch handlers\nPromise.resolve(1)\n  .then(x => {\n    throw new Error('Error 1');\n  })\n  .catch(error => {\n    console.error('First catch:', error.message);\n    throw new Error('Error 2'); // Re-throw or new error\n  })\n  .catch(error => {\n    console.error('Second catch:', error.message);\n    return 'final';\n  })\n  .then(x => console.log('Final:', x)); // 'Final: final'\n\n// .finally() always runs\nfetch('/api/data')\n  .then(response => response.json())\n  .then(data => processData(data))\n  .catch(error => console.error(error))\n  .finally(() => {\n    console.log('Cleanup'); // Always runs\n    // Good for: hiding spinners, closing connections, etc.\n  });\n\n// Real-world: User authentication flow\nfunction authenticateUser(credentials) {\n  return fetch('/api/login', {\n    method: 'POST',\n    body: JSON.stringify(credentials)\n  })\n    .then(response => {\n      if (!response.ok) {\n        throw new Error('Authentication failed');\n      }\n      return response.json();\n    })\n    .then(data => {\n      localStorage.setItem('token', data.token);\n      return data.user;\n    })\n    .then(user => {\n      return fetch(`/api/users/${user.id}/profile`);\n    })\n    .then(response => response.json())\n    .then(profile => {\n      console.log('Login successful:', profile);\n      return profile;\n    })\n    .catch(error => {\n      console.error('Login failed:', error);\n      localStorage.removeItem('token');\n      throw error;\n    })\n    .finally(() => {\n      console.log('Login attempt completed');\n    });\n}\n\n// Returning values vs promises\nPromise.resolve(1)\n  .then(x => x + 1)           // Returns value → wrapped in Promise.resolve()\n  .then(x => Promise.resolve(x * 2)) // Returns promise → chained directly\n  .then(x => {\n    // Both work the same!\n    console.log(x); // 4\n  });\n\n// Conditional chaining\nfunction processUser(userId, includeStats = false) {\n  let promise = fetch(`/api/users/${userId}`)\n    .then(r => r.json());\n  \n  if (includeStats) {\n    promise = promise\n      .then(user => {\n        return fetch(`/api/stats/${user.id}`);\n      })\n      .then(r => r.json());\n  }\n  \n  return promise;\n}\n\n// Error recovery patterns\n\n// Pattern 1: Default value on error\nfetch('/api/config')\n  .then(r => r.json())\n  .catch(error => {\n    console.warn('Using default config');\n    return { theme: 'light', lang: 'en' }; // Default\n  })\n  .then(config => applyConfig(config));\n\n// Pattern 2: Retry on error\nfunction fetchWithRetry(url, retries = 3) {\n  return fetch(url)\n    .then(r => r.json())\n    .catch(error => {\n      if (retries > 0) {\n        console.log(`Retrying... (${retries} left)`);\n        return fetchWithRetry(url, retries - 1);\n      }\n      throw error; // No more retries\n    });\n}\n\n// Pattern 3: Fallback chain\nfetch('/api/primary')\n  .catch(() => fetch('/api/backup1'))\n  .catch(() => fetch('/api/backup2'))\n  .catch(() => fetch('/api/backup3'))\n  .then(response => response.json())\n  .catch(() => {\n    console.error('All endpoints failed');\n    return null;\n  });\n\n// Advanced: Combining multiple chains\nfunction getFullUserData(userId) {\n  const userPromise = fetch(`/api/users/${userId}`)\n    .then(r => r.json());\n  \n  const postsPromise = userPromise\n    .then(user => fetch(`/api/posts?author=${user.id}`))\n    .then(r => r.json());\n  \n  const commentsPromise = userPromise\n    .then(user => fetch(`/api/comments?author=${user.id}`))\n    .then(r => r.json());\n  \n  return Promise.all([userPromise, postsPromise, commentsPromise])\n    .then(([user, posts, comments]) => ({\n      user,\n      posts,\n      comments\n    }));\n}\n\n// Error handling with Promise.all\nPromise.all([\n  fetch('/api/users').then(r => r.json()),\n  fetch('/api/posts').then(r => r.json()),\n  fetch('/api/comments').then(r => r.json())\n])\n  .then(([users, posts, comments]) => {\n    console.log('All succeeded');\n  })\n  .catch(error => {\n    console.error('At least one failed:', error);\n    // Can't tell which one failed!\n  });\n\n// Better: Individual error handling\nPromise.all([\n  fetch('/api/users').then(r => r.json()).catch(() => []),\n  fetch('/api/posts').then(r => r.json()).catch(() => []),\n  fetch('/api/comments').then(r => r.json()).catch(() => [])\n])\n  .then(([users, posts, comments]) => {\n    console.log('All completed (some may have failed)');\n    console.log({ users, posts, comments });\n  });\n\n// Or use allSettled\nPromise.allSettled([\n  fetch('/api/users').then(r => r.json()),\n  fetch('/api/posts').then(r => r.json()),\n  fetch('/api/comments').then(r => r.json())\n])\n  .then(results => {\n    const users = results[0].status === 'fulfilled' ? results[0].value : [];\n    const posts = results[1].status === 'fulfilled' ? results[1].value : [];\n    const comments = results[2].status === 'fulfilled' ? results[2].value : [];\n    console.log({ users, posts, comments });\n  });\n\n// Chaining with transformation\nfetch('/api/data')\n  .then(response => response.json())\n  .then(data => data.filter(item => item.active))\n  .then(activeItems => activeItems.map(item => item.name))\n  .then(names => names.sort())\n  .then(sortedNames => {\n    console.log('Active names:', sortedNames);\n    return sortedNames;\n  })\n  .catch(error => console.error(error));\n\n// Avoiding callback hell (pyramid of doom)\n\n// Bad: Nested promises\nfetch('/api/user/1')\n  .then(r1 => r1.json())\n  .then(user => {\n    fetch(`/api/posts?userId=${user.id}`)\n      .then(r2 => r2.json())\n      .then(posts => {\n        fetch(`/api/comments?postId=${posts[0].id}`)\n          .then(r3 => r3.json())\n          .then(comments => {\n            console.log(comments); // Deep nesting!\n          });\n      });\n  });\n\n// Good: Flat chain\nlet userId;\nfetch('/api/user/1')\n  .then(r => r.json())\n  .then(user => {\n    userId = user.id;\n    return fetch(`/api/posts?userId=${userId}`);\n  })\n  .then(r => r.json())\n  .then(posts => {\n    return fetch(`/api/comments?postId=${posts[0].id}`);\n  })\n  .then(r => r.json())\n  .then(comments => {\n    console.log(comments); // Flat!\n  })\n  .catch(error => console.error(error));\n\n// Even better: async/await\nasync function betterVersion() {\n  try {\n    const userRes = await fetch('/api/user/1');\n    const user = await userRes.json();\n    \n    const postsRes = await fetch(`/api/posts?userId=${user.id}`);\n    const posts = await postsRes.json();\n    \n    const commentsRes = await fetch(`/api/comments?postId=${posts[0].id}`);\n    const comments = await commentsRes.json();\n    \n    console.log(comments);\n  } catch (error) {\n    console.error(error);\n  }\n}"
        },
        {
          "type": "interview-tip",
          "tip": "Promise Chaining Best Practices",
          "explanation": "KEY CONCEPTS:\n- Each .then() returns new Promise\n- Return value/promise to chain\n- Errors skip to next .catch()\n- .finally() always executes\n\nERROR HANDLING:\n- Single .catch() at end for all errors\n- Multiple .catch() for different error types\n- Return default values in .catch() to recover\n- Use .catch() after individual promises in Promise.all()\n\nCOMMON MISTAKES:\n- Forgetting to return in .then()\n- Nesting promises (use flat chains)\n- Not handling errors\n- Creating unnecessary intermediate variables\n\nWHEN TO CHAIN:\n- Sequential dependencies\n- Data transformation pipelines\n- Multi-step async operations\n\nALTERNATIVES:\n- async/await for better readability\n- Promise.all() for parallel operations"
        },
        {
          "type": "title",
          "level": 2,
          "content": "Q4. What is the microtask queue? How do Promises relate to the event loop?"
        },
        {
          "type": "description",
          "content": "The microtask queue (or job queue) handles Promise callbacks, with higher priority than the regular task queue (macrotask queue). After each macrotask, all microtasks are executed before the next macrotask. Promise .then/.catch/.finally callbacks are microtasks, while setTimeout/setInterval are macrotasks."
        },
        {
          "type": "code",
          "language": "javascript",
          "title": "Microtask Queue Examples",
          "code": "// Event loop priorities: Microtasks > Macrotasks\n\nconsole.log('1: Synchronous');\n\nsetTimeout(() => {\n  console.log('2: Macrotask (setTimeout)');\n}, 0);\n\nPromise.resolve().then(() => {\n  console.log('3: Microtask (Promise)');\n});\n\nconsole.log('4: Synchronous');\n\n// Output:\n// 1: Synchronous\n// 4: Synchronous\n// 3: Microtask (Promise)  ← Runs before setTimeout!\n// 2: Macrotask (setTimeout)\n\n// Microtasks run BEFORE next macrotask\nconsole.log('Start');\n\nsetTimeout(() => console.log('setTimeout 1'), 0);\n\nPromise.resolve()\n  .then(() => console.log('Promise 1'))\n  .then(() => console.log('Promise 2'));\n\nsetTimeout(() => console.log('setTimeout 2'), 0);\n\nPromise.resolve().then(() => console.log('Promise 3'));\n\nconsole.log('End');\n\n// Output:\n// Start\n// End\n// Promise 1\n// Promise 2\n// Promise 3\n// setTimeout 1\n// setTimeout 2\n\n// Microtasks can create more microtasks\nPromise.resolve()\n  .then(() => {\n    console.log('Microtask 1');\n    return Promise.resolve();\n  })\n  .then(() => {\n    console.log('Microtask 2');\n  });\n\nsetTimeout(() => {\n  console.log('Macrotask');\n}, 0);\n\n// Output:\n// Microtask 1\n// Microtask 2\n// Macrotask\n\n// Infinite microtask loop (freezes browser!)\nfunction infiniteMicrotasks() {\n  Promise.resolve().then(() => {\n    console.log('Microtask');\n    infiniteMicrotasks(); // Creates another microtask\n  });\n}\n// infiniteMicrotasks(); // DON'T RUN - will freeze!\n\n// Event loop phases:\n// 1. Execute synchronous code\n// 2. Execute ALL microtasks\n// 3. Execute ONE macrotask\n// 4. Execute ALL microtasks (created by that macrotask)\n// 5. Render (if needed)\n// 6. Repeat from step 3\n\n// Microtasks vs Macrotasks\n\n// Macrotasks:\n// - setTimeout, setInterval\n// - setImmediate (Node.js)\n// - I/O operations\n// - UI rendering\n// - requestAnimationFrame (browser)\n\n// Microtasks:\n// - Promise.then/catch/finally\n// - queueMicrotask()\n// - MutationObserver (browser)\n// - process.nextTick (Node.js - even higher priority!)\n\n// Demonstration with all types\nconsole.log('Script start');\n\nsetTimeout(() => {\n  console.log('setTimeout');\n}, 0);\n\nPromise.resolve()\n  .then(() => {\n    console.log('Promise 1');\n  })\n  .then(() => {\n    console.log('Promise 2');\n  });\n\nqueueMicrotask(() => {\n  console.log('queueMicrotask');\n});\n\nconsole.log('Script end');\n\n// Output:\n// Script start\n// Script end\n// Promise 1\n// queueMicrotask\n// Promise 2\n// setTimeout\n\n// Complex example\nconsole.log('1');\n\nsetTimeout(() => console.log('2'), 0);\n\nPromise.resolve()\n  .then(() => console.log('3'))\n  .then(() => {\n    console.log('4');\n    setTimeout(() => console.log('5'), 0);\n  });\n\nsetTimeout(() => {\n  console.log('6');\n  Promise.resolve().then(() => console.log('7'));\n}, 0);\n\nPromise.resolve().then(() => console.log('8'));\n\nconsole.log('9');\n\n// Output:\n// 1, 9 (synchronous)\n// 3, 4, 8 (all microtasks)\n// 2 (first macrotask)\n// 6 (second macrotask)\n// 7 (microtask from macrotask 6)\n// 5 (third macrotask, queued from microtask 4)\n\n// Async/await and microtasks\nasync function example() {\n  console.log('1');\n  \n  await Promise.resolve();\n  // Everything after 'await' is like .then()\n  \n  console.log('2'); // This is a microtask\n}\n\nconsole.log('3');\nexample();\nconsole.log('4');\n\n// Output:\n// 3\n// 1\n// 4\n// 2 (microtask)\n\n// Equivalent to:\nfunction exampleWithPromise() {\n  console.log('1');\n  \n  Promise.resolve().then(() => {\n    console.log('2');\n  });\n}\n\n// Race conditions due to microtask timing\nlet data = { value: 0 };\n\nPromise.resolve().then(() => {\n  data.value = 1; // Runs before setTimeout\n});\n\nsetTimeout(() => {\n  console.log(data.value); // 1 (promise ran first)\n}, 0);\n\n// Practical: Batching updates\nclass StateManager {\n  constructor() {\n    this.state = {};\n    this.listeners = [];\n    this.pending = false;\n  }\n  \n  setState(updates) {\n    Object.assign(this.state, updates);\n    \n    if (!this.pending) {\n      this.pending = true;\n      // Use microtask to batch multiple setState calls\n      queueMicrotask(() => {\n        this.notifyListeners();\n        this.pending = false;\n      });\n    }\n  }\n  \n  notifyListeners() {\n    this.listeners.forEach(listener => listener(this.state));\n  }\n  \n  subscribe(listener) {\n    this.listeners.push(listener);\n  }\n}\n\nconst store = new StateManager();\nstore.subscribe(state => console.log('State:', state));\n\nstore.setState({ a: 1 });\nstore.setState({ b: 2 });\nstore.setState({ c: 3 });\n// Only triggers ONE notification (batched)!\n\n// Node.js: process.nextTick (runs BEFORE microtasks!)\n// In Node.js:\nprocess.nextTick(() => console.log('nextTick'));\nPromise.resolve().then(() => console.log('Promise'));\nsetTimeout(() => console.log('setTimeout'), 0);\n// Output: nextTick, Promise, setTimeout\n\n// Browser: MutationObserver (microtask)\nconst observer = new MutationObserver(() => {\n  console.log('DOM changed (microtask)');\n});\n\nconst element = document.createElement('div');\nobserver.observe(element, { attributes: true });\n\nelement.setAttribute('data-test', '1');\nconsole.log('After setAttribute');\n\n// Output:\n// After setAttribute\n// DOM changed (microtask)\n\n// Debugging event loop\nfunction logWithType(message, type) {\n  console.log(`[${type}] ${message}`);\n}\n\nlogWithType('Start', 'sync');\n\nsetTimeout(() => logWithType('Timeout 1', 'macro'), 0);\n\nPromise.resolve()\n  .then(() => logWithType('Promise 1', 'micro'))\n  .then(() => {\n    logWithType('Promise 2', 'micro');\n    setTimeout(() => logWithType('Timeout 2', 'macro'), 0);\n  });\n\nqueueMicrotask(() => logWithType('queueMicrotask', 'micro'));\n\nsetTimeout(() => {\n  logWithType('Timeout 3', 'macro');\n  Promise.resolve().then(() => logWithType('Promise 3', 'micro'));\n}, 0);\n\nlogWithType('End', 'sync');\n\n// Visualizing the queue\nfunction visualizeEventLoop() {\n  const events = [];\n  \n  const log = (msg, type) => {\n    events.push({ msg, type, time: performance.now() });\n  };\n  \n  log('Start', 'sync');\n  \n  setTimeout(() => log('Macro 1', 'macro'), 0);\n  Promise.resolve().then(() => log('Micro 1', 'micro'));\n  Promise.resolve().then(() => log('Micro 2', 'micro'));\n  setTimeout(() => log('Macro 2', 'macro'), 0);\n  \n  log('End', 'sync');\n  \n  setTimeout(() => {\n    console.table(events);\n  }, 100);\n}"
        },
        {
          "type": "interview-tip",
          "tip": "Microtask Queue Key Points",
          "explanation": "EVENT LOOP ORDER:\n1. Execute synchronous code\n2. Execute ALL microtasks\n3. Execute ONE macrotask\n4. Execute ALL microtasks (from step 3)\n5. Render (if needed)\n6. Repeat from step 3\n\nMICROTASKS (high priority):\n- Promise.then/catch/finally\n- queueMicrotask()\n- MutationObserver\n- process.nextTick (Node.js)\n\nMACROTASKS (lower priority):\n- setTimeout/setInterval\n- setImmediate (Node.js)\n- I/O operations\n- UI events\n\nKEY INSIGHT:\nALL microtasks run before NEXT macrotask\n\nPRACTICAL:\n- Promises execute faster than setTimeout\n- Can cause UI freezes if too many microtasks\n- Use for batching updates\n- Understand for debugging async code"
        }
      ]
    },
    {
      "id": "section-6",
      "title": "JavaScript - Classes & OOP",
      "blocks": [
        {
          "type": "title",
          "level": 2,
          "content": "Q1. What are JavaScript classes? How do they compare to constructor functions?"
        },
        {
          "type": "description",
          "content": "Classes are syntactic sugar over JavaScript's prototype-based inheritance (ES6+). They provide a cleaner syntax for creating objects and implementing inheritance. Classes use the 'class' keyword, have constructor methods, and support inheritance via 'extends'. Under the hood, they still use prototypes."
        },
        {
          "type": "code",
          "language": "javascript",
          "title": "Classes vs Constructor Functions",
          "code": "// Constructor Function (ES5)\nfunction PersonConstructor(name, age) {\n  this.name = name;\n  this.age = age;\n}\n\nPersonConstructor.prototype.greet = function() {\n  return `Hi, I'm ${this.name}`;\n};\n\nconst person1 = new PersonConstructor('Alice', 25);\nconsole.log(person1.greet()); // 'Hi, I'm Alice'\n\n// Class (ES6+)\nclass PersonClass {\n  constructor(name, age) {\n    this.name = name;\n    this.age = age;\n  }\n  \n  greet() {\n    return `Hi, I'm ${this.name}`;\n  }\n}\n\nconst person2 = new PersonClass('Bob', 30);\nconsole.log(person2.greet()); // 'Hi, I'm Bob'\n\n// Both produce similar objects\nconsole.log(typeof PersonConstructor); // 'function'\nconsole.log(typeof PersonClass); // 'function'\nconsole.log(person1 instanceof PersonConstructor); // true\nconsole.log(person2 instanceof PersonClass); // true\n\n// Key difference: Classes must be called with 'new'\n// PersonClass(); // TypeError: Class constructor cannot be invoked without 'new'\nPersonConstructor(); // Works (but creates global variables - bad!)\n\n// Static methods\nclass MathHelper {\n  static PI = 3.14159;\n  \n  static square(n) {\n    return n * n;\n  }\n  \n  static cube(n) {\n    return n * n * n;\n  }\n}\n\nconsole.log(MathHelper.square(5)); // 25\nconsole.log(MathHelper.PI); // 3.14159\n\n// Can't call static methods on instances\nconst helper = new MathHelper();\n// helper.square(5); // TypeError\n\n// Getters and setters\nclass User {\n  constructor(firstName, lastName) {\n    this.firstName = firstName;\n    this.lastName = lastName;\n  }\n  \n  get fullName() {\n    return `${this.firstName} ${this.lastName}`;\n  }\n  \n  set fullName(name) {\n    const parts = name.split(' ');\n    this.firstName = parts[0];\n    this.lastName = parts[1];\n  }\n  \n  get initials() {\n    return `${this.firstName[0]}${this.lastName[0]}`;\n  }\n}\n\nconst user = new User('John', 'Doe');\nconsole.log(user.fullName); // 'John Doe' (no parentheses!)\nuser.fullName = 'Jane Smith';\nconsole.log(user.firstName); // 'Jane'\nconsole.log(user.initials); // 'JS'\n\n// Inheritance with extends\nclass Animal {\n  constructor(name) {\n    this.name = name;\n  }\n  \n  speak() {\n    return `${this.name} makes a sound`;\n  }\n}\n\nclass Dog extends Animal {\n  constructor(name, breed) {\n    super(name); // Must call super() first!\n    this.breed = breed;\n  }\n  \n  speak() {\n    return `${this.name} barks`;\n  }\n  \n  wagTail() {\n    return `${this.name} wags tail`;\n  }\n}\n\nconst dog = new Dog('Rex', 'German Shepherd');\nconsole.log(dog.speak()); // 'Rex barks'\nconsole.log(dog.wagTail()); // 'Rex wags tail'\nconsole.log(dog instanceof Dog); // true\nconsole.log(dog instanceof Animal); // true\n\n// Super to call parent methods\nclass Cat extends Animal {\n  speak() {\n    const parentSound = super.speak();\n    return `${parentSound}, meow!`;\n  }\n}\n\nconst cat = new Cat('Whiskers');\nconsole.log(cat.speak()); // 'Whiskers makes a sound, meow!'\n\n// Private fields (ES2022)\nclass BankAccount {\n  #balance = 0; // Private field (must be declared)\n  \n  deposit(amount) {\n    if (amount > 0) {\n      this.#balance += amount;\n    }\n  }\n  \n  withdraw(amount) {\n    if (amount > 0 && amount <= this.#balance) {\n      this.#balance -= amount;\n      return amount;\n    }\n    return 0;\n  }\n  \n  getBalance() {\n    return this.#balance;\n  }\n  \n  #auditLog(action) { // Private method\n    console.log(`Audit: ${action}`);\n  }\n}\n\nconst account = new BankAccount();\naccount.deposit(1000);\nconsole.log(account.getBalance()); // 1000\n// console.log(account.#balance); // SyntaxError: Private field\n\n// Public class fields (ES2022)\nclass Counter {\n  count = 0; // Public field (no need for constructor)\n  \n  increment() {\n    this.count++;\n  }\n}\n\nconst counter = new Counter();\ncounter.increment();\nconsole.log(counter.count); // 1\n\n// Arrow methods (automatically bound)\nclass Button {\n  label = 'Click me';\n  clicks = 0;\n  \n  // Regular method (this depends on how it's called)\n  handleClickRegular() {\n    this.clicks++;\n  }\n  \n  // Arrow function (this always refers to instance)\n  handleClickArrow = () => {\n    this.clicks++;\n  }\n}\n\nconst btn = new Button();\nconst regularHandler = btn.handleClickRegular;\nconst arrowHandler = btn.handleClickArrow;\n\n// regularHandler(); // Error: this is undefined\narrowHandler(); // Works! Arrow function preserves 'this'\n\n// Abstract pattern (no native abstract classes)\nclass Shape {\n  constructor() {\n    if (new.target === Shape) {\n      throw new Error('Cannot instantiate abstract class');\n    }\n  }\n  \n  area() {\n    throw new Error('Must implement area()');\n  }\n}\n\nclass Circle extends Shape {\n  constructor(radius) {\n    super();\n    this.radius = radius;\n  }\n  \n  area() {\n    return Math.PI * this.radius ** 2;\n  }\n}\n\n// const shape = new Shape(); // Error: Cannot instantiate abstract class\nconst circle = new Circle(5);\nconsole.log(circle.area()); // 78.53981633974483\n\n// Mixins (multiple inheritance pattern)\nconst Flyable = {\n  fly() {\n    return `${this.name} is flying`;\n  }\n};\n\nconst Swimmable = {\n  swim() {\n    return `${this.name} is swimming`;\n  }\n};\n\nclass Duck extends Animal {\n  // Duck can fly and swim\n}\n\nObject.assign(Duck.prototype, Flyable, Swimmable);\n\nconst duck = new Duck('Donald');\nconsole.log(duck.fly()); // 'Donald is flying'\nconsole.log(duck.swim()); // 'Donald is swimming'\n\n// Complex example: Observable pattern\nclass Observable {\n  #observers = [];\n  \n  subscribe(observer) {\n    this.#observers.push(observer);\n    return () => this.unsubscribe(observer); // Return unsubscribe function\n  }\n  \n  unsubscribe(observer) {\n    this.#observers = this.#observers.filter(obs => obs !== observer);\n  }\n  \n  notify(data) {\n    this.#observers.forEach(observer => observer(data));\n  }\n}\n\nclass Store extends Observable {\n  #state = {};\n  \n  getState() {\n    return { ...this.#state };\n  }\n  \n  setState(updates) {\n    this.#state = { ...this.#state, ...updates };\n    this.notify(this.#state);\n  }\n}\n\nconst store = new Store();\n\nconst unsubscribe = store.subscribe(state => {\n  console.log('State updated:', state);\n});\n\nstore.setState({ count: 1 }); // Logs: State updated: { count: 1 }\nstore.setState({ count: 2 }); // Logs: State updated: { count: 2 }\nunsubscribe();\nstore.setState({ count: 3 }); // No log (unsubscribed)"
        },
        {
          "type": "interview-tip",
          "tip": "Classes Key Points",
          "explanation": "CLASSES vs CONSTRUCTOR FUNCTIONS:\n- Classes are syntactic sugar over prototypes\n- Classes must use 'new' keyword\n- Class methods are non-enumerable\n- Classes have 'use strict' by default\n- Constructor functions are hoisted, classes are not\n\nKEY FEATURES:\n- constructor() method for initialization\n- Methods (prototype methods)\n- Static methods/fields (class-level)\n- Getters/setters (computed properties)\n- extends for inheritance\n- super() to call parent\n- Private fields (#field) - ES2022\n- Public fields - ES2022\n\nBEST PRACTICES:\n- Use classes for clear OOP patterns\n- Private fields for encapsulation\n- Arrow methods for event handlers\n- super() first in child constructor\n- Prefer composition over inheritance"
        },
        {
          "type": "title",
          "level": 2,
          "content": "Q2. Explain prototypal inheritance in JavaScript?"
        },
        {
          "type": "description",
          "content": "JavaScript uses prototypal inheritance where objects inherit from other objects. Every object has an internal [[Prototype]] link (accessed via __proto__ or Object.getPrototypeOf()) to another object. When accessing a property, JavaScript searches up the prototype chain until found or reaching null."
        },
        {
          "type": "code",
          "language": "javascript",
          "title": "Prototypal Inheritance Examples",
          "code": "// Every object has a prototype\nconst obj = { name: 'Test' };\nconsole.log(Object.getPrototypeOf(obj) === Object.prototype); // true\n\n// Prototype chain\nconst animal = {\n  eats: true,\n  walk() {\n    console.log('Animal walks');\n  }\n};\n\nconst rabbit = {\n  jumps: true,\n  __proto__: animal // Set prototype (not recommended in production)\n};\n\nconsole.log(rabbit.eats); // true (inherited from animal)\nconsole.log(rabbit.jumps); // true (own property)\nrabbit.walk(); // 'Animal walks' (inherited method)\n\n// Property lookup: own properties first, then prototype chain\nconst longEar = {\n  earLength: 10,\n  __proto__: rabbit\n};\n\nconsole.log(longEar.jumps); // true (from rabbit)\nconsole.log(longEar.eats); // true (from animal, up the chain)\nconsole.log(longEar.earLength); // 10 (own property)\n\n// Better way: Object.create()\nconst animal2 = {\n  eats: true,\n  walk() {\n    console.log('Walking');\n  }\n};\n\nconst rabbit2 = Object.create(animal2);\nrabbit2.jumps = true;\n\nconsole.log(rabbit2.eats); // true (inherited)\nconsole.log(Object.getPrototypeOf(rabbit2) === animal2); // true\n\n// Constructor function and prototype\nfunction Person(name) {\n  this.name = name;\n}\n\nPerson.prototype.greet = function() {\n  return `Hi, I'm ${this.name}`;\n};\n\nconst alice = new Person('Alice');\nconst bob = new Person('Bob');\n\nconsole.log(alice.greet()); // 'Hi, I'm Alice'\nconsole.log(bob.greet()); // 'Hi, I'm Bob'\n\n// Both instances share the same prototype\nconsole.log(alice.greet === bob.greet); // true (same function)\n\n// Prototype chain with constructor\nconsole.log(alice.__proto__ === Person.prototype); // true\nconsole.log(Person.prototype.__proto__ === Object.prototype); // true\nconsole.log(Object.prototype.__proto__); // null (end of chain)\n\n// Own vs inherited properties\nfunction Car(brand) {\n  this.brand = brand; // Own property\n}\n\nCar.prototype.wheels = 4; // Inherited property\n\nconst car = new Car('Toyota');\n\nconsole.log(car.hasOwnProperty('brand')); // true\nconsole.log(car.hasOwnProperty('wheels')); // false (inherited)\nconsole.log('wheels' in car); // true (checks entire chain)\n\n// Modifying prototype affects all instances\nconst car1 = new Car('Honda');\nconst car2 = new Car('Ford');\n\nCar.prototype.type = 'vehicle';\n\nconsole.log(car1.type); // 'vehicle'\nconsole.log(car2.type); // 'vehicle'\n\n// But own properties shadow prototype properties\ncar1.wheels = 6; // Own property\nconsole.log(car1.wheels); // 6 (own property)\nconsole.log(car2.wheels); // 4 (from prototype)\n\ndelete car1.wheels; // Remove own property\nconsole.log(car1.wheels); // 4 (now uses prototype)\n\n// Inheritance with constructor functions\nfunction Animal(name) {\n  this.name = name;\n}\n\nAnimal.prototype.eat = function() {\n  return `${this.name} is eating`;\n};\n\nfunction Dog(name, breed) {\n  Animal.call(this, name); // Call parent constructor\n  this.breed = breed;\n}\n\n// Set up inheritance\nDog.prototype = Object.create(Animal.prototype);\nDog.prototype.constructor = Dog; // Fix constructor reference\n\nDog.prototype.bark = function() {\n  return `${this.name} barks`;\n};\n\nconst dog = new Dog('Rex', 'Labrador');\nconsole.log(dog.eat()); // 'Rex is eating' (from Animal)\nconsole.log(dog.bark()); // 'Rex barks' (from Dog)\nconsole.log(dog instanceof Dog); // true\nconsole.log(dog instanceof Animal); // true\n\n// Prototype chain visualization\nfunction showPrototypeChain(obj) {\n  let current = obj;\n  let level = 0;\n  \n  while (current !== null) {\n    console.log('  '.repeat(level) + (current.constructor?.name || 'Object'));\n    current = Object.getPrototypeOf(current);\n    level++;\n  }\n  console.log('  '.repeat(level) + 'null');\n}\n\nshowPrototypeChain(dog);\n// Dog\n//   Animal\n//     Object\n//       null\n\n// Object.create() with properties\nconst vehicle = {\n  type: 'vehicle',\n  start() {\n    console.log('Starting...');\n  }\n};\n\nconst bike = Object.create(vehicle, {\n  wheels: {\n    value: 2,\n    writable: true,\n    enumerable: true,\n    configurable: true\n  },\n  brand: {\n    value: 'Yamaha',\n    writable: true,\n    enumerable: true\n  }\n});\n\nconsole.log(bike.wheels); // 2\nconsole.log(bike.type); // 'vehicle' (inherited)\nbike.start(); // 'Starting...'\n\n// Object.setPrototypeOf() (slower than Object.create)\nconst obj1 = { a: 1 };\nconst obj2 = { b: 2 };\n\nObject.setPrototypeOf(obj1, obj2);\nconsole.log(obj1.b); // 2 (inherited from obj2)\n\n// Checking prototype relationship\nconsole.log(Object.prototype.isPrototypeOf(obj1)); // true\nconsole.log(obj2.isPrototypeOf(obj1)); // true\n\n// Pure prototypal inheritance (no constructors)\nconst personPrototype = {\n  greet() {\n    return `Hello, I'm ${this.name}`;\n  }\n};\n\nfunction createPerson(name, age) {\n  const person = Object.create(personPrototype);\n  person.name = name;\n  person.age = age;\n  return person;\n}\n\nconst person1 = createPerson('Alice', 25);\nconst person2 = createPerson('Bob', 30);\n\nconsole.log(person1.greet()); // 'Hello, I'm Alice'\nconsole.log(person2.greet()); // 'Hello, I'm Bob'\n\n// Prototype pollution (security issue)\nconst obj3 = JSON.parse('{\"__proto__\": {\"isAdmin\": true}}');\n// This can pollute Object.prototype!\n\n// Safe version\nconst obj4 = Object.create(null); // No prototype\nobj4.name = 'Safe';\nconsole.log(obj4.__proto__); // undefined (no prototype chain)\n\n// Enumeration and prototype\nfunction MyClass() {\n  this.ownProp = 1;\n}\nMyClass.prototype.inheritedProp = 2;\n\nconst instance = new MyClass();\n\n// for...in iterates over enumerable properties (own + inherited)\nfor (let key in instance) {\n  console.log(key); // 'ownProp', 'inheritedProp'\n}\n\n// Object.keys() only own properties\nconsole.log(Object.keys(instance)); // ['ownProp']\n\n// Get only own enumerable properties\nfor (let key in instance) {\n  if (instance.hasOwnProperty(key)) {\n    console.log(key); // 'ownProp' only\n  }\n}\n\n// Modern classes still use prototypes\nclass Modern {\n  constructor() {\n    this.own = 1;\n  }\n  \n  method() {\n    return 'method';\n  }\n}\n\nconst modern = new Modern();\nconsole.log(modern.own); // 1 (own property)\nconsole.log(modern.method); // 'method' (from prototype)\nconsole.log(modern.hasOwnProperty('method')); // false\nconsole.log(Modern.prototype.hasOwnProperty('method')); // true"
        },
        {
          "type": "interview-tip",
          "tip": "Prototypal Inheritance Key Points",
          "explanation": "PROTOTYPE CHAIN:\n- Every object has [[Prototype]] (internal link)\n- Access via Object.getPrototypeOf() or __proto__ (deprecated)\n- Chain ends at Object.prototype → null\n- Property lookup: object → prototype → prototype → ... → null\n\nCREATING INHERITANCE:\n- Object.create(proto) - best way\n- Constructor.prototype = Object.create(Parent.prototype)\n- Class extends (modern, preferred)\n\nKEY METHODS:\n- Object.getPrototypeOf(obj)\n- Object.setPrototypeOf(obj, proto) - slow!\n- obj.hasOwnProperty(prop)\n- proto.isPrototypeOf(obj)\n\nCOMMON PATTERNS:\n- Constructor functions + prototype\n- Object.create() for delegation\n- Factory functions\n- ES6 classes (still uses prototypes)\n\nBEST PRACTICES:\n- Prefer Object.create() over __proto__\n- Use classes for clarity\n- Check hasOwnProperty() when iterating\n- Object.create(null) for dictionaries"
        },
        {
          "type": "title",
          "level": 2,
          "content": "Q3. What are static methods? When to use them?"
        },
        {
          "type": "description",
          "content": "Static methods belong to the class itself, not instances. Called on the class directly (ClassName.method()), not on objects. Used for utility functions, factory methods, or operations that don't require instance data. Cannot access instance properties (no 'this')."
        },
        {
          "type": "code",
          "language": "javascript",
          "title": "Static Methods Examples",
          "code": "// Basic static method\nclass Calculator {\n  static add(a, b) {\n    return a + b;\n  }\n  \n  static multiply(a, b) {\n    return a * b;\n  }\n}\n\n// Call on class, not instance\nconsole.log(Calculator.add(5, 3)); // 8\nconsole.log(Calculator.multiply(4, 2)); // 8\n\n// Can't call on instance\nconst calc = new Calculator();\n// calc.add(5, 3); // TypeError: calc.add is not a function\n\n// Static properties (ES2022)\nclass Config {\n  static API_URL = 'https://api.example.com';\n  static TIMEOUT = 5000;\n  static VERSION = '1.0.0';\n}\n\nconsole.log(Config.API_URL); // 'https://api.example.com'\n\n// Use case 1: Factory methods\nclass User {\n  constructor(name, email, role) {\n    this.name = name;\n    this.email = email;\n    this.role = role;\n  }\n  \n  static createAdmin(name, email) {\n    return new User(name, email, 'admin');\n  }\n  \n  static createGuest(name) {\n    return new User(name, 'guest@example.com', 'guest');\n  }\n  \n  static fromJSON(json) {\n    const data = JSON.parse(json);\n    return new User(data.name, data.email, data.role);\n  }\n}\n\nconst admin = User.createAdmin('Alice', 'alice@example.com');\nconst guest = User.createGuest('Bob');\nconst fromJson = User.fromJSON('{\"name\":\"Charlie\",\"email\":\"charlie@example.com\",\"role\":\"user\"}');\n\nconsole.log(admin); // User { name: 'Alice', email: 'alice@example.com', role: 'admin' }\n\n// Use case 2: Validation utilities\nclass Validator {\n  static isEmail(str) {\n    return /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/.test(str);\n  }\n  \n  static isPhone(str) {\n    return /^\\d{10}$/.test(str);\n  }\n  \n  static isURL(str) {\n    try {\n      new URL(str);\n      return true;\n    } catch {\n      return false;\n    }\n  }\n}\n\nconsole.log(Validator.isEmail('test@example.com')); // true\nconsole.log(Validator.isPhone('1234567890')); // true\n\n// Use case 3: Counter/singleton pattern\nclass IDGenerator {\n  static #currentId = 0;\n  \n  static generate() {\n    return ++this.#currentId;\n  }\n  \n  static reset() {\n    this.#currentId = 0;\n  }\n  \n  static getCurrent() {\n    return this.#currentId;\n  }\n}\n\nconsole.log(IDGenerator.generate()); // 1\nconsole.log(IDGenerator.generate()); // 2\nconsole.log(IDGenerator.generate()); // 3\nconsole.log(IDGenerator.getCurrent()); // 3\nIDGenerator.reset();\nconsole.log(IDGenerator.generate()); // 1\n\n// Use case 4: Comparison/sorting\nclass Person {\n  constructor(name, age) {\n    this.name = name;\n    this.age = age;\n  }\n  \n  static compareByAge(a, b) {\n    return a.age - b.age;\n  }\n  \n  static compareByName(a, b) {\n    return a.name.localeCompare(b.name);\n  }\n}\n\nconst people = [\n  new Person('Charlie', 25),\n  new Person('Alice', 30),\n  new Person('Bob', 20)\n];\n\npeople.sort(Person.compareByAge);\nconsole.log(people.map(p => p.name)); // ['Bob', 'Charlie', 'Alice']\n\npeople.sort(Person.compareByName);\nconsole.log(people.map(p => p.name)); // ['Alice', 'Bob', 'Charlie']\n\n// Static this refers to the class\nclass Animal {\n  static className = 'Animal';\n  \n  static getClassName() {\n    return this.className; // 'this' is the class\n  }\n  \n  static create(name) {\n    return new this(name); // 'this' is the class\n  }\n}\n\nclass Dog extends Animal {\n  static className = 'Dog';\n  \n  constructor(name) {\n    super();\n    this.name = name;\n  }\n}\n\nconsole.log(Animal.getClassName()); // 'Animal'\nconsole.log(Dog.getClassName()); // 'Dog' (inherited, uses Dog's className)\n\nconst dog = Dog.create('Rex');\nconsole.log(dog instanceof Dog); // true\n\n// Static inheritance\nclass Parent {\n  static parentMethod() {\n    return 'parent';\n  }\n}\n\nclass Child extends Parent {\n  static childMethod() {\n    return 'child';\n  }\n  \n  static combinedMethod() {\n    return super.parentMethod() + ' + child';\n  }\n}\n\nconsole.log(Child.parentMethod()); // 'parent' (inherited)\nconsole.log(Child.childMethod()); // 'child'\nconsole.log(Child.combinedMethod()); // 'parent + child'\n\n// Real-world: Database model\nclass Model {\n  static tableName = '';\n  static #cache = new Map();\n  \n  static async find(id) {\n    if (this.#cache.has(id)) {\n      return this.#cache.get(id);\n    }\n    \n    const data = await fetch(`/api/${this.tableName}/${id}`)\n      .then(r => r.json());\n    \n    const instance = new this(data);\n    this.#cache.set(id, instance);\n    return instance;\n  }\n  \n  static async findAll() {\n    const data = await fetch(`/api/${this.tableName}`)\n      .then(r => r.json());\n    return data.map(item => new this(item));\n  }\n  \n  static clearCache() {\n    this.#cache.clear();\n  }\n}\n\nclass UserModel extends Model {\n  static tableName = 'users';\n  \n  constructor(data) {\n    super();\n    Object.assign(this, data);\n  }\n}\n\n// Usage\nconst user = await UserModel.find(1);\nconst allUsers = await UserModel.findAll();\n\n// Built-in examples\nconsole.log(Array.isArray([1, 2, 3])); // true (static method)\nconsole.log(Object.keys({ a: 1 })); // ['a'] (static method)\nconsole.log(Math.max(1, 2, 3)); // 3 (static method)\nconsole.log(Number.parseInt('42')); // 42 (static method)\n\n// Static vs instance methods\nclass Example {\n  constructor(value) {\n    this.value = value;\n  }\n  \n  // Instance method - needs instance data\n  instanceMethod() {\n    return this.value * 2;\n  }\n  \n  // Static method - doesn't need instance\n  static staticMethod(value) {\n    return value * 2;\n  }\n}\n\nconst ex = new Example(5);\nconsole.log(ex.instanceMethod()); // 10 (uses instance data)\nconsole.log(Example.staticMethod(5)); // 10 (no instance needed)\n\n// Static blocks (ES2022) - initialization\nclass DatabaseConnection {\n  static #connection = null;\n  \n  static {\n    // Static initialization block\n    console.log('Initializing database connection...');\n    this.#connection = { connected: true };\n  }\n  \n  static getConnection() {\n    return this.#connection;\n  }\n}\n\n// Private static fields\nclass SecretKeeper {\n  static #secret = 'top-secret';\n  \n  static getSecret(password) {\n    if (password === 'admin123') {\n      return this.#secret;\n    }\n    throw new Error('Access denied');\n  }\n}\n\nconsole.log(SecretKeeper.getSecret('admin123')); // 'top-secret'\n// console.log(SecretKeeper.#secret); // SyntaxError"
        },
        {
          "type": "interview-tip",
          "tip": "Static Methods Best Practices",
          "explanation": "WHEN TO USE STATIC:\n- Utility/helper functions (no instance data needed)\n- Factory methods (create instances)\n- Constants and configuration\n- Counters/singletons\n- Validation functions\n- Comparison functions for sorting\n\nSTATIC vs INSTANCE:\n- Static: belongs to class, no 'this' instance access\n- Instance: belongs to objects, has 'this' access\n\nKEY FEATURES:\n- Called on class: ClassName.method()\n- Can't access instance properties\n- Can access other static members\n- Inherited by child classes\n- 'this' refers to the class\n\nCOMMON PATTERNS:\n- Math utilities\n- Factory methods\n- Validation\n- ORM/Model methods (find, findAll)\n\nEXAMPLES IN WILD:\n- Array.isArray()\n- Object.keys()\n- Math.max()\n- Number.parseInt()"
        },
        {
          "type": "title",
          "level": 2,
          "content": "Q4. What are getters and setters? How do they work?"
        },
        {
          "type": "description",
          "content": "Getters and setters are special methods that allow you to define how properties are accessed and modified. Getters (get) execute when reading a property, setters (set) execute when writing. Used for computed properties, validation, data transformation, and controlled access to private fields."
        },
        {
          "type": "code",
          "language": "javascript",
          "title": "Getters & Setters Examples",
          "code": "// Basic getter and setter\nclass Person {\n  constructor(firstName, lastName) {\n    this.firstName = firstName;\n    this.lastName = lastName;\n  }\n  \n  // Getter - accessed like a property\n  get fullName() {\n    return `${this.firstName} ${this.lastName}`;\n  }\n  \n  // Setter - assigned like a property\n  set fullName(name) {\n    const parts = name.split(' ');\n    this.firstName = parts[0];\n    this.lastName = parts[1] || '';\n  }\n}\n\nconst person = new Person('John', 'Doe');\nconsole.log(person.fullName); // 'John Doe' (no parentheses!)\n\nperson.fullName = 'Jane Smith'; // Calls setter\nconsole.log(person.firstName); // 'Jane'\nconsole.log(person.lastName); // 'Smith'\n\n// Getter for computed property\nclass Circle {\n  constructor(radius) {\n    this.radius = radius;\n  }\n  \n  get diameter() {\n    return this.radius * 2;\n  }\n  \n  get circumference() {\n    return 2 * Math.PI * this.radius;\n  }\n  \n  get area() {\n    return Math.PI * this.radius ** 2;\n  }\n}\n\nconst circle = new Circle(5);\nconsole.log(circle.diameter); // 10\nconsole.log(circle.circumference); // 31.41592653589793\nconsole.log(circle.area); // 78.53981633974483\n\n// Setter with validation\nclass User {\n  #age = 0; // Private field\n  \n  get age() {\n    return this.#age;\n  }\n  \n  set age(value) {\n    if (typeof value !== 'number') {\n      throw new TypeError('Age must be a number');\n    }\n    if (value < 0 || value > 150) {\n      throw new RangeError('Age must be between 0 and 150');\n    }\n    this.#age = value;\n  }\n}\n\nconst user = new User();\nuser.age = 25; // Valid\nconsole.log(user.age); // 25\n\ntry {\n  user.age = -5; // Invalid\n} catch (e) {\n  console.error(e.message); // 'Age must be between 0 and 150'\n}\n\n// Read-only property (getter without setter)\nclass Product {\n  constructor(price, taxRate = 0.1) {\n    this.price = price;\n    this.taxRate = taxRate;\n  }\n  \n  get totalPrice() {\n    return this.price * (1 + this.taxRate);\n  }\n}\n\nconst product = new Product(100);\nconsole.log(product.totalPrice); // 110\nproduct.totalPrice = 200; // Silently ignored (no setter)\nconsole.log(product.totalPrice); // Still 110\n\n// Write-only property (setter without getter) - rare\nclass Logger {\n  set log(message) {\n    console.log(`[${new Date().toISOString()}] ${message}`);\n  }\n}\n\nconst logger = new Logger();\nlogger.log = 'User logged in'; // Calls setter\n// console.log(logger.log); // undefined (no getter)\n\n// Getter/setter with private field\nclass Temperature {\n  #celsius = 0;\n  \n  get celsius() {\n    return this.#celsius;\n  }\n  \n  set celsius(value) {\n    this.#celsius = value;\n  }\n  \n  get fahrenheit() {\n    return this.#celsius * 9/5 + 32;\n  }\n  \n  set fahrenheit(value) {\n    this.#celsius = (value - 32) * 5/9;\n  }\n}\n\nconst temp = new Temperature();\ntemp.celsius = 0;\nconsole.log(temp.fahrenheit); // 32\n\ntemp.fahrenheit = 212;\nconsole.log(temp.celsius); // 100\n\n// Lazy initialization with getter\nclass DataLoader {\n  #data = null;\n  \n  get data() {\n    if (this.#data === null) {\n      console.log('Loading data...');\n      this.#data = this.#loadData();\n    }\n    return this.#data;\n  }\n  \n  #loadData() {\n    // Expensive operation\n    return Array.from({ length: 1000 }, (_, i) => i);\n  }\n}\n\nconst loader = new DataLoader();\nconsole.log('Created loader');\nconsole.log(loader.data.length); // Logs 'Loading data...' then 1000\nconsole.log(loader.data.length); // 1000 (no loading, cached)\n\n// Object literal getters/setters\nconst account = {\n  balance: 1000,\n  transactions: [],\n  \n  get formattedBalance() {\n    return `$${this.balance.toFixed(2)}`;\n  },\n  \n  set deposit(amount) {\n    if (amount > 0) {\n      this.balance += amount;\n      this.transactions.push({ type: 'deposit', amount });\n    }\n  },\n  \n  set withdraw(amount) {\n    if (amount > 0 && amount <= this.balance) {\n      this.balance -= amount;\n      this.transactions.push({ type: 'withdraw', amount });\n    }\n  }\n};\n\nconsole.log(account.formattedBalance); // '$1000.00'\naccount.deposit = 500;\naccount.withdraw = 200;\nconsole.log(account.formattedBalance); // '$1300.00'\nconsole.log(account.transactions);\n\n// Defining getter/setter with Object.defineProperty\nconst obj = {};\n\nObject.defineProperty(obj, 'name', {\n  get() {\n    return this._name || 'Unknown';\n  },\n  set(value) {\n    this._name = value.toUpperCase();\n  },\n  enumerable: true,\n  configurable: true\n});\n\nobj.name = 'alice';\nconsole.log(obj.name); // 'ALICE'\n\n// Chaining setters\nclass Builder {\n  #config = {};\n  \n  set name(value) {\n    this.#config.name = value;\n    return this; // Return 'this' for chaining\n  }\n  \n  set age(value) {\n    this.#config.age = value;\n    return this;\n  }\n  \n  build() {\n    return { ...this.#config };\n  }\n}\n\nconst builder = new Builder();\n// Note: Setters can't actually return values that are used\n// This pattern doesn't work with setters\n// builder.name = 'Alice'.age = 25; // Doesn't work\n\n// Better: Use methods for chaining\nclass FluentBuilder {\n  #config = {};\n  \n  name(value) {\n    this.#config.name = value;\n    return this;\n  }\n  \n  age(value) {\n    this.#config.age = value;\n    return this;\n  }\n  \n  build() {\n    return { ...this.#config };\n  }\n}\n\nconst config = new FluentBuilder()\n  .name('Alice')\n  .age(25)\n  .build();\n\nconsole.log(config); // { name: 'Alice', age: 25 }\n\n// Getter/setter performance\nclass WithGetter {\n  get value() {\n    return this._value;\n  }\n  set value(v) {\n    this._value = v;\n  }\n}\n\nclass WithProperty {\n  // Direct property access is faster\n}\n\n// For simple cases, direct property is faster\n// For computed/validated values, getters/setters are worth it\n\n// Real-world: Form validation\nclass FormField {\n  #value = '';\n  #errors = [];\n  \n  get value() {\n    return this.#value;\n  }\n  \n  set value(val) {\n    this.#value = val;\n    this.#validate();\n  }\n  \n  get isValid() {\n    return this.#errors.length === 0;\n  }\n  \n  get errors() {\n    return [...this.#errors];\n  }\n  \n  #validate() {\n    this.#errors = [];\n    if (this.#value.length < 3) {\n      this.#errors.push('Too short');\n    }\n  }\n}\n\nconst field = new FormField();\nfield.value = 'ab';\nconsole.log(field.isValid); // false\nconsole.log(field.errors); // ['Too short']\n\nfield.value = 'abc';\nconsole.log(field.isValid); // true"
        },
        {
          "type": "interview-tip",
          "tip": "Getters & Setters Key Points",
          "explanation": "SYNTAX:\n- get propertyName() { return value; }\n- set propertyName(value) { this.field = value; }\n- Accessed like properties: obj.prop (no parentheses)\n\nUSE CASES:\n1. Computed properties (derived from other values)\n2. Validation (check before setting)\n3. Data transformation (format, normalize)\n4. Lazy loading (compute on first access)\n5. Controlled access to private fields\n6. Read-only properties (getter only)\n7. Side effects (logging, notifications)\n\nBENEFITS:\n- Cleaner API (looks like property access)\n- Encapsulation (hide implementation)\n- Validation on assignment\n- Backward compatibility (can change internal implementation)\n\nLIMITATIONS:\n- Getters should be fast (no heavy computation)\n- Setters can't return values (for chaining)\n- Can't be async\n\nBEST PRACTICES:\n- Use with private fields for encapsulation\n- Keep getters simple and fast\n- Validate in setters\n- Don't perform side effects in getters"
        }
      ]
    }
  ]
}
